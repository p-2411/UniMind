PDFs to Text — Consolidated Output (pypdf-only)
===============================================

Source folder: /Users/parhamsepasgozar/Desktop/UniMind/slides/2521T3
Matched PDFs: 15
Generated at: 2025-10-01 03:02:30

[1/15] week01lec01-intro.pdf
----------------------------

COMP2521
25T3
Introduction
Tools
Welcome!
COMP2521 25T3
Data Structures and Algorithms
COMP2521
25T3
Introduction
Tools
COMP2521 25T3
Introduction
Sim Mautner
cs2521@cse.unsw.edu.au
course introduction
tools of the trade
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Course Goals
to get you thinking like a computer scientist
not just a programmer
• know and understand fundamental data structures, algorithms
• reason about applicability + effectiveness
• analyse behaviour/correctness of programs
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assumed Knowledge
We assume that you can:
• Produce a correct C program from a specification
• Use fundamental control structures
(sequence, selection ( if), iteration (while))
• Use fundamental C data types and data structures
(char, int, double, arrays, structs, pointers, linked lists)
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acquired Knowledge
In this course, you will learn:
• data structures: trees, graphs, hash tables, tries
• data structure/algorithm analysis: time/space complexity
• sorting and searching techniques
• graph algorithms
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acquired Skills
By the end of this course, you should be able to:
• Implement solutions to a wider range of problems
• Analyse performance characteristics of algorithms
• Analyse performance characteristics of data structures
• Make decisions about appropriate data structures and algorithms
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Course Staff
Convenor John Shepherd
Lecturer Sim Mautner
Admins Kevin Luxa, Ethan Brown and Ryan Berlee
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Contact
Website https://webcms3.cse.unsw.edu.au/COMP2521/25T3/
Email cs2521@cse.unsw.edu.au
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Teaching/Assessment Methods
Lectures
Tutorials
Labs
Quizzes
Assignments
Exam
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Lectures
Four hours of lectures per week
• Monday 14:00–16:00; Wednesday 11:00–13:00
• In person in E19 Patricia O’Shane 104
• Also livestreamed via YouTube
• Link to livestream on the lectures page
• Feel free to ask questions in the chat
• Recordings will be on YouTube
• present a brief overview of theory
• demonstrate problem-solving methods
• give practical demonstrations
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Tutorials
Weekly one-hour tutorials
• tutorials start in week 1
• run every week, except flex week
• online classes are via Blackboard Collaborate
• tutorials clarify lecture material
• work through problems related to lecture topics
• questions available (usually) the week before
• answers available Friday evening
To get the best out of tutorials
• read and attempt the problems yourself beforehand
• don’t keep quiet in tutorials… talk, discuss, …
• ask if you don’t understand something
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Labs
Each tutorial is followed by a two-hour lab class
• several exercises, mostly small implementation/analysis tasks
• aim to improve your coding and analysis skills
• give you experience applying algorithms and techniques
• done individually, unless specified
• submitted via give, before Monday 17:00 09:00 the following week
• many labs have a handmarking component (see spec for details)
• handmarking completed by showing your work to your tutor in the lab
within two weeks of the lab
• worth 15% of your final mark, best 7 of 8 labs used to calculate the 15%
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Quizzes
Weekly quizzes
• on WebCMS
• questions about previous week’s lectures
• different kinds of questions
• multiple choice, multiple select, fill-in-the-blank…
• aim to test your knowledge and understanding of the theory
• done individually
• due Monday 17:00 09:00 the following week
• can submit multiple times, only last submission is marked
• worth 10% of your final mark, best 7 of 8 quizzes used to calculate the
10%
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assignments
Two assignments
• each worth 15% of your final mark
• give you experience applying algorithms to larger problems
• done individually
• help sessions will be available to assist with assignments
• will be very busy in the last days before an assignment is due
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Late Penalties
Labs, quizzes and assignments all have the same late penalty
• UNSW standard late penalty
• 0.2% of the maximum mark taken from your raw mark for each hour late
• equivalent to 4.8% per day
• submissions later than 5 days not allowed (automatically enforced)
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Sample Solutions and Marking
Due to the UNSW standard late penalty allowing late submissions up to 5
days after the deadline, along with extensions for special consideration:
• sample solutions for labs will be released 12 days after the due date
• marks for labs will be released a week after the due date
• answers and marks for quizzes will be released 5 days after the due date
• sample solutions for assignments are not released
• marks for assignments are released in two parts
• automarking will be released a week after the due date
• handmarking (style, automarking adjustments) takes longer and will be
released 2 weeks after the automarking
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Final Exam
• 3 hour in-person exam, during exam period
• Limited resources provided
• Two sections:
• Theory - short-answer questions
• Programming - programming questions
• To pass the exam hurdle, you must:
• score at least 18/45 (40%) on the final exam
• score at least 25% in the theory section of the exam
• score at least 25% in the programming section of the exam
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Special Consideration
• Have you been impacted by unforeseen adverse circumstances?
• Has it affected your ability to complete coursework?
• You can apply for special consideration via myUNSW
• Find out how to apply here:
https://student.unsw.edu.au/special-consideration
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assessment
Summary:
15% labs
10% quizzes
15% assignment 1
15% assignment 2
45% final exam
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assessment
To pass COMP2521, you must:
• score at least 50/100 overall
• pass the exam hurdle
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Academic Integrity
• Labs, quizzes and assignments must be entirely your own work
• Plagiarism will be checked for and penalised
• Plagiarism may result in suspension from UNSW
• Scholarship students may lose their scholarship
• International students may lose their visa
• Supplying your work to any other person may result in loss of all your
marks for the lab/assignment
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Academic Integrity
Generative AI Tools
• Use of generative AI tools, e.g., GitHub Copilot, ChatGPT, with the
intention of generating answers/solutions for assessment tasks is not
permitted
• Use of generative AI tools for learning is permitted
• You must still be critical of any response you get from these tools
• Generative AI tools have great potential to assist coders, but use of them
requires good understanding of the language/system
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Resources
Additional Help
• Discourse forum
• Weekly consultations
• Starting from week 2
• Wednesday 1pm-2pm
• In person (location to be confirmed)
• For clarification of course content
• Help sessions
• Starting from week 2
• Schedule on course website
• For help with labs and assignments
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Resources
Additional Exercises
• Attempt lecture excercises by yourself using the startercode provided
• Practice exercises by topic: here
• Extra lab exercises
• LeetCode/HackerRank problems for more practice: here
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Expectations
What we expect from you
• Check your email regularly
• Announcements will be sent to your email
• Your tutor will send you emails
• Reminders of unsubmitted work will be sent to your email
• Read the spec before asking questions
• Don’t ask questions that are already answered in the spec
• Attempt to debug your program yourself before asking for help
• Debugging may involve adding print statements or using gdb to check the
state of the program at various points, or drawing diagrams to visualise
the program’s execution
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Expectations
What you can expect from us
• Regular announcements/updates
• Lecture slides released before lectures
• Minimal typos/mistakes in lecture slides
• Tutorial questions/lab exercises released on time (by the weekend
before)
• Assignments released on time
• Assignments marked on time
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Advice
• Keep up with lectures
Labs and quizzes require you to know content from recent lectures
• Attend tutorials, especially if you are falling behind
Tutors will not judge you for falling behind
• Always try to understand, instead of just memorise
Understanding something makes it easier to remember
Exam questions will be different from what you’ve seen
• Programming is a skill that improves with practice
The more you practice, the easier labs, assignments and the exam will be
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Advice
Engage, ask questions, go to consults, do practice exercises...
You can improve if you put in the effort!
COMP2521
25T3
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acknowledgements
COMP2521 material drawn from...
• slides by Jashank Jeremy (COMP2521 19T0)
• slides by Angela Finlayson (COMP2521 18x1)
• slides by John Shepherd (COMP1927 16s2)
• slides by Gabriele Keller (COMP1927 12s2)
• lectures by Richard Buckland (COMP1927 09s2)
• slides by Manuel Chakravarty (COMP1927 08s1)
• notes by Aleks Ignjatovic (COMP2011 ’05)
• slides and books by Robert Sedgewick
• Book Cormen, Thomas H.; Lieserson, Charles E.; Rivest, Ronald L.; Stein,
Clifford, Introduction to Algorithms (4th ed.). MIT Press and McGraw-Hill,
2022
• slides by Kevin Luxa (COMP2521 25T1)
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
The Tools of the Trade
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation

COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
{Address, Leak, Memory, Thread, DataFlow,UndefinedBehavior}Sanitizer
a family of compiler plugins, developed by Google
which instrument executing code with sanity checks
use-after-free, array overruns, value overflows, uninitialised values, and more
you’ve been using ASan+UBSan already: dcc uses them!
usable on your own *nix systems (Linuxes, BSDs, ‘macOS’) too!
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer
• Detects invalid memory accesses, such as:
• Out-of-bounds array accesses
• Use-after-free errors
• Double-free errors
• …and many others
• To use AddressSanitizer, compile with -fsanitize=address
• Our Makefiles compile with AddressSanitizer by default
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer - Example
#include <stdio.h>
#define SIZE 5
int main(void) {
int arr[SIZE];
int i = 0;
while (scanf("%d", &arr[i]) == 1) {
i++;
}
...
}
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer - Example

COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
LeakSanitizer
• Detects memory leaks
• To use LeakSanitizer, compile with -fsanitize=leak
• Example of error that would be caught by LeakSanitizer:
#include <stdlib.h>
int main(void) {
int *a = malloc(sizeof(int));
*a = 42;
// free(a);
}
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
MemorySanitizer
• Detects uninitialized memory access
• To use MemorySanitizer, compile with -fsanitize=memory
• Example of error that would be caught by MemorySanitizer:
#include <stdio.h>
int main(void) {
int arr[10];
arr[0] = 42;
if (arr[1] == 0) {
printf("zero\n");
}
}
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
UndefinedBehaviorSanitizer
• Detects wide range of undefined behaviours
• To use UndefinedBehaviorSanitizer, compile with
-fsanitize=undefined
• Example of error that would be caught by UndefinedBehaviorSanitizer:
#include <limits.h>
#include <stdio.h>
int main(void) {
int a = INT_MAX;
printf("%d\n", a + 1);
}
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
valgrind
• finding memory leaks
… not free’ing memory that you malloc’d
• finding memory errors
… illegally trying access memory
$ valgrind ./prog
...
==29601== HEAP SUMMARY:
==29601== in use at exit: 64 bytes in 1 blocks
==29601== total heap usage: 1 allocs, 0 frees, 64 bytes allocated
==29601==
==29601== LEAK SUMMARY:
==29601== definitely lost: 64 bytes in 1 blocks
Valgrind doesn’t play well with ASan. Compile without ASan if you want to use it.
COMP2521
25T3
Introduction
Tools
Compilation
Sanitizers
valgrind
make
make
Can’t be bothered typing long compilation commands?
make lets you specify
rules, dependencies, variables
in a Makefile
to define what a program needs to be compiled
With a Makefile, all you need to do to compile is to type
make


================================================================================

[2/15] week01lec01-recursion.pdf
--------------------------------

COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
COMP2521 25T3
Recursion
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion

COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Definition
Recursion is a problem solving strategy
where problems are solved via solving subproblems
(smaller or simpler instances of the same problem)
In programming, we solve problems recursively by
using functions that call themselves
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion
The Sierpinski triangle
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid

COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Iteratively
1
 2
3
 4
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Iteratively
To build a pyramid of width n:
• For each width w from n down to 1 (decrementing by 2 each time):
• Build a w × w layer of blocks on top
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
1
Build a 7 x 7 layer of blocks
2
Build a pyramid of width 5 on top!
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
What’s wrong with this method?
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
What’s wrong with this method?
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 If n ≤ 0, do nothing
2 Otherwise:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
The factorial of n (where n ≥ 0)
denoted by n!
is the product of all positive integers
less than or equal to n.
n! =n × (n − 1) × (n − 2) × · · · ×2 × 1
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Iteratively
Iterative method:
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Observation:
n! =n × (n − 1) × (n − 2) × · · · ×2 × 1
= n × (n − 1)!
For example:
4! = 4× 3 × 2 × 1
= 4× 3!
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
return n * factorial(n - 1);
}
What’s wrong with this function?
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
return n * factorial(n - 1);
}
What’s wrong with this function?
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
if (n == 0) {
return 1;
} else {
return n * factorial(n - 1);
}
}
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Example:
factorial(3) = 3 * factorial(2)
= 3 * (2 * factorial(1))
= 3 * (2 * (1 * factorial(0)))
= 3 * (2 * (1 * 1))
= 3 * (2 * 1)
= 3 * 2
= 6
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
• A recursive function calls itself
• This is possible because there is a difference between a function and a
function call
• Each function call creates a new mini-environment, called a stack frame,
that holds all the local variables used by the function call
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Consider this program (no recursion):
int main(void) {
a(5);
}
void a(int val) {
b(val);
}
void b(int val) {
printf("%d\n", val);
}
This is how the state of the stack changes:
main() main()
a(5)
main()
a(5)
b(5)
main()
a(5)
main()
main calls a a calls b b returns a returns
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Now consider factorial(2):
int factorial(int n) {
if (n == 0) {
return 1;
} else {
return n * factorial(n - 1);
}
}
This is how the state of the stack changes:
fact(2) fact(2)
fact(1)
fact(2)
fact(1)
fact(0)
fact(2)
fact(1)
fact(2)
fact(2)
calls
fact(1)
fact(1)
calls
fact(0)
fact(0)
returns
1
fact(1)
returns
1 x 1 = 1
fact(2)
returns
2 x 1 = 2
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
When the function recurses, that is called “winding”
When recursive calls return, that is called “unwinding”
fact(4) fact(4)
fact(3)
fact(4)
fact(3)
fact(2)
fact(4)
fact(3)
fact(2)
fact(1)
fact(4)
fact(3)
fact(2)
fact(1)
fact(0)
fact(4)
fact(3)
fact(2)
fact(1)
fact(4)
fact(3)
fact(2)
fact(4)
fact(3)
fact(4)
winding unwinding
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Pre-order operations
Operations before the recursive call occur during winding.
Post-order operations
Operations after the recursive call occur during unwinding.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion on Linked Lists
Recall that recursion is
a problem solving strategy where problems are solved via
solving smaller or simpler instances of the same problem
How do we apply recursion to linked lists?
list 4 5 7
smaller linked list
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion on Linked Lists
Recall that recursion is
a problem solving strategy where problems are solved via
solving smaller or simpler instances of the same problem
How do we apply recursion to linked lists?
list 4 5 7
smaller linked list
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Example: summing values of a list
• Base case: empty list
• Sum of an empty list is zero
• Non-empty lists
• I can’t solve the whole problem directly
• But I do know the first value in the list
• And if I can sum the rest of the list (smaller than whole list)
• Then I can add the first value to the sum of the rest of the list, giving the
sum of the whole list
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Example:
listSum([3, 1, 4]) = 3 + listSum([1, 4])
= 3 + (1 + listSum([4]))
= 3 + (1 + (4 + listSum([])))
= 3 + (1 + (4 + 0))
= 3 + (1 + 4)
= 3 + 5
= 8
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Recursive method:
struct node {
int value;
struct node *next;
};
int listSum(struct node *list) {
if (list == NULL) {
return 0;
} else {
return list->value + listSum(list->next);
}
}
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How to Write a Recursive Function
First, think:
• How can the solution be expressed in terms of subproblems?
• What would the subproblem(s) be?
• How can you relate the original problem to the subproblem(s)?
• What are the base cases?
Then, implement:
• Implement base case(s) first
• Then implement recursive cases
• Each subproblem corresponds to a recursive call
• Assume that the function works for the subproblem(s)
• Like in Mathematical Induction!
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Exercises
Exercise 1:
• Given a linked list, print the items in the list in reverse.
Exercise 2:
• Given a linked list, print every second item.
Exercise 3:
• Given a linked list and an index, return the value at that index. Index 0
corresponds to the first value, index 1 the second value, and so on.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Example: append a value to a list
struct node *listAppend(struct node *list, int value) {
...
}
listAppendshould insert the given value at the end of the given list and
return a pointer to the start of the updated list.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
What’s wrong with this solution?
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
Consider this list…
myList
4
…and this function call:
listAppend(myList, 5);
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
The recursive call on line 5 creates a new node and returns it...
list
4 5
…but this new node is not attached to the list!
The node containing 4 still points to NULL.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Correct solution:
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 list->next = listAppend(list->next, value);
6 return list;
7 }
8 }
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Why does this work?
list->next = listAppend(list->next, value);
Consider the following list:
list
4 rest of the list
Two cases to consider:
(1) The rest of the list is empty
(2) The rest of the list is not empty
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 …
5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 … 5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 … 5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
More Exercises
Exercise 1:
• Given a linked list, return a copy of the linked list.
Exercise 2:
• Given a linked list and a value, delete the first instance of the value from
the list (if it exists), and return the updated list.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Sometimes, recursive solutions require recursive helper functions
• Data structure uses a “wrapper” struct
• Recursive function needs to take in extra information (e.g., state)
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
Wrapper struct for a linked list:
struct list
head
4 5 7 struct node {
int value;
struct node *next;
};
struct list {
struct node *head;
};
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
Example: Implement this function:
void listAppend(struct list *list, int value);
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
void listAppend(struct list *list, int value);
We can’t recurse with this function because our recursive function needs to
take in a struct nodepointer.
Solution: Use a recursive helper function!
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
void listAppend(struct list *list, int value) {
list->head = doListAppend(list->head, value);
}
struct node *doListAppend(struct node *node, int value) {
if (node == NULL) {
return newNode(value);
} else {
node->next = doListAppend(node->next, value);
return node;
}
}
Our convention for naming recursive helper functions is to prepend “do” to
the name of the original function.
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Passing extra information
Problem:
• Print a linked list in a numbered list format, starting from 1.
void printNumberedList(struct node *list);
Example:
• Suppose the input list contains the following elements: [11, 9, 2023]
• We expect the following output:
1. 11
2. 9
3. 2023
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Passing extra information
We need to keep track of the current number.
Solution:
• Use a recursive helper function that takes in an extra integer
void printNumberedList(struct node *list) {
doPrintNumberedList(list, 1);
}
void doPrintNumberedList(struct node *list, int num) {
if (list == NULL) return;
printf("%d. %d\n", num, list->value);
doPrintNumberedList(list->next, num + 1);
}
COMP2521
25T3
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion vs. Iteration
• If there is a simple iterative solution, a recursive solution will
generally be slower
• Due to a stack frame needing to be created for each function call
• A recursive solution will generally use more memory than an iterative
solution


================================================================================

[3/15] week01lec02-analysis.pdf
-------------------------------

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
COMP2521 25T3
Analysis of Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Motivation
• Program efficiency is critical for many applications:
• Finance, robotics, games, database systems, ...
• We may want to compare programs to decide which one to use
• We may want to determine whether a program will be “fast enough”
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Program Efficiency
What determines how fast a program runs?
• The operating system?
• Compilers?
• Hardware?
• E.g., CPU, GPU, cache
• Load on the machine?
• Most important: the data structures and algorithms used
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Algorithm Efficiency
• The running time of an algorithm tends to be a function of input size
• Typically: larger input ⇒ longer running time
• Small inputs: fast running time , regardless of algorithm
• Larger inputs: slower, but how much slower?

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
What to Analyse?
• Best-case performance
• Not very useful
• Usually only occurs for specific types of input
• Average-case performance
• Difficult; need to know how the program is used
• Worst-case performance
• Most important; determines how long the program could possibly run
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Time Complexity
Time complexity is
the amount of time it takes to run an algorithm,
as a function of the input size
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Time Complexity
Example functions:
n2
6n
n log2 n
20 log2 n
input size
time
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Analysing Time Complexity
The time complexity of an algorithm can be analysed in two ways:
• Empirically: Measuring the time that a program implementing the
algorithm takes to run
• Theoretically: Counting the number of operations or “steps” performed
by the algorithm as a function of input size
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Searching
The search problem:
Given an array of size n and a value,
return the index containing the value if it exists,
otherwise return -1.
[0]
2
[1]
16
[2]
11
[3]
1
[4]
9
[5]
4
[6]
15
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
1 Write a program that implements the algorithm
2 Run the program with inputs of varying size and composition
3 Measure the running time of the algorithm
4 Plot the results
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
We can measure the running time of an algorithm using clock(3).
• The clock() function determines the amount of processor time used
since the start of the process.
#include <time.h>
clock_t start = clock();
// algorithm code here...
clock_t end = clock();
double seconds = (double)(end - start) / CLOCKS_PER_SEC;
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Absolute times will differ
between machines, between languages
…so we’re not interested in absolute time.
We are interested in the relative change
as the input size increases
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Which algorithm is more efficient?

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Compare growth rates, not absolute times

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
Let’s empirically analyse the following search algorithm:
// Returns the index of the given value in the array
// if it exists, or -1 otherwise
int linearSearch(int arr[], int size, int val) {
for (int i = 0; i < size; i++) {
if (arr[i] == val) {
return i;
}
}
}
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
// Returns the index of the given value in the array if it exists,
// or -1 otherwise
int linearSearch(int arr[], int size, int val) {
for (int i = 0; i < size; i++) {
if (arr[i] == val) {
return i;
}
}
return -1;
}
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
Sample results:
Input Size Running Time
1,000,000 0.002
10,000,000 0.023
100,000,000 0.240
200,000,000 0.471
300,000,000 0.702
400,000,000 0.942
500,000,000 1.196
1,000,000,000 2.384
The worst-case running time of linear search
grows linearly as the input size increases.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Limitations of Empirical Analysis
• Requires implementation of algorithm
• Different choice of input data ⇒ different results
• Choosing good inputs is extremely important
• Timing results affected by runtime environment
• E.g., load on the machine
• In order to compare two algorithms...
• Need “comparable” implementation of each algorithm
• Must use same inputs, same hardware, same O/S, same load
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Theoretical Analysis
• Uses high-level description of algorithm (pseudocode)
• Can use the code if it is implemented already
• Characterises running time as a function of input size
• Allows us to evaluate the efficiency of the algorithm
• Independent of the hardware/software environment
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Pseudocode
• Pseudocode is a plain language description of the steps in an algorithm
• Uses structural conventions of a regular programming language
• if statements, loops
• Omits language-specific details
• variable declarations
• allocating/freeing memory
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Pseudocode
Pseudocode for linear search:
linearSearch(A, val):
Input: array A of size n, value val
Output: index of val in A if it exists
-1 otherwise
for i from 0 up to n − 1:
if A[i] = val:
return i
return -1
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Primitive Operations
Every algorithm uses a core set of basic operations.
Examples:
• Assignment
• Indexing into an array
• Calling/returning from a function
• Evaluating an expression
• Increment/decrement
We call these operations primitive operations.
Assume that primitive operations take the same constant amount of time.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Example
How many primitive operations are performed by this line of code?
for (int i = 0; i < n; i++)
The assignment i = 0occurs 1 time
The comparison i < noccurs n + 1 times
The increment i++occurs n times
Total: 1 + ( n + 1) + n primitive operations
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Example
How many primitive operations are performed by this line of code?
for (int i = 0; i < n; i++)
The assignment i = 0occurs 1 time
The comparison i < noccurs n + 1 times
The increment i++occurs n times
Total: 1 + ( n + 1) + n primitive operations
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
By inspecting the pseudocode, we can determine the maximum number of
primitive operations executed by an algorithm as a function of the input size.
linearSearch(A, val):
Input: array A of size n, value val
Output: index of val in A if it exists
-1 otherwise
for i from 0 up to n − 1: 1 + (n + 1) + n
if A[i] = val: 2n
return i
return -1 1
---------------
4n + 3 (total)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Linear search requires 4n + 3 primitive operations in the worst case.
If the time taken by a primitive operation is c, then the time taken by linear
search in the worst case is c(4n + 3).
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
We are mainly interested in
how the running time of an algorithm changes
as the input size increases.
This is called the asymptotic behaviour of the running time.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Lower-Order Terms
Asymptotic behaviour is not affected by lower-order terms.
• For example, suppose the running time of an algorithm is 4n + 100.
• As n increases, the lower-order term (i.e., 100) becomes less significant
(i.e., becomes a smaller proportion of the running time)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Constant Factors
Asymptotic behaviour is not affected by constant factors.
Example: Suppose the running time T (n) of an algorithm is n2.
• What happens when we double the input size?
T (2n) = (2 n)2
= 4 n2
= 4 T (n)
When we double the input size, the time taken quadruples.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Constant Factors
Example: Now suppose the running time T (n) of an algorithm is 10n2.
• Now what happens when we double the input size?
T (2n) = 10 × (2n)2
= 10 × 4n2
= 4 × 10n2
= 4 T (n)
When we double the input size, the time taken also quadruples!
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
To summarise:
• Asymptotic behaviour is unaffected by lower-order terms
• Asymptotic behaviour is unaffected by constant factors
This means we can ignore lower-order terms and constant factors when
characterising the asymptotic behaviour of an algorithm.
Examples:
• If T (n) = 100 n + 500, ignoring lower-order terms and constant factors
gives n
• If T (n) = 5 n2 + 2n + 3, ignoring lower-order terms and constant factors
gives n2
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
This also means that for sufficiently large inputs, the algorithm that has the
running time with the highest-order term will always take longer.

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Big-Oh notation
is used to classify the asymptotic behaviour of an algorithm,
and this is how we usually express time complexity in this course.
For example, linear search is O(n) in the worst case.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Big-Oh notation allows us to easily compare the efficiency of algorithms
• For example, if algorithm A has a time complexity of O(n) and algorithm
B has a time complexity of O(n2), then we can say that for sufficiently
large inputs, algorithm A will perform better.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Formally, big-Oh is actually a notation used to describe the asymptotic
relationship between functions.
Formally:
Given functions f (n) and g(n), we say that f (n) is O(g(n)) if:
• There are positive constants c and n0 such that:
• f (n) ≤ c · g(n) for all n ≥ n0
Informally:
Given functions f (n) and g(n), we say that f (n) is O(g(n)) if for sufficiently
large n, f (n) is bounded above by some multiple of g(n).
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Relatives of Big-Oh
All The Mathematics!
f (n) is O(g(n))
if f (n) is asymptotically less than or equal to g(n)
f (n) is Ω(g(n))
if f (n) is asymptotically greater than or equal to g(n)
f (n) is Θ(g(n))
if f (n) is asymptotically equal to g(n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Analysing Complexity
Since time complexity is not affected by constant factors, instead of counting
primitive operations, we can simply count line executions.
linearSearch(A, value):
Input: array A of size n, value
Output: index of value in A if it exists
-1 otherwise
for i from 0 up to n − 1: n
if A[i] = value: n
return i
return -1 1
---------------
2n + 1 (total)
Worst-case time complexity: O(n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Analysing Complexity
To determine the worst-case time complexity of an algorithm:
• Determine the number of line executions performed in the worst case in
terms of the input size
• Discard lower-order terms and constant factors
• The worst-case time complexity is then the big-Oh of the term that
remains
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Common Functions
Commonly encountered functions in algorithm analysis:
• Constant: 1
• Logarithmic: log n
• Linear: n
• N-Log-N: n log n
• Quadratic: n2
• Cubic: n3
• Exponential: 2n
• Factorial: n!
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Common Functions

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Back to Linear Search
Linear search requires 4n + 3 primitive operations in the worst case.
Therefore, linear search is O(n) in the worst case.
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Searching in a Sorted Array
Is there a faster algorithm for searching an array?
Yes... if the array is sorted.
[0]
1
[1]
2
[2]
4
[3]
9
[4]
11
[5]
15
[6]
16
Let’s start in the middle.
• If a[N /2] = val, we found val; we’re done!
• Otherwise, we split the array:
… if val < a[N /2], we search the left half ( a[0] to a[(N /2) − 1)])
… if val > a[N /2], we search the right half ( a[(N /2) + 1)] to a[N − 1])
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Binary search is a more efficient search algorithm for sorted arrays:
int binarySearch(int arr[], int size, int val) {
int lo = 0;
int hi = size - 1;
while (lo <= hi) {
int mid = (lo + hi) / 2;
if (val < arr[mid]) {
hi = mid - 1;
} else if (val > arr[mid]) {
lo = mid + 1;
} else {
return mid;
}
}
return -1;
}
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Example
Successful search for 6:
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
6 > 5
6 < 8
lo mid hi
lo mid hi
lo
mid
hi
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Example
Unsuccessful search for 7:
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
7 > 5
7 < 8
7 > 6
lo mid hi
lo mid hi
lo
mid
hi
lohi
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Analysis
How many iterations of the loop?
• Best case: 1 iteration
• Item is found right away
• Worst case: log2 n iterations
• Item does not exist
• Every iteration, the size of the subarray being searched is halved
Thus, binary search is O(log2 n) or simply O(log n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
O(log n)
O(log2 n) = O(log n)
Why drop the base?
According to the change of base formula:
loga n = logb n
logb a
If a and b are constants,
loga n and logb n differ by a constant factor
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
O(log n)
For example:
log2 n = log5 n
log5 2
≈ 2.32193 log5 n

COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
What if an algorithm takes multiple arrays as input?
If there is no constraint on the relative sizes of the arrays,
their sizes would be given as two variables, usually n and m
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example time complexities with two variables:
O(n + m)
O(nm)
O(max(n, m))
O(min(n, m))
O(n log m)
O(n log m + m log n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example
Problem:
Given two arrays, where each array contains no repeats,
find the number of elements in common
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example
numCommonElements(A, B):
Input: array A of size n
array B of size m
Output: number of elements in common
numCommon = 0
for i from 0 up to n − 1:
for j from 0 up to m − 1:
if A[i] = B[j]:
numCommon = numCommon + 1
return numCommon
Time complexity: O(nm)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Appendix
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Predicting Time
If I know my algorithm is quadratic (i.e., O(n2)),
and I know that for a dataset of 1000 items,
it takes 1.2 seconds to run …
• how long for 2000?
4.8 seconds
• how long for 10,000?
120 seconds (2 mins)
• how long for 100,000?
12000 seconds (3.3 hours)
• how long for 1,000,000?
1200000 seconds (13.9 days)
(answers on the next slide)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Predicting Time
If I know my algorithm is quadratic (i.e., O(n2)),
and I know that for a dataset of 1000 items,
it takes 1.2 seconds to run …
• how long for 2000? 4.8 seconds
• how long for 10,000? 120 seconds (2 mins)
• how long for 100,000? 12000 seconds (3.3 hours)
• how long for 1,000,000? 1200000 seconds (13.9 days)
(answers on the next slide)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 1
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
for (int k = 1; k <= n; k++) {
// constant-time statement
}
}
}
Time complexity?
O(n3)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 1
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
for (int k = 1; k <= n; k++) {
// constant-time statement
}
}
}
Time complexity? O(n3)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 2
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= i; j++) {
// constant-time statement
}
}
Time complexity?
O(n2)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 2
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= i; j++) {
// constant-time statement
}
}
Time complexity? O(n2)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 3
for (int i = 1; i <= n; i = i * 2) {
// constant-time statement
}
Time complexity?
O(log n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 3
for (int i = 1; i <= n; i = i * 2) {
// constant-time statement
}
Time complexity? O(log n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 4
int p = 0;
for (int i = 1; p <= n; i++) {
p = p + i;
}
Time complexity?
O(√n)
COMP2521
25T3
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 4
int p = 0;
for (int i = 1; p <= n; i++) {
p = p + i;
}
Time complexity? O(√n)


================================================================================

[4/15] week02lec01-divide-and-conquer-sorts.pdf
-----------------------------------------------

COMP2521
25T3
Merge Sort
Quick Sort
Comparison
Summary COMP2521 25T3
Sorting Algorithms (III)
Divide-and-Conquer Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
merge sort
quick sort
COMP2521
25T3
Merge Sort
Quick Sort
Comparison
Summary
Divide-and-Conquer Algorithms
divide-and-conquer algorithms
split a problem into two or more subproblems,
solve the subproblems recursively,
and then combine the results.
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Invented by John von Neumann
in 1945

COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
A divide-and-conquer sorting algorithm:
split the array into two roughly equal-sized parts
recursively sort each of the partitions
merge the two now-sorted partitions into a sorted array
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
unsorted unsorted
mergesort mergesort
sorted sorted
merge
sorted
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort

COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Splitting
How do we split the array?
• We don’t physically split the array
• We simply calculate the midpoint of the array
• mid = (lo + hi) / 2
• Then recursively sort each half by passing in appropriate indices
• Sort between indices loand mid
• Sort between indices mid + 1and hi
• This means the time complexity of splitting the array is O(1)
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging
How do we merge two sorted subarrays?
• We merge the subarrays into a temporary array
• Keep track of the smallest element that has not been merged in each
subarray
• Copy the smaller of the two elements into the temporary array
• If the elements are equal, take from the left subarray
• Repeat until all elements have been merged
• Then copy from the temporary array back to the original array
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1
2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1
2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2
2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2
2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2
3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2
3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3
4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3
4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4
5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4
5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5
6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5
6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6
7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6
7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2
5
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2
5
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging
• The time complexity of merging two sorted subarrays is O(n), where n is
the total number of elements in both subarrays
• Therefore:
• Merging two subarrays of size 1 takes 2 “steps”
• Merging two subarrays of size 2 takes 4 “steps”
• Merging two subarrays of size 4 takes 8 “steps”
• …
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
C Implementation: Sort
void mergeSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
int mid = (lo + hi) / 2;
mergeSort(items, lo, mid);
mergeSort(items, mid + 1, hi);
merge(items, lo, mid, hi);
}
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
C Implementation: Merge
void merge(Item items[], int lo, int mid, int hi) {
Item *tmp = malloc((hi - lo + 1) * sizeof(Item));
int i = lo, j = mid + 1, k = 0;
// Scan both segments, copying to `tmp'.
while (i <= mid && j <= hi) {
if (le(items[i], items[j])) {
tmp[k++] = items[i++];
} else {
tmp[k++] = items[j++];
}
}
// Copy items from unfinished segment.
while (i <= mid) tmp[k++] = items[i++];
while (j <= hi) tmp[k++] = items[j++];
// Copy `tmp' back to main array.
for (i = lo, k = 0; i <= hi; i++, k++) {
items[i] = tmp[k];
}
free(tmp);
}
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Split
n − 1 splits
(log2 n levels
of splitting)
Merge
We have to merge
n numbers exactly
log2 n times
O(n)
O(n log n)
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Split
n − 1 splits
(log2 n levels
of splitting)
Merge
We have to merge
n numbers exactly
log2 n times
O(n)
O(n log n)
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Analysis:
• Merge sort splits the array into equal-sized partitions
halving at each level ⇒ log2 n levels
• The same operations happen at every recursive level
• Each ‘level’ requires ≤ n comparisons
Therefore:
• The time complexity of merge sort is O(n log n)
• Best-case, average-case, and worst-case time complexities are all the same
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis - Alternative Method
Note: Not required knowledge in COMP2521!
Let T (n) be the time taken to sort n elements.
Splitting arrays into two halves takes constant time.
Merging two sorted arrays takes n steps.
So we have that:
T (n) = 2T (n/2) +n
Then the Master Theorem (see COMP3121) can be used to
show that the time complexity is O(n log n).
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Properties
Stable
Due to taking from left subarray if items are equal during merge
Non-adaptive
O(n log n) best case, average case, worst case
Not in-place
Merge uses a temporary array of size up to n
Note: Merge sort also uses O(log n) stack space
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort on Lists
It is possible to apply merge sort on linked lists.
5 2 4 7 3 1 2 6
split
5 2 4 7
a
3 1 2 6
b
mergesort(a) mergesort(b)
2 4 5 7
a
1 2 3 6
b
merge(a, b)
1 2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
An approach that works non-recursively!
• On each pass, our array contains sorted runs of length m.
• Initially, n sorted runs of length 1.
• The first pass merges adjacent elements into runs of length 2.
• The second pass merges adjacent elements into runs of length 4.
• Continue until we have a single sorted run of length n.
Can be used for external sorting;
e.g., sorting disk-file contents
COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
Example

COMP2521
25T3
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
C Implementation
void mergeSortBottomUp(Item items[], int lo, int hi) {
for (int m = 1; m <= hi - lo; m *= 2) {
for (int i = lo; i <= hi - m; i += 2 * m) {
int end = min(i + 2 * m - 1, hi);
merge(items, i, i + m - 1, end);
}
}
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Invented by Tony Hoare
in 1959

COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Method:
1 Choose an item to be a pivot
2 Rearrange (partition) the array so that
• All elements to the left of the pivot are less than (or equal to) the pivot
• All elements to the right of the pivot are greater than (or equal to) the pivot
3 Recursively sort each of the partitions
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
x unsorted
partition
≤ x, unsorted x ≥ x, unsorted
quicksort quicksort
≤ x, sorted x ≥ x, sorted
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
How to partition an array?
• Assume the pivot is stored at index lo
• Create index lto start of array (lo + 1)
• Create index rto end of array (hi)
• Until land rmeet:
• Increment luntil a[l]is greater than pivot
• Decrement runtil a[r]is less than pivot
• Swap items at indices land r
• Swap the pivot with index lor l - 1(depending on the item at index l)
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1 2
7
2 3
61
4
1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1 2
7
2 3
61
4
1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)
Done
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Analysis
• Partitioning is O(n), where n is the number of elements being
partitioned
• About n comparisons are performed, at most n
2 swaps are performed
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
C Implementation: Sort
void naiveQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
int pivotIndex = partition(items, lo, hi);
naiveQuickSort(items, lo, pivotIndex - 1);
naiveQuickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
C Implementation: Partition
int partition(Item items[], int lo, int hi) {
Item pivot = items[lo];
int l = lo + 1;
int r = hi;
while (l < r) {
while (l < r && le(items[l], pivot)) l++;
while (l < r && ge(items[r], pivot)) r--;
if (l == r) break;
swap(items, l, r);
}
if (lt(pivot, items[l])) l--;
swap(items, lo, l);
return l;
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Best case: O(n log n)
• Choice of pivot gives two equal-sized partitions
• Same happens at every recursive call
• Resulting in log2 n recursive levels
• Each “level” requires approximately n comparisons
≤ x ≤x≥ ≥ x
recursively sort recursively sort
≤ y ≤y≥ ≥ y ≤ z ≤z≥ ≥ z
… … … …
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Worst case: O(n2)
• Always choose lowest/highest value for pivot
• Resulting in partitions of size 0 and n − 1
• Resulting in n recursive levels
• Each “level” requires one less comparison than the level above
x ≥ x
y ≥ y
z ≥ z
…
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Average case: O(n log n)
• If array is randomly ordered, chance of repeatedly choosing a bad pivot
is very low
• Can also show empirically by generating random sequences and sorting
them
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Properties
Unstable
Due to long-range swaps
Non-adaptive
O(n log n) average case, sorted input does not improve this
In-place
Partitioning is done in-place
Stack depth is O(n) worst-case, O(log n) average
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Issues with Quick Sort
Choice of pivot can have a significant effect:
• Ideal pivot is the median value
• Always choosing largest/smallest ⇒ worst case
Therefore, always picking the first or last element as pivot is not a good idea:
• Existing order is a worst case
• Existing reverse order is a worst case
• Will result in partitions of size n − 1 and 0
• This pivot selection strategy is called naïve quick sort
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Take three values: left-most, middle, right-most.
Pick the median of these three values as our pivot.
Ordered data is no longer a worst-case scenario.
In general, doesn’t eliminate the worst-case …
… but makes it much less likely.
lo (lo + hi)/2 hi
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
lo (lo + hi)/2 hi
1 Sort a[lo], a[(lo + hi)/2], a[hi], such that a[(lo + hi)/2] ≤ a[lo] ≤ a[hi]
2 Partition on a[lo] to a[hi]
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?
Answer: 5
2
5
lo
3 7 8
2
(lo + hi)/2
1 4 6 5
8
hi
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?
Answer: 5
2
5
lo
3 7 8
2
(lo + hi)/2
1 4 6 5
8
hi
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?Answer: 5
2
5
lo
3 7
8
2
(lo + hi)/2
1 4 6
5
8
hi
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
C Implementation
void medianOfThreeQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
medianOfThreeQuickSort(items, lo, pivotIndex - 1);
medianOfThreeQuickSort(items, pivotIndex + 1, hi);
}
void medianOfThree(Item a[], int lo, int hi) {
int mid = (lo + hi) / 2;
if (gt(a[mid], a[lo])) swap(a, mid, lo);
if (gt(a[lo], a[hi])) swap(a, lo, hi);
if (gt(a[mid], a[lo])) swap(a, mid, lo);
// now, we have a[mid] <= a[lo] <= a[hi]
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Randomised Partitioning
Idea: Pick a random value for the pivot
This makes it nearly impossible to
systematically generate inputs that would lead to
O(n2) performance
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Randomised Partitioning
C Implementation
void randomisedQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
swap(items, lo, randint(lo, hi));
int pivotIndex = partition(items, lo, hi);
randomisedQuickSort(items, lo, pivotIndex - 1);
randomisedQuickSort(items, pivotIndex + 1, hi);
}
int randint(int lo, int hi) {
int i = rand() % (hi - lo + 1);
return lo + i;
}
Note: rand()is a pseudo-random number generator provided by <stdlib.h>.
The generator should be initialised with srand().
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
For small sequences (when n < 5, say),
quick sort is expensive
because of the recursion overhead.
Solution: Handle small partitions with insertion sort
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
C Implementation - Version 1
#define THRESHOLD 5
void quickSort(Item items[], int lo, int hi) {
if (hi - lo < THRESHOLD) {
insertionSort(items, lo, hi);
return;
}
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
quickSort(items, lo, pivotIndex - 1);
quickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
C Implementation - Version 2
#define THRESHOLD 5
void quickSort(Item items[], int lo, int hi) {
doQuickSort(items, lo, hi);
insertionSort(items, lo, hi);
}
void doQuickSort(Item items[], int lo, int hi) {
if (hi - lo < THRESHOLD) return;
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
doQuickSort(items, lo, pivotIndex - 1);
doQuickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort on Lists
It is possible to quick sort a linked list:
1 Pick first element as pivot
• Alternatively, can use median-of-three or random pivot
2 Create two empty linked lists A and B
3 For each element in original list (excluding pivot):
• If element is less than (or equal to) pivot, add it to A
• If element is greater than pivot, add it to B
4 Recursively sort A and B
5 Form sorted linked list using sorted A, the pivot, and then sorted B
COMP2521
25T3
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort on Lists
5 2 4 7 3 1 2 6
partition
5
pivot
2 4 3 1 2
a
7 6
b
quicksort(a) quicksort(b)
5
pivot
1 2 2 3 4
a
6 7
b
combine
1 2 2 3 4 5 6 7
COMP2521
25T3
Merge Sort
Quick Sort
Comparison
Summary
Quick Sort vs Merge Sort
Design of modern cpus mean,
for sorting arrays in ram
quick sort generally outperforms merge sort.
Quick sort is more ‘cache friendly’:
good locality of access on arrays.
On the other hand, merge sort is
readily stable, readily parallel,
a good choice for sorting linked lists
COMP2521
25T3
Merge Sort
Quick Sort
Comparison
Summary
Summary of Divide-and-Conquer Sorts
Time complexity Properties
Best Average Worst Stable Adaptive
Merge sort O(n log n) O(n log n) O(n log n) Yes No
Quick sort O(n log n) O(n log n) O(n2) No No


================================================================================

[5/15] week02lec01-elementary-sorts.pdf
---------------------------------------

COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
COMP2521 25T3
Sorting Algorithms (II)
Elementary Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
selection sort
bubble sort
insertion sort
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Method:
• Find the smallest element, swap it with the first element
• Find the second-smallest element, swap it with the second element
• …
• Find the second-largest element, swap it with the second-last element
Each iteration improves the “sortedness” of the array by one element.
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
Example
4 1 7 3 8 6 5 2
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
C Implementation
void selectionSort(Item items[], int lo, int hi) {
for (int i = lo; i < hi; i++) {
int min = i;
for (int j = i + 1; j <= hi; j++) {
if (lt(items[j], items[min])) {
min = j;
}
}
swap(items, i, min);
}
}
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Analysis
Cost analysis:
• In the first iteration, n − 1 comparisons, 1 swap
• In the second iteration, n − 2 comparisons, 1 swap
• …
• In the final iteration, 1 comparison, 1 swap
• C = (n − 1) + (n − 2) +. . .+ 1 =1
2 n(n − 1) ⇒ O(n2)
• S = n − 1
Cost is the same, regardless of the sortedness of the original array.
COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Properties
Selection sort is unstable
• Due to long-range swaps
• For example, sort these cards by value:

COMP2521
25T3
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Properties
Unstable
Due to long-range swaps
Non-adaptive
Performs same steps, regardless of sortedness of original array
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Method:
• Make multiple passes from left ( lo) to right
• On each pass, swap any out-of-order adjacent pairs
• Elements “bubble up” until they meet a larger element
• Stop if there are no swaps during a pass
• This means the array is sorted
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Example
4 3 6 1 2 5
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
C Implementation
void bubbleSort(Item items[], int lo, int hi) {
for (int i = hi; i > lo; i--) {
bool swapped = false;
for (int j = lo; j < i; j++) {
if (gt(items[j], items[j + 1])) {
swap(items, j, j + 1);
swapped = true;
}
}
if (!swapped) break;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Best case: Array is sorted
• Only a single pass required
• n − 1 comparisons, no swaps
• Best-case time complexity: O(n)
1 2 3 4 5 6
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Worst case: Array is reverse-sorted
• n − 1 passes required
• First pass: n − 1 comparisons
• Second pass: n − 2 comparisons
• …
• Final pass: 1 comparison
• Total comparisons: (n − 1) + (n − 2) +. . .+ 1 =1
2 n(n − 1)
• Every comparison leads to a swap ⇒ 1
2 n(n − 1) swaps
• Worst-case time complexity: O(n2)
6 5 4 3 2 1
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Average-case time complexity: O(n2)
• It can be proven that for a randomly ordered array, bubble sort needs to
perform 1
4 n(n − 1) swaps on average ⇒ O(n2)
• See appendix for details
• Can show empirically by generating random sequences and sorting them
COMP2521
25T3
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Properties
Stable
Comparisons are between adjacent elements only
Elements are only swapped if out of order
Adaptive
Bubble sort is O(n2) on average, O(n) if input array is sorted
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Method:
• Take first element and treat as sorted array (of length 1)
• Take next element and insert into sorted part of array so that order is
preserved
• This increases the length of the sorted part by one
• Repeat for remaining elements
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
Example
4 1 7 3 8 6 5 2
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
C Implementation
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Best case: Array is sorted
• Inserting each element requires one comparison
• n − 1 comparisons
• Best-case time complexity: O(n)
1 2 3 4 5 6 7 8
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Worst case: Array is reverse-sorted
• Inserting i-th element requires i comparisons
• Inserting index 1 element requires 1 comparison
• Inserting index 2 element requires 2 comparisons
• …
• Total comparisons: 1 + 2 +. . .+ (n − 1) =1
2 n(n − 1)
• Worst-case time complexity: O(n2)
8 7 6 5 4 3 2 1
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Average-case time complexity: O(n2)
• Same reason as for bubble sort
• Can show empirically by generating random sequences and sorting them
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Properties
Stable
Elements are always inserted to the right of any equal elements
Adaptive
Insertion sort is O(n2) on average, O(n) if input array is sorted
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Summary of Elementary Sorts
Time complexity Properties
Best Average Worst Stable Adaptive
Selection sort O(n2) O(n2) O(n2) No No
Bubble sort O(n) O(n2) O(n2) Yes Yes
Insertion sort O(n) O(n2) O(n2) Yes Yes
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Aside: Sorting Linked Lists
Selection sort:
• Let L = original list, S = sorted list (initially empty)
• Repeat the following until L is empty:
• Find the node V containing the largest value in L, and unlink it
• Insert V at the front of S
Bubble sort:
• Traverse the list, comparing adjacent values
• If value in current node is greater than value in next node, swap values
• Repeat the above until no swaps required in one traversal
Insertion sort:
• Let L = original list, S = sorted list (initially empty)
• For each node in L:
• Insert the node into S in order
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Appendix
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Note: Not required knowledge in COMP2521!
New concept: inversion
An inversion is a pair of elements from a sequence where
the left element is greater than the right element.
For example, consider the following array:
4 2 1 5 3
The array contains 5 inversions:
(4, 2), (4, 1), (4, 3), (2, 1), (5, 3)
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Observation:
• In bubble sort, every swap reduces the number of inversions by 1
The goal of the proof: Show that the average number of inversions in a
randomly sorted array is O(n2).
• This implies the number of swaps required by bubble sort is O(n2) …
• Which implies that the average-case time complexity of bubble sort is
O(n2) or slower
• (but we know that it can’t be slower than O(n2) since the worst-case time
complexity of bubble sort is O(n2))
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
In a randomly sorted array:
• The minimum possible number of inversions is 0
(sorted array)
• The maximum possible number of inversions is 1
2 n(n − 1)
(reverse-sorted array)
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Let k be the number of inversions in a random permutation.
By reversing this permutation, one can obtain a permutation with
1
2 n(n − 1) − k inversions.
For example, suppose n = 5:
3 2 4 1 5
4 inversions
reverse 5 1 4 2 3
6 inversions
1 2 3 4 5
0 inversions
reverse 5 4 3 2 1
10 inversions
1 3 4 5 2
3 inversions
reverse
2 5 4 3 1
7 inversions
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Thus, if we take all the possible permutations of an array and pair each
permutation with its reverse, the total number of inversions in each pair is
1
2 n(n − 1).
This implies that the average number of inversions across all permutations is
1
4 n(n − 1), which is O(n2).
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
Sort the following array:
4 2 1 5 3
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5
item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T3
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5
item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}


================================================================================

[6/15] week02lec01-sorting-intro.pdf
------------------------------------

COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
COMP2521 25T3
Sorting Algorithms (I)
Introduction to Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
sorting
properties of sorting algorithms
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Motivation
• Sorting enables faster searching
• Binary search
• Sorting provides a useful intermediate for other algorithms
• For example, duplicate detection/removal, merging two collections
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Sorting
• Sorting involves arranging a collection of items in order
• Arrays, linked lists, files
• Items are sorted based on some property (called the key), using an
ordering relation on that property
• Numbers are sorted numerically
• Strings are sorted alphabetically
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Sorting
We sort arrays of Items, which could be:
• Simple values: int, char, double
• Aggregate values: strings
• Structured values: struct
The items are sorted based on a key, which could be:
• The entire item, if the item is a single value
• One or more fields, if the item is a struct
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Sorting
Example: Each student has an ID and a name
5151515
John
5012345
Jane
3456789
Bob
5050505
Alice
5555555
John
5432109
Andrew
Sorting by ID (i.e., key is ID):
3456789
Bob
5012345
Jane
5050505
Alice
5151515
John
5432109
Andrew
5555555
John
Sorting by name (i.e., key is name):
5050505
Alice
5432109
Andrew
3456789
Bob
5012345
Jane
5151515
John
5555555
John
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Sorting
Arrange items in array slice a[lo..hi]into sorted order:
a
lo hi
unordered
sort(a, lo, hi)
a
lo hi
ordered
To sort an entire array of size N, lo == 0and hi == N - 1.
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Examples of Sorting Algorithms
Elementary sorting algorithms:
• Selection sort
• Bubble sort
• Insertion sort
• Shell sort
Divide-and-conquer sorting algorithms:
• Merge sort
• Quick sort
Non-comparison-based sorting algorithms:
• Radix sort
• Key-indexed counting sort
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Analysis of Sorting Algorithms
Three main cases to consider for input order:
• Random order
• Sorted order
• Reverse-sorted order
When analysing sorting algorithms, we consider:
• n: the number of items ( hi− lo+ 1)
• C : the number of comparisons between items
• S: the number of times items are swapped
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Properties:
• Stability
• Adaptability
• In-place
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
• A stable sort preserves the relative order of items with equal keys.
• Formally: For all pairs of items x and y where key(x) ≡ key(y), if x
precedes y in the original array, then x precedes y in the sorted array.
A stable sorting algorithm always performs a stable sort.
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
Example: Each card has a value and a suit
A stable sort on value: p

COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
Example: Each card has a value and a suit
Example of an unstable sort on value:

COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
When is stability important?
• When sorting the same array multiple times on different keys
• Some sorting algorithms rely on this, for example, radix sort
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
Example: Array of first names and last names
Alice
Wunder
Andrew
Bennett
Jake
Renzella
Alice
Hatter
Andrew
Taylor
John
Shepherd
Sort by last name:
Andrew
Bennett
Alice
Hatter
Jake
Renzella
John
Shepherd
Andrew
Taylor
Alice
Wunder
Then sort by first name (using stable sort):
Alice
Hatter
Alice
Wunder
Andrew
Bennett
Andrew
Taylor
Jake
Renzella
John
Shepherd
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Stability
Stability doesn’t matter if...
• All items have unique keys
• Example: Sorting students by ID
• The key is the entire item
• Example: Sorting an array of integer values
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Adaptability
• An adaptive sorting algorithm takes advantage of existing order in its
input
• The nature of the algorithm allows sorted or nearly-sorted inputs to be
sorted much quicker than other inputs
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Adaptability
Warning!
Just because a sorting algorithm
sorts sorted input faster than it sorts random/reverse-sorted input,
does not mean that it is adaptive.
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Adaptability
Example of data for non-adaptive sorting algorithm:

COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
Adaptability
Example of data for adaptive sorting algorithm:

COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Stability
Adaptability
In-place
Programming
Properties of Sorting Algorithms
In-place
• An in-place sorting algorithm sorts the data within the original structure,
without using temporary arrays
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Implementing Sorting Algorithms
Generic sort function:
void sort(Item a[], int lo, int hi);
Helper function to swap elements at indices iand j:
void swap(Item a[], int i, int j);
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Implementing Sorting Algorithms
Itemis a typedef,
which is a way to give a new name to a type.
For example, if we want to sort integers:
typedef int Item;
For example, if we want to sort strings:
typedef char *Item;
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Implementing Sorting Algorithms
We also define macros which indicate
(1) how to extract keys from an item, and
(2) how items should be compared.
For example, when sorting integers:
typedef int Item;
#define key(A) (A)
#define lt(A, B) (key(A) < key(B)) // less than
#define le(A, B) (key(A) <= key(B)) // less than or equal to
#define ge(A, B) (key(A) >= key(B)) // greater than or equal to
#define gt(A, B) (key(A) > key(B)) // greater than
COMP2521
25T3
Motivation
Sorting
Analysis
Properties
Programming
Implementing Sorting Algorithms
When sorting structs:
typedef struct {
char *name;
char *course;
} Item;
#define key(A) (A.name)
#define lt(A, B) (strcmp(key(A), key(B)) < 0)
#define le(A, B) (strcmp(key(A), key(B)) <= 0)
#define ge(A, B) (strcmp(key(A), key(B)) >= 0)
#define gt(A, B) (strcmp(key(A), key(B)) > 0)


================================================================================

[7/15] week02lec02-non-comparison-sorts.pdf
-------------------------------------------

COMP2521
25T3
n log n Lower
Bound
Radix Sort
COMP2521 25T3
Sorting Algorithms (IV)
Non-Comparison-Based Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
n log n lower bound
radix sort
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
All of the sorting algorithms so far have been
comparison-based sorts.
It can be shown that these algorithms require Ω(n log n) comparisons.
That is, they require at least kn log n comparisons for some constant k.
Why?
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we need to sort 3 items.
Obviously, one comparison is not sufficient to sort them.
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we need to sort 3 items.
Even two comparisons are not sufficient to sort them. Why?
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
If we have 3 items, there are 3! = 6 ways to order them:
Assuming items are unique, one of these permutations is in sorted order.
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we performed the following comparisons:
<
<
Four combinations of results are possible:
(true, true), (true, false), (false, true), (false, false)
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
The two comparisons create four groups, and
each permutation of items belongs to one of these groups
true
true
true
false
false
true
false
false
<
<
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Mathematically,
If we have 3 items, then there are 3! = 6 ways to order them.
In other words, 6 possible permutations.
But if we only perform 2 comparisons, then there are only 22 = 4 groups,
so at least one group will contain more than one permutation.
We need at least 3 comparisons, because this creates 23 = 8 groups,
so each permutation can belong in its own group.
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
If we have n items, then there are n! permutations.
If we perform k comparisons, that creates up to 2k groups.
So given n items, we must perform enough comparisons k such that
2k ≥ n!
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
So given n items, we must perform enough comparisons k such that
2k ≥ n!
Taking the log2 of both sides gives
log2 2k ≥ log2 n!
Since log2 2k = k, we get
k ≥ log2 n!
Using Stirling’s approximation, we get
k ≥ n log2 n − n log2 e + O(log2 n)
Removing lower-order terms gives
k = Ω( n log2 n)
COMP2521
25T3
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Therefore:
The theoretical lower bound on
worst-case execution time
for comparison-based sorts is Ω(n log n).
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Non-Comparison-Based Sorting
If we aren’t limited to just comparing keys,
we can achieve better than O(n log n) worst-case time.
Non-comparison-based sorting algorithms exploit specific properties
of the data to sort it.
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Radix sort is a non-comparison-based sorting algorithm.
It requires us to be able to decompose our keys into individual symbols
(digits, characters, bits, etc.), for example:
• The key 372 is decomposed into (3, 7, 2)
• The key “sydney” is decomposed into (‘s’ , ‘y’ , ‘d’ , ‘n’ , ‘e’ , ‘y’)
Formally, each key k is decomposed into a tuple ( k1, k2, k3, …, km ).
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Ideally, the range of possible symbols is reasonably small, for example:
• Numeric: 0-9
• Alphabetic: a-z
The number of possible symbols is known as the radix, and is denoted by R.
• Numeric: R = 10 (for base 10)
• Alphabetic: R = 26
If the keys have different lengths, pad them with a suitable symbol, for
example:
• Numeric: 123, 015, 007
• Alphabetic: “ abc” , “zz␣” , “t␣␣”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Method:
• Perform stable sort on km
• Perform stable sort on km−1
• …
• Perform stable sort on k1
Example:

COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Pseudocode
radixSort(A):
Input: array A of keys where
each key consists of m symbols from an "alphabet"
initialise R buckets // one for each symbol
for i from m down to 1:
empty all buckets
for each key in A:
append key to bucket key[i]
clear A
for each bucket (in order):
for each key in bucket:
append key to A
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Assume alphabet is {‘ a’ , ‘b’ , ‘c’}, so R = 3 .
We want to sort the array:
[“abc” , “cab” , “baa” , “a” , “ca”]
First, pad keys with blank characters:
[“abc” , “cab” , “baa” , “a␣␣” , “ca␣”]
Each key contains three characters, so m = 3 .
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣ a b c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣ a b c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣ a b c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc”
“baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc”
“baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa”
“ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa”
“ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣”
“cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a b c
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Analysis
Analysis:
• Array contains n keys
• Each key contains m symbols
• Radix sort uses R buckets
• A single stable sort runs in time O(n + R)
• Radix sort uses stable sort m times
Hence, time complexity for radix sort is O(m(n + R)).
• ≈ O(mn), assuming R is small
Therefore, radix sort performs better than comparison-based sorting
algorithms:
• When keys are short (i.e., m is small) and arrays are large (i.e., n is large)
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Properties
Stable
All sub-sorts performed are stable
Non-adaptive
Same steps performed, regardless of sortedness
Not in-place
Uses O(R + n) additional space for buckets
and storing keys in buckets
COMP2521
25T3
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Other Non-Comparison-Based Sorts
• Bucket sort
• MSD Radix Sort
• The version shown was LSD
• Key-indexed counting sort
• …and others


================================================================================

[8/15] week03lec01-adts.pdf
---------------------------

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
COMP2521 25T3
Abstract Data Types
Sim Mautner
cs2521@cse.unsw.edu.au
abstraction
abstract data types
stacks and queues
sets
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Abstraction
is the process of
hiding or generalising
the details of an object or system
to focus on its high-level meaning or behaviour
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We drive a car by using a steering wheel and pedals

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We drive a car by using a steering wheel and pedals

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We operate a television through a remote control

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We operate a television through a remote control

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We deposit and withdraw money to/from our bank account via an ATM

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We deposit and withdraw money to/from our bank account via an ATM

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
How many of these are examples of abstraction?
Using a computer
Executing a sorting program
Calling a function in C
Using an intin C
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
How many of these are examples of abstraction?
Using a computer
Executing a sorting program
Calling a function in C
Using an intin C
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Functions abstract away the steps of a computation
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
int res = factorial(5);
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Modern programming languages abstract away assembly code
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-0x14], edi
mov DWORD PTR [rbp-0x04], 0x1
mov DWORD PTR [rbp-0x08], 0x1
jmp 25 <fn+0x25>
mov eax, DWORD PTR [rbp-0x04]
imul eax, DWORD PTR [rbp-0x08]
mov DWORD PTR [rbp-0x04], eax
add DWORD PTR [rbp-0x08], 0x1
mov eax, DWORD PTR [rbp-0x08]
cmp eax, DWORD PTR [rbp-0x14]
jle 17 <fn+0x17>
mov eax, DWORD PTR [rbp-0x04]
pop rbp
ret
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Assembly languages abstract away machine code
0000000000000000 <fn>:
0: 55 push rbp
1: 48 89 e5 mov rbp, rsp
4: 89 7d ec mov DWORD PTR [rbp-0x14], edi
7: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x04], 0x1
e: c7 45 f8 01 00 00 00 mov DWORD PTR [rbp-0x08], 0x1
15: eb 0e jmp 25 <fn+0x25>
17: 8b 45 fc mov eax, DWORD PTR [rbp-0x04]
1a: 0f af 45 f8 imul eax, DWORD PTR [rbp-0x08]
1e: 89 45 fc mov DWORD PTR [rbp-0x04], eax
21: 83 45 f8 01 add DWORD PTR [rbp-0x08], 0x1
25: 8b 45 f8 mov eax, DWORD PTR [rbp-0x08]
28: 3b 45 ec cmp eax, DWORD PTR [rbp-0x14]
2b: 7e ea jle 17 <fn+0x17>
2d: 8b 45 fc mov eax, DWORD PTR [rbp-0x04]
30: 5d pop rbp
31: c3 ret
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
An abstract data type…
is a conceptual model
that defines a set of operations for a data structure
without specifying how these operations are implemented
or how data is stored in memory.
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
An analogy...
Ordering from a restaurant...
The menu...
The kitchen...

COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
Example of an ADT: Stack
A stack is a linear collection of items
with two main operations:
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Interface
The set of operations provided by an ADT is called the interface.
Users of an ADT only see and interact with the interface.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Interface
An ADT interface must:
1. clearly describe the behaviour of each operation
2. describe the conditions under which each operation can be used
Example:
pop
removes the item at
the top of the stack
assumes that the stack is not empty
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Implementation
Builders of an ADT provide an implementation of its operations.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
Implementation
create(...) {
...
}
destroy(...) {
...
}
push(...) {
...
}
pop(...) {
...
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Implementation
Users of an ADT do not see the implementation.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
Implementation
create(...) {
...
}
destroy(...) {
...
}
push(...) {
...
}
pop(...) {
...
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
In C, abstract data types are implemented using two files:
a .h file that contains the interface
a .c file that contains the implementation
Stack.h
Interface
Stack.c
Implementation
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Interface — .hfile
The interface includes:
• forward declaration of the struct for the concrete representation
• via typedef struct t *T
• the struct is not defined in the interface
• function prototypes for all operations
• clear description of operations
• via comments
• a contract between the ADT and clients
• documentation describes how an operation can be used
• and what the expected result is as long as the operation is used correctly
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Interface — .hfile
Stack.h
typedef structstack *Stack;
/** Creates a new empty stack */
Stack StackNew(void);
/** Frees memory allocated to the stack */
void StackFree(Stack s);
/** Adds an item to the top of the stack */
void StackPush(Stack s, int item);
/** Removes the item at the top of the stack
Assumes that the stack is not empty */
int StackPop(Stack s);
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Implementation — .cfile
The implementation includes:
• concrete definition of the data structures
• definition of struct t
• function implementations for all operations
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Implementation — .cfile
Stack.c
struct stack {
...
};
Stack StackNew(void) {
...
}
void StackFree(Stack s) {
...
}
void StackPush(Stack s, int item) {
...
}
int StackPop(Stack s) {
...
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
User
A user of an ADT #includes the interface and uses the interface functions to
interact with the ADT.
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Users of an ADT only see and interact with the interface —
they do not see the implementation!
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
#include "Stack.h"
int main(void) {
Stack s = StackNew();
// this is not valid!
s->...
}
Stack.h
typedef struct stack *Stack;
...
Stack.c
struct stack {
...
};
This means users cannot access the concrete representation (struct) directly.
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Users of an ADT only see and interact with the interface —
they do not see the implementation!
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
#include "Stack.h"
int main(void) {
Stack s = StackNew();
// this is not valid!
s->...
}
Stack.h
typedef struct stack *Stack;
...
Stack.c
struct stack {
...
};
This means users cannot access the concrete representation (struct) directly.
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
COMP2521 Conventions
Naming conventions:
• ADTs are defined in files whose names start with an uppercase letter
• For example, for a Stack ADT:
• The interface is defined in Stack.h
• The implementation is defined in Stack.c
• ADT interface function names are in PascalCaseand begin with the
name of the ADT
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Creating/Using Abstract Data Types
1 Decide what operations you want to provide
• Operations to create, query, manipulate
• What are their inputs and outputs?
• What are the conditions under which they can be used (if any)?
2 Provide the function signatures and documentation for these operations
in a .hfile
3 The “developer” builds a concrete implementation for the ADT in a .cfile
4 The “user” #includes the interface in their program and uses the
provided functions
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
What operations can you perform on a simple bank account?
• Open an account
• Check balance
• Deposit money
• Withdraw money
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
Interface (Account.h)
typedef struct account *Account;
/** Opens a new account with zero balance */
Account AccountOpen(void);
/** Closes an account */
void AccountClose(Account acc);
/** Returns account balance */
int AccountBalance(Account acc);
/** Withdraws money from account
Returns true if enough balance, false otherwise
Assumes amount is positive */
bool AccountWithdraw(Account acc, int amount);
/** Deposits money into account
Assumes amount is positive */
void AccountDeposit(Account acc, int amount);
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
User
int main(void) {
Account acc = AccountOpen();
printf("Balance: %d\n", AccountBalance(acc));
AccountDeposit(acc, 50);
printf("Balance: %d\n", AccountBalance(acc));
AccountWithdraw(acc, 20);
printf("Balance: %d\n", AccountBalance(acc));
AccountWithdraw(acc, 40);
printf("Balance: %d\n", AccountBalance(acc));
AccountClose(acc);
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
User
Invalid usage of an ADT (breaking abstraction):
int main(void) {
Account acc = AccountOpen();
acc->balance = 1000000;
// I'm a millionaire now, woohoo!
printf("Balance: %d\n", AccountBalance(acc));
AccountClose(acc);
}
COMP2521
25T3
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Examples of ADTs
• Stack
• Queue
• Set
• Multiset
• Map
• Graph
• Priority Queue
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stacks
A stack is a collection of items,
such that the last item to enter
is the first item to leave:
Last In, First Out (lifo)
(Think stacks of books, plates, etc.)
• web browser history
• text editor undo/redo
• balanced bracket checking
• HTML tag matching
• rpn calculators
(…and programming languages!)
• function calls
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stacks
Operations
A stack supports the following operations:
push
add a new item to the top of the stack
pop
remove the topmost item from the stack
size
return the number of items on the stack
peek
get the topmost item on the stack without removing it
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
A Stack ADT can be used to check for balanced brackets.
Example of balanced brackets:
( [ { } ] )
Examples of unbalanced brackets!
( ) ) ) ( (
( [ { } ) ]
( [ ] ) ( [
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADT Interface
"Stack.h"
typedef struct stack *Stack;
/** Creates a new, empty Stack */
Stack StackNew(void);
/** Frees memory allocated for a Stack */
void StackFree(Stack s);
/** Adds an item to the top of a Stack */
void StackPush(Stack s, Item it);
/** Removes an item from the top of a Stack
Assumes that the Stack is not empty */
Item StackPop(Stack s);
/** Gets the number of items in a Stack */
int StackSize(Stack s);
/** Gets the item at the top of a Stack
Assumes that the Stack is not empty */
Item StackPeek(Stack s);
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
How to implement a stack?
array
linked list
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADTs
Array implementation
Dynamically allocate an array with an initial capacity
Fill the array sequentially — s[0], s[1], …
Maintain a counter of the number of items on the stack
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
4
6
7
3
struct stack
capacity 8
size 4
items
4 6 7 3
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
Example
Perform the following operations:
push(9), push(2), push(6), pop, pop, push(8)
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size 0
123212
items
9 28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
0
1
23212
items
9
28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
01
2
3212
items
9 2
8 6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
012
3
212
items
9 2
8
6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
0123
2
12
items
9 2
8 6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
capacity 8
size
01232
1
2
items
9
28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
capacity 8
size
012321
2
items
9
2
8
6
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation - Analysis
Cost of push:
• Inserting item at index sizeis O(1)
• What if array is full?
• If we double the size of the array with realloc(3) each time it is full, push
will still be O(1) on average
Cost of pop:
• Accessing item at index ( size - 1) is O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
Store items in a linked list
To push an item, insert it at the beginning of the list
To pop an item, remove it from the beginning of the list
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
4
6
7
3
struct stack
size 4
items
3 7 6 4
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
Example
Perform the following operations:
push(9), push(2), push(6), pop, pop, push(8)
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size 0
123212
items NULL
6 82 9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
0
1
23212
items
NULL
6 82
9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
01
2
3212
items
NULL
6 8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
012
3
212
items
NULL
6
8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
0123
2
12
items
NULL
6 8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
size
01232
1
2
items
NULL
6 82
9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
size
012321
2
items
NULL
6
8
2
9
Stack
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation - Analysis
Cost of push:
• Inserting at the beginning of a linked list is O(1)
Cost of pop:
• Removing from the beginning of a linked list is O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues
A queue is a collection of items,
such that the first item to enter
is the first item to leave:
First In, First Out (fifo)
(Think queues of people, etc.)
• waiting lists
• call centres
• access to shared resources
(e.g., printers)
• processes in a computer
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues

COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues
Operations
A queue supports the following operations:
enqueue
add a new item to the end of the queue
dequeue
remove the item at the front of the queue
size
return the number of items in the queue
peek
get the frontmost item of the queue, without removing it
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queue ADT Interface
"Queue.h"
typedef struct queue *Queue;
/** Create a new, empty Queue */
Queue QueueNew(void);
/** Free memory allocated to a Queue */
void QueueFree(Queue q);
/** Add an item to the end of a Queue */
void QueueEnqueue(Queue q, Item it);
/** Remove an item from the front of a Queue
Assumes that the Queue is not empty */
Item QueueDequeue(Queue q);
/** Get the number of items in a Queue */
int QueueSize(Queue q);
/** Get the item at the front of a Queue
Assumes that the Queue is not empty */
Item QueuePeek(Queue q);
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Implementation
How to implement a queue?
array
linked list (easier)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
To enqueue an item, insert it at the end of the list
To an item, remove it from the beginning of the list
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
What’s the problem with this design?
4
6
7
3
front
back
struct queue
size 4
items
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
Improved design
4
6
7
3
front
back
struct queue
size 4
back
front
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
Example
Perform the following operations:
enQ(9), enQ(2), enQ(6), deQ, deQ, enQ(8)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size 0
123212
back NULL
front NULL
9 2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
0
1
23212
back
NULL
front
NULL
9
2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
01
2
3212
back
NULL
front
NULL
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
012
3
212
back
NULL
front
NULL
9 2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
0123
2
12
back
NULL
front
NULL
9
2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
01232
1
2
back
NULL
front
NULL
9 2
6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
012321
2
back
NULL
front
NULL
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation - Analysis
Cost of enqueue:
• Inserting at the end of the linked list is O(1)
Cost of dequeue:
• Removing from the beginning of the linked list is O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
Dynamically allocate an array with an initial capacity
Maintain an index to the front of the queue
Maintain a counter of the number of items in the queue
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
4
6
7
3
front
back
struct queue
front 0
capacity 8
size 4
items
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
Example
Perform the following operations:
enQ(9), enQ(2), enQ(6), deQ, deQ, enQ(8)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size 0
123212
items
9 2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
0
1
23212
items
9
2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
01
2
3212
items
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
012
3
212
items
9 2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
0
1
2
capacity 8
size
0123
2
12
items
9
2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
01
2
capacity 8
size
01232
1
2
items
9 2
6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
01
2
capacity 8
size
012321
2
items
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation - Analysis
Cost of enqueue:
• Enqueue involves calculating insertion index
and inserting item at that index ⇒ O(1)
Cost of dequeue:
• Dequeue involves accessing item at index front⇒ O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Sets
A set is an unordered collection of distinct elements.
4 7
8
15
17
23 26
30
39
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Basic set operations:
• Create an empty set
• Insert an item into the set
• Delete an item from the set
• Check if an item is in the set
• Get the size of the set
• Display the set
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Interface
#include <stdbool.h>
typedef struct set *Set;
/** Creates a new empty set */
Set SetNew(void);
/** Free memory used by set */
void SetFree(Set set);
/** Inserts an item into the set */
void SetInsert(Set set, int item);
/** Deletes an item from the set */
void SetDelete(Set set, int item);
/** Checks if an item is in the set */
bool SetContains(Set set, int item);
/** Returns the size of the set */
int SetSize(Set set);
/** Displays the set */
void SetShow(Set set);
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Example Usage
Counting and displaying distinct numbers:
#include <stdio.h>
#include "Set.h"
int main(void) {
Set s = SetNew();
int val;
while (scanf("%d", &val) == 1) {
SetInsert(s, val);
}
printf("Number of distinct values: %d\n", SetSize(s));
printf("Values: ");
SetShow(s);
SetFree(s);
}
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Different ways to implement a set:
• Unordered array
• Ordered array
• Ordered linked list
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
struct set
capacity 8
size 5
elems
4 7 5 1 9
Set
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we check if an element exists?
• Perform linear scan of array ⇒ O(n)
bool SetContains(Set s, int elem) {
for (int i = 0; i < s->size; i++) {
if (s->elems[i] == elem) {
return true;
}
}
return false;
}
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we insert an element?
• If the element doesn’t exist, insert it after the last element
void SetInsert(Set s, int elem) {
if (SetContains(s, elem)) {
return;
}
if (s->size == s->capacity) {
// error message
}
s->elems[s->size] = elem;
s->size++;
}
Time complexity: O(n)
• SetContains is O(n) and inserting after the last element is O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we delete an element?
• If the element exists, overwrite it with the last element
void SetDelete(Set s, int elem) {
for (int i = 0; i < s->size; i++) {
if (s->elems[i] == elem) {
s->elems[i] = s->elems[s->size - 1];
s->size--;
return;
}
}
}
Time complexity: O(n)
• Finding the element is O(n), overwriting it with the last element is O(1)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
struct set
capacity 8
size 5
elems
1 4 5 7 9
Set
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we check if an element exists?
• Perform binary search ⇒ O(log n)
bool SetContains(Set s, int elem) {
int lo = 0;
int hi = s->size - 1;
while (lo <= hi) {
int mid = (lo + hi) / 2;
if (elem < s->elems[mid]) {
hi = mid - 1;
} else if (elem > s->elems[mid]) {
lo = mid + 1;
} else {
return true;
}
}
return false;
}
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1
42 5
4
7
5
9
7 9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1
4
2
5
4
7
5
9
7 9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
Time complexity of insertion?
• Binary search lets us find the insertion point in O(log n) time
• …but we still have to potentially shift up to n elements, which is O(n)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1 4
5
5
7
7
9
9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1 4
5
5
7
7
9
9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1
4
5
5
7
7
9
9
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
Time complexity of deletion?
• Binary search lets us find the element in O(log n) time
• …but we still have to potentially shift up to n − 1 elements, which is O(n)
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
struct set
size 3
elems
4 5 7
Set
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
How do we check if an element exists?
• Traverse the list ⇒ O(n)
bool SetContains(Set s, int elem) {
for (struct node *curr = s->elems; curr != NULL; curr = curr->next) {
if (curr->elem == elem) {
return true;
}
}
return false;
}
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
We always have to traverse the list from the start. Therefore…
• Insertion and deletion are also O(n)
However, this analysis hides a crucial advantage of linked lists:
• Finding the insertion/deletion point is O(n)
• But inserting/deleting a node is O(1), as no shifting is required
COMP2521
25T3
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set ADT Summary
Data Structure Contains Insert Delete
Unordered array O(n) O(n) O(n)
Ordered array O(log n) O(n) O(n)
Ordered linked list O(n) O(n) O(n)


================================================================================

[9/15] week03lec02-bsts.pdf
---------------------------

COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
COMP2521 25T3
Binary Search Trees
Sim Mautner
cs2521@cse.unsw.edu.au
trees
binary search trees
binary search tree operations
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees

COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
A tree is a hierarchical data structure
consisting of a set of connected nodes where:
Each node may have multiple other nodes as children
(depending on the type of tree)
Each node is connected to one parent except the root node
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - File System Tree
/
etc
hosts network
interfaces
bin home
andrewt
public_html
hsmith
public_html
index.html
webappdev
css html js
examples notes
lesson1.txt lesson2.txt
ts
jas
public_html
index.html
lib var
Source: https:/ /www.openbookproject.net/tutorials/getdown/unix/lesson2.html
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Abstract Syntax Tree
function decl
type: int(int)
name: fn
parameter list
parameter decl
type: int
name: n
statement list
if
==
variable
name: n
constant
value: 0
return
constant
value: 1
return
*
variable
name: n
function call
function
name: fn
argument list
-
variable
name: n
constant
value: 1
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Search Trees
5
2
1 4
7
9
13
3 23 25
2 6 8 9 14 20 24 29 30
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Decision Tree
Are you nervous?
Savings account.
Yes
Will you need to access most of the
money within the next 5 years?
Money market fund.
Yes
Are you willing to accept risks in
exchange for higher expected returns?
Stock portfolio.
Yes
Diversified portfolio with stocks,
bonds and short-term instruments.
No
No
No
Source: “Data Structures and Algorithms in Java” (6th ed) by Goodrich et al.
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Decoding Morse Code
start
E
I
S
H
5 4
V
3
U
F A
2
A
R
L
W
P J
1
T
N
D
B
6
X
K
C Y
M
G
Z
7
Q
O
0
8
0
9 0
Dot Dash
COMP2521
25T3
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Trees
A binary tree is a tree where
each node can have up to two child nodes,
referred to as the left child and the right child.
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
A binary search tree is an ordered binary tree, where for each node :
• All values in the left subtree are less than the value in the node
• All values in the right subtree are greater than the value in the node
20
10
5
2
14
12 17
30
24
29
32
31
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Tree
Why?
We need a more efficient way to search and maintain large amounts of data.
We have already explored some approaches:
Ordered array Ordered linked list
Searching/finding the
insertion/deletion point O(log n) O(n)
Inserting/deleting
after finding the
insertion/deletion point
O(n) O(1)
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Why?
Binary search trees are efficient to search and maintain:
• Searching in a binary search tree is similar to how binary search works
• A binary search tree is a linked data structure (like a linked list), so there
is no need to shift elements when inserting/deleting
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Concrete Representation
Binary trees are typically represented by node structures
• Where each node contains a value and pointers to child nodes
struct node {
int item;
struct node *left;
struct node *right;
};
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Concrete Representation
4
2
1 3
6
5 7
4
2 6
1 3 5 7
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
The root node is the node with no parent node.
A leaf node is a node that has no child nodes.
An internal node is a node that has at least one child node.
4
2
1 3
8
6 9
leaf
root internal
node
internal
node
internal
node
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
Height of a tree: Maximum path length from the root node to a leaf
• The height of an empty tree is considered to be -1
• The height of the following tree is 3
5
2
1 3
4
8
6 9
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a tree with n nodes:
The maximum possible height is n − 1
1
2
3
…
n
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a tree with n nodes:
The minimum possible height is ⌊log2 n⌋
n minimum height = ⌊log2 n⌋ tree
1 0
2-3 1
4-7 2
… … …
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a given number of nodes, a tree is said to be
balanced if its height is minimal (or close to minimal), and
degenerate if its height is maximal (or close to maximal).
balanced degenerate
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations
Key operations on binary search trees:
• Insert
• Search
• Traverse
• Join
• Delete
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations - Analysis
The height h of a binary search tree
determines the efficiency of many operations,
so we will use both n and h in our analyses.
n = 20 h = 4
COMP2521
25T3
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations - Recursion
Many BST operations can be implemented recursively.
A binary search tree is either:
• empty; or
• consists of a node with two subtrees
• ...which are also binary search trees
4
2
1 3
8
6 9
4’s left subtree 4’s right subtree
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Insertion
bstInsert(t, v)
Given a BST t and a value v,
insert v into the BST
and return the root of the updated BST
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Insertion is straightforward:
• Start at the root
• Compare value to be inserted with value in the node
• If value being inserted is less, descend to left child
• If value being inserted is greater, descend to right child
• Repeat until...
you have to go left/right but current node has no left/right child
• Create new node and attach to current node
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Method
Recursive method:
• t is empty
⇒ make a new node with v as the root of the new tree
• v < t->item
⇒ insert v into t’s left subtree
• v > t->item
⇒ insert v into t’s right subtree
• v = t->item
⇒ tree unchanged (assuming no duplicates)
exercise Try writing an iterative version.
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 1
Insert the following values into an empty tree:
4 2 6 5 1 7 3
4
2
1 3
6
5 7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 1
Insert the following values into an empty tree:
4 2 6 5 1 7 3
4
2
1 3
6
5 7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 2
Insert the following values into an empty tree:
5 6 2 3 4 7 1
5
2
1 3
4
6
7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 2
Insert the following values into an empty tree:
5 6 2 3 4 7 1
5
2
1 3
4
6
7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 3
Insert the following values into an empty tree:
1 2 3 4 5 6 7
1
2
3
4
5
6
7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 3
Insert the following values into an empty tree:
1 2 3 4 5 6 7
1
2
3
4
5
6
7
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Pseudocode
bstInsert(t, v):
Input: tree t, value v
Output: t with v inserted
if t is empty:
return new node containing v
else if v < t->item:
t->left = bstInsert(t->left, v)
else if v > t->item:
t->right = bstInsert(t->right, v)
return t
COMP2521
25T3
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Analysis
Analysis:
• At most one node is visited per level
• Number of operations performed per node is constant
• Therefore, the worst-case time complexity of insertion is O(h) where h is
the height of the BST
COMP2521
25T3
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Search
bstSearch(t, v)
Given a BST t and a value v,
return true if v is in the BST
and false otherwise
COMP2521
25T3
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Method
Recursive method:
• t is empty:
⇒ return false
• v < t->item
⇒ search for v in t’s left subtree
• v > t->item
⇒ search for v in t’s right subtree
• v = t->item
⇒ return true
exercise Try writing an iterative version.
COMP2521
25T3
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Example
Search for 4 and 7 in the following BST:
6
2
1 3
5
8
7 9
COMP2521
25T3
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Pseudocode
bstSearch(t, v):
Input: tree t, value v
Output: true if v is in t
false otherwise
if t is empty:
return false
else if v < t->item:
return bstSearch(t->left, v)
else if v > t->item:
return bstSearch(t->right, v)
else:
return true
COMP2521
25T3
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Analysis
Analysis:
• At most one node is visited per level
• Number of operations performed per node is constant
• Therefore, the worst-case time complexity of search is O(h) where h is
the height of the BST
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Traversal
Given a BST,
visit every node of the tree
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
There are 4 common ways to traverse a binary tree:
1 Pre-order (NLR):
visit root, then traverse left subtree, then traverse right subtree
2 In-order (LNR):
traverse left subtree, then visit root, then traverse right subtree
3 Post-order (LRN):
traverse left subtree, then traverse right subtree, then visit root
4 Level-order:
visit root, then its children, then their children, and so on
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Pseudocode
Pseudocode:
preorder(t):
Input: tree t
if t is empty:
return
visit(t)
preorder(t->left)
preorder(t->right)
inorder(t):
Input: tree t
if t is empty:
return
inorder(t->left)
visit(t)
inorder(t->right)
postorder(t):
Input: tree t
if t is empty:
return
postorder(t->left)
postorder(t->right)
visit(t)
Note:
Level-order traversal is difficult to implement recursively.
It is typically implemented using a queue.
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Example: Binary Search Tree
20
10
5
2
14
12 17
30
24
29
32
31
Pre-order 20 10 5 2 14 12 17 30 24 29 32 31
In-order 2 5 10 12 14 17 20 24 29 30 31 32
Post-order 2 5 12 17 14 10 29 24 31 32 30 20
Level-order 20 10 30 5 14 24 32 2 12 17 29 31
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Example: Expression Tree
Expression tree for 1 * 3 + (5 * 7 - 9)
+
*
1 3
-
*
5 7
9
Pre-order + * 1 3 - * 5 7 9
In-order 1 * 3 + 5 * 7 - 9
Post-order 1 3 * 5 7 * 9 - +
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Applications
Pre-order traversal:
• Useful for reconstructing a tree
In-order traversal:
• Useful for traversing a BST in ascending order
Post-order traversal:
• Useful for evaluating an expression tree
• Useful for freeing a tree
Level-order traversal:
• Useful for printing a tree
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Analysis
Analysis:
• Each node is visited once
• Hence, time complexity of tree traversal is O(n), where n is the number
of nodes
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Join
bstJoin(t1, t2)
Given two BSTs t1 and t2
where max (t1) < min (t2)
return a BST containing all items from t1 and t2
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Method
Method:
1 Find the minimum node min in t2
2 Replace min by its right subtree (if it exists)
3 Elevate min to be the new root of t1 and t2
t1 t2
join(t1, t2)
t1 t′
2
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Example 1
t1
10
5 14
t2
30
24
29
26
32
join(t1, t2)
24
10
5 14
30
29
26
32
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Example 2
t1
10
5 14
t2
24
29
30
32
join(t1, t2)
24
10
5 14
29
30
32
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Pseudocode
bstJoin(t1, t2):
Input: trees t1, t2
Output: t1 and t2 joined together
if t1 is empty:
return t2
else if t2 is empty:
return t1
else if t2->left is empty:
t2->left = t1
return t2
else:
curr = t2
parent = NULL
while curr->left ̸= NULL:
parent = curr
curr = curr->left
parent->left = curr->right
curr->left = t1
curr->right = t2
return curr
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Analysis
Analysis:
• The join algorithm simply finds the minimum node in t2
• Thus, at most one node is visited per level of t2
• Therefore, the worst-case time complexity of join is O(h2) where h2 is the
height of t2
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Deletion
bstDelete(t, v)
Given a BST t and a value v
delete v from the BST
and return the root of the updated BST
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Method
Recursive method:
• t is empty:
⇒ result is empty
• v < t->item
⇒ delete v from t’s left subtree
• v > t->item
⇒ delete v from t’s right subtree
• v = t->item
⇒ three sub-cases:
• t is a leaf
⇒ result is empty tree
• t has one subtree
⇒ replace with subtree
• t has two subtrees
⇒ join the two subtrees
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
If the node being deleted is a leaf, then the result is an empty tree
5 delete 5 NULL
9
4
1 6
15
11
12
18
delete 6
9
4
1
15
11
12
18
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
Node to be deleted has one subtree
9
4
1 6
5
15
11
12
18
delete 11
9
4
1 6
5
15
12 18
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
Node to be deleted has two subtrees
9
4
1 6
15
11
12
18
delete 9
11
4
1 6
15
12 18
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Pseudocode
bstDelete(t, v):
Input: tree t, value v
Output: t with v deleted
if t is empty:
return empty tree
else if v < t->item:
t->left = bstDelete(t->left, v)
else if v > t->item:
t->right = bstDelete(t->right, v)
else:
if t->left is empty:
new = t->right
else if t->right is empty:
new = t->left
else:
new = bstJoin(t->left, t->right)
free(t)
t = new
return t
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Analysis
Analysis:
• The deletion algorithm traverses down just one branch
• First, the item being deleted is found
• If the item exists and has two subtrees, its successor is found
• Thus, at most one node is visited per level
• Therefore, the worst-case time complexity of deletion is O(h) where h is
the height of the BST
COMP2521
25T3
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
BST Exercises
• bstFree
free all nodes of a tree
• bstSize
return the size of a tree
• bstHeight
return the height of a tree
• bstPrune
given values lo and hi, remove all values outside the range [lo, hi]


================================================================================

[10/15] week04lec01-avl-trees.pdf
---------------------------------

COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
COMP2521 25T3
AVL Trees
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Invented by Georgy Adelson-Velsky and Evgenii Landis in 1962

COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Approach:
• Keep tree height-balanced
• Repair balance as soon as imbalance occurs
• During insertion or deletion
• Repairs are done locally, not by restructuring entire tree
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Height of an AVL tree
Since AVL trees are always height-balanced,
the height of an AVL tree is guaranteed to be at most
logφ (n + 1.1708) − 1.3277 (where φ is the golden ratio)
≈ 1.4404 log2(n + 1.1708) − 1.3277 =O(log n)
If you are interested in this:
https://github.com/COMP2521UNSW/gists/blob/main/height_of_
height-balanced_trees.pdf
(written by a former COMP2521 tutor)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Note:
AVL trees are not necessarily size-balanced.
For example, the following is a perfectly valid AVL tree:
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Method:
• Insert item recursively
• Check balance at each node along the insertion path in reverse
• i.e., from bottom to top
• Fix imbalances as they are found
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Example: Insert 5 into this tree
6
3
2
1 4
3
9
8
Balance must be checked at 4, then at 2, then at 6
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Example: Insert 5 into this tree
6
3
2
2
1 4
1
3 5
9
8
Balance must be checked at 4, then at 2, then at 6
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
How to check balance along insertion path in reverse?
• Perform balance checking as a postorder operation in the insertion
function
• In other words - add balance checking code below recursive calls
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Outline of insertion process:
1 if the tree is empty:
• return new node
2 insert recursively
3 check (and fix) balance
4 return root of updated tree
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Pseudocode
avlInsert(t, v):
Input: AVL tree t, item v
Output: t with v inserted
if t is empty:
return new node containing v
else if v < t->item:
t->left = avlInsert(t->left, v)
else if v > t->item:
t->right = avlInsert(t->right, v)
else:
return t
return avlRebalance(t)
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Pseudocode
avlRebalance(t):
Input: possibly unbalanced tree t
Output: balanced t
bal = balance(t)
if bal > 1:
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
return t
balance(t):
Input: tree t
Output: balance factor of t
return height(t->left) - height(t->right)
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
There are 4 rebalancing cases:
Left Left
Left Right
Right Left
Right Right
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
g Left Left g
bal = balance(t)
if bal > 1: (true)
if balance(t->left) < 0: (false)
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
1
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Left Right
bal = balance(t)
if bal > 1: (true)
if balance(t->left) < 0: (true)
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
2
1
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Right Left
bal = balance(t)
if bal > 1: (false)
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1: (true)
if balance(t->right) > 0: (true)
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
2
1
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Right Right
bal = balance(t)
if bal > 1: (false)
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1: (true)
if balance(t->right) > 0: (false)
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
1
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
Insert 7 into this tree:
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
6 3
2 2
1 0 5 1
3 0
9 2
8 1
7 0
Check for balance at 8, then at 9, then at 6.
9 is unbalanced.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
6 3
2 2
1 0 5 1
3 0
9 2
8 1
7 0
6 3
2 2
1 0 5 1
3 0
8 1
7 0 9 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
Insert 4 into this tree:
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
6 4
2 3
1 0 5 2
3 1
4 0
9 1
8 0
Check for balance at 3, then at 5, then at 2, then at 6.
5 is unbalanced.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
6 4
2 3
1 0 5 2
3 1
4 0
9 1
8 0
1
2
6 3
2 2
1 0 4 1
3 0 5 0
9 1
8 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
AVL tree insertion requires balance checking
at each node on the insertion path…
…which requires the height of many subtrees to be computed
In an ordinary binary search tree, computing the height is O(n)!
(need to traverse whole (sub)tree)
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
Solution:
For each node, store the height of its subtree in the node itself:
struct node {
int item;
struct node *left;
struct node *right;
int height;
};
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
Height of each node’s subtree is stored in the node itself
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data
When does height data need to be maintained?
• Whenever a node is inserted
• Heights of all ancestors may be affected
• Whenever a rotation is performed
• Heights of original root and new root may be affected
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
Whenever a node is inserted…
…heights of all ancestors may be affected
Example: Insert 4 into this tree
6 2
2 1
1 0 5 0
9 1
8 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 ?
4 0
9 1
8 0
Recompute height of each ancestor (from bottom to top)
using the heights stored in its children.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 ?
4 0
9 1
8 0
The heights of 5’s children are 0 and -1 (empty tree).
Thus, the height of 5 is max(0, −1) + 1 = 1.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 1
4 0
9 1
8 0
The heights of 2’s children are 0 and 1.
Thus, the height of 2 is max(0, 1) + 1 = 2.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 2
1 0 5 1
4 0
9 1
8 0
The heights of 6’s children are 2 and 1.
Thus, the height of 6 is max(2, 1) + 1 = 3.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 3
2 2
1 0 5 1
4 0
9 1
8 0
Done.
Note that recomputing the height of each node was done in O(1) time.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
Whenever a rotation is performed…
…heights of original root and new root may be affected
n1
n2
A B
C ⇌
n2
A n1
B C
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
Example: Perform a right rotation at 7
7 3
4 2
2 1
1 0
6 0
9 0
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 ?
6 0 9 0
Recompute height of original root
then recompute height of new root
using the heights stored in their children.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 ?
6 0 9 0
The height of 7’s children are 0 and 0.
Thus, the height of 7 is max(0, 0) + 1 = 1.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 1
6 0 9 0
The height of 4’s children are 1 and 1.
Thus, the height of 4 is max(1, 1) + 1 = 2.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 2
2 1
1 0
7 1
6 0 9 0
Done.
Every rotation, two height updates are performed, each in O(1) time.
COMP2521
25T3
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Analysis
Analysis:
• Height of an AVL tree is O(log n)
• In the worst case, length of insertion path is O(log n)
• Have to maintain height data and check/fix balance at each node on
insertion path
• This is O(1) per node
• Therefore, worst-case time complexity of AVL tree insertion is O(log n)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
AVL Tree Search
Exactly the same as for regular BSTs.
Worst-case time complexity is O(log n),
since AVL trees are height-balanced.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Method:
• Delete item recursively
• Check balance at each node along the deletion path ∗ in reverse
• Fix imbalances as they are found
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 10 from this tree
13
2
6
3
2
10
9
15
18
Balance must be checked at 6, then at 13
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 10 from this tree
13
2
6
1
3
2
9
15
18
Balance must be checked at 6, then at 13
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Important:
If the item being deleted has two child nodes,
the deletion path includes the path to its successor
(the smallest value in its right subtree)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 13 from this tree
13
3
8
3
5
11
23
17
15
16
22
25
28
, 13 will be replaced by 15 (its in-order successor) ,
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 13 from this tree
15
3
8
3
5
11
23
2
17
1
16
16
22
25
28
(y Balance must be checked at 17, then at 23, then at 15 y)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Pseudocode
avlDelete(t, v):
Input: AVL tree t, item v
Output: t with v deleted
if t is empty:
return empty tree
else if v < t->item:
t->left = avlDelete(t->left, v)
else if v > t->item:
t->right = avlDelete(t->right, v)
else:
if t->left is empty:
temp = t->right
free(t)
return temp
else if t->right is empty:
temp = t->left
free(t)
return temp
else:
successor = minimum value in t->right
t->item = successor
t->right = avlDelete(t->right, successor)
return avlRebalance(t)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Pseudocode
Note: This is the same as in AVL tree insertion
avlRebalance(t):
Input: possibly unbalanced tree t
Output: balanced t
bal = balance(t)
if bal > 1:
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
return t
balance(t):
Input: tree t
Output: balance factor of t
return height(t->left) - height(t->right)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing
AVL tree deletion
has the same rebalancing cases
as AVL tree insertion.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
Delete 2 from this tree:
9 4
5 2
2 1
3 0
7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
9 4
5 1
3 0 7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
Check for balance at 5 and 9
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
9 4
5 1
3 0 7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
1
2
9 is unbalanced
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
12 3
9 2
5 1
3 0 7 0
11 0
16 2
13 1
15 0
17 1
20 0
Balanced
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
Delete 8 from this tree:
8 4
3 2
1 0 6 1
4 0
13 3
9 1
10 0
17 2
15 1
14 0
18 1
20 0
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
13 3
10 0 17 2
15 1
14 0
18 1
20 0
Check for balance at 13 and 9
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
13 3
10 0 17 2
15 1
14 0
18 1
20 0
13 is unbalanced
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
17 3
13 2
10 0 15 1
14 0
18 1
20 0
Balanced
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data
Height data also needs to be maintained…
• Whenever a node is deleted
• Heights of all nodes on deletion path may be affected
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
Example: Delete 6 from this tree
19 4
6 3
5 1
1 0
16 2
11 1
12 0
17 0
25 2
23 0 28 1
29 0
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 ?
12 0 17 0
25 2
23 0 28 1
29 0
Recompute height of each node on the deletion path
using the heights stored in its children.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 ?
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 16’s children are 0 and 0.
Thus, the height of 16 is max(0, 0) + 1 = 1.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 11’s children are 1 and 1.
Thus, the height of 11 is max(1, 1) + 1 = 2.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 2
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 19’s children are 2 and 2.
Thus, the height of 19 is max(2, 2) + 1 = 3.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 3
11 2
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
Done.
Note that recomputing the height of each node was done in O(1) time.
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Analysis
Analysis:
• Height of an AVL tree is O(log n)
• In the worst case, length of deletion path is O(log n)
• Have to maintain height data and check/fix balance at each node on
deletion path
• This is O(1) per node
• Therefore, worst-case time complexity of AVL tree deletion is O(log n)
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
Summary
• AVL trees are always height-balanced
• This means the height of an AVL tree is O(log n)
• Rotations are used to fix imbalances during insertion and deletion
• Balance is checked efficiently by storing height data in each node, which
needs to be maintained
• Worst-case time complexity of O(log n) for insertion, search and deletion
COMP2521
25T3
AVL Trees
Insertion
Search
Deletion
Summary
Set ADT Implementations
We now have a new data structure for implementing the Set ADT.
Data Structure Contains Insert Delete
Unordered array O(n) O(n) O(n)
Ordered array O(log n) O(n) O(n)
Ordered linked list O(n) O(n) O(n)
AVL tree O(log n) O(log n) O(log n)


================================================================================

[11/15] week04lec01-balancing-bsts.pdf
--------------------------------------

COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
COMP2521 25T3
Balancing Binary Search Trees
Sim Mautner
cs2521@cse.unsw.edu.au
balancing operations
balancing methods
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Recap
Height of a tree: Maximum path length from the root node to a leaf
• The height of an empty tree is considered to be -1
• The height of the following tree is 3
5
2
1 3
4
8
6 9
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The structure, height, and hence
performance
of a binary search tree
depends on the order of insertion.
5
3
1 4
7
9
1
3
4
5
7
9
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The Best Case
Best case
Items are inserted evenly on the left and right throughout the tree
Height of tree will be O(log n)
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The Worst Case
Worst case
Items are inserted in ascending or descending order
such that tree consists of a single branch
Height of tree will be O(n)
…
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
A binary tree of n nodes is said to be
balanced if its height is minimal (or close to minimal) ( O(log n)), and
degenerate if it its height is maximal (or close to maximal) ( O(n)).
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
size-balanced
a size-balanced tree has,
for every node,
|size (l) − size (r)| ≤ 1
height-balanced
a height-balanced tree has,
for every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T3
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Balancing
Methods
Balancing Operations
Rotation
• Left rotation
• Right rotation
Partition
• Rearrange tree around a specified node by rotating it up to the root
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
left rotation and right rotation:
a pair of operations
that change the balance of a tree
n1
n2
t1 t2
t3
Right rotation
Left rotation
n2
t1
n1
t2 t3
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Rotations maintain the order of a search tree:
n1
n2
t1 t2
t3
Right rotation
Left rotation
n2
t1
n1
t2 t3
(all values in t1) < n2 < (all values in t2) < n1 < (all values in t3)
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 5
5
3
2 4
6
3
2 5
4 6
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 5
5
3
2 4
6
3
2 5
4 6
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate left at 3
3
2 5
4 6
5
3
2 4
6
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate left at 3
3
2 5
4 6
5
3
2 4
6
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 23
23
7
3 16
11
10
20
30
28 35
7
3 23
16
11
10
20
30
28 35
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 23
23
7
3 16
11
10
20
30
28 35
7
3 23
16
11
10
20
30
28 35
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
struct node *rotateLeft(struct node *root) {
if (root == NULL || root->right == NULL) return root;
struct node *newRoot = root->right;
root->right = newRoot->left;
newRoot->left = root;
return newRoot;
}
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Analysis
Time complexity: O(1)
• Rotation requires only a few localised pointer re-arrangements
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
partition(tree, i)
Rearrange the tree so that the element with index i becomes the root
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
6
[3]
10
[5]
17
[8]
16
[7]
20
[10]
19
[9]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Method:
• Find element with index i
• Perform rotations to lift it to the root
• If it is the left child of its parent, perform right rotation at its parent
• If it is the right child of its parent, perform left rotation at its parent
• Repeat until it is at the root of the tree
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
Partition this tree around index 3:
10
[1]
5
[0]
14
[2]
30
[4]
29
[3]
32
[5]
3
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
Partition this tree around index 3:
10
[1]
5
[0]
14
[2]
30
[4]
29
[3]
32
[5]
1
2
3
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After right rotation at 30:
10
5 14
29
30
32
2
3
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After left rotation at 14:
10
5 29
14 30
32
3
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After left rotation at 10:
29
10
5 14
30
32
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode
partition(t, i):
Input: tree t, index i
Output: tree with i-th item moved to root
leftSize = size(t->left)
if i < leftSize:
t->left = partition(t->left, i)
t = rotateRight(t)
else if i > leftSize:
t->right = partition(t->right, i - leftSize - 1)
t = rotateLeft(t)
return t
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Partition this tree around index 4
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 6, and 4 < 6...
so partition left subtree around index 4
and then rotate right at 13
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 6, and 4 < 6...
so partition left subtree around index 4
and then rotate right at 13
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 2, and 4 > 2...
so partition right subtree around index (4 - 2 - 1 = 1)
and then rotate left at 5
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 2, and 4 > 2...
so partition right subtree around index (4 - 2 - 1 = 1)
and then rotate left at 5
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 1, and 1 = 1...
so we have found the desired node
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 1, and 1 = 1...
so we have found the desired node
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Unwinding...
Rotate left at 5
13
5
3
1
8
7 10
17
16
2
1
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Unwinding...
Rotate right at 13
13
8
5
3
1
7
10
17
16
2
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Done
8
5
3
1
7
13
10 17
16
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Analysis
Analysis:
• size() operation is expensive
• Can cause partition to be O(n2) in the worst case
• For example, in the following tree:
n
n-1
n-2
…
2
1
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Analysis
Analysis (continued):
• To improve efficiency, can change node structure so that each node
stores the size of its subtree in the node itself
• However, this will require extra work in other functions to maintain
struct node {
int item;
struct node *left;
struct node *right;
int size;
};
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Balancing Methods
Two categories:
global rebalancing
visit every node and balance its subtree;
⇒ perfectly balanced tree — at cost.
local rebalancing
perform small, efficient, localised operations
to try to improve the overall balance of the tree
… at the cost of imperfect balance
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Idea:
Completely rebalance whole tree so it is size-balanced
Method:
Lift the median node to the root
by partitioning on index size(t)/2,
then rebalance both subtrees (recursively)
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
First, partition on index n/2…
a
0 (indices)
t1
n/2 n - 1
t2
b
x y
partition
b
n/2
a
0
t1
x
n - 1
t′
2
y
…then rebalance both subtrees
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Pseudocode
rebalance(t):
Input: tree t
Output: rebalanced t
if size(t) < 3:
return t
t = partition(t, size(t) / 2)
t->left = rebalance(t->left)
t->right = rebalance(t->right)
return t
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Rebalance the following tree:
15
12
5
4
2
10
8
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
First, partition the tree on index 7/2 = 3(node 8)
15
12
5
4
2
10
8
1
2
3
4
8
5
4
2
15
12
10
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
First, partition the tree on index 7/2 = 3(node 8)
15
12
5
4
2
10
8
1
2
3
4
8
5
4
2
15
12
10
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Then, recursively rebalance subtrees
8
5
4
2
15
12
10
8
4
2 5
12
10 15
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Then, recursively rebalance subtrees
8
5
4
2
15
12
10
8
4
2 5
12
10 15
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Analysis
Worst-case time complexity: O(n log n)
• Assume nodes store the size of their subtrees
• First step: partition entire tree on index n/2
• This takes at most n recursive calls, n rotations ⇒ n steps
• Result is two subtrees of size ≈ n/2
• Then partition both subtrees
• Partitioning these subtrees takes n/2 steps each ⇒ n steps in total
• Result is four subtrees of size ≈ n/4
• …and so on…
• About log2 n levels of partitioning in total, each requiring n steps
⇒ O(n log n)
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Problems
What if we insert more items?
• Options:
• Rebalance on every insertion
• Not feasible
• Rebalance every k insertions; what k is good?
• Rebalance when imbalance exceeds threshold.
• It’s a tradeoff…
• We either have more costly insertions
• Or we have degraded performance for periods of time
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Periodic Rebalancing
bstInsert(t, v):
Input: tree t, value v
Output: t with v inserted
t = insertAtLeaf(t, v)
if size(t) mod k = 0:
t = rebalance(t)
return t
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Periodic Rebalancing
Remarks
• Good if tree is not modified very often
• Otherwise…
• Insertion will be slow occasionally due to rebalancing
• Performance will gradually degrade until next rebalance
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Local Rebalancing
Perform small, efficient, localised operations
in an attempt to improve the overall balance of the tree
1. root insertion
2. randomised insertion
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Idea:
Rotations change the structure of a tree
If we perform some rotations every time we insert,
that may restructure the tree randomly enough
such that it is more balanced
One systematic way to perform these rotations:
Insert new values at the root
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Method:
Insert new value normally (at the leaf) …
… and then rotate the new node up to the root.
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Insert 24 at the root of this tree:
10
5 14
30
29 32
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Insert 24 at the root of this tree:
10
5 14
30
29
24
32
1
2
3
4
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate right at 29
10
5 14
30
29
24
32
1
2
3
4
10
5 14
30
24
29
32
2
3
4
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate right at 30
10
5 14
30
24
29
32
2
3
4
10
5 14
24
30
29 32
3
4
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate left at 14
10
5 14
24
30
29 32
3
4
10
5 24
14 30
29 32
4
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate left at 10
10
5 24
14 30
29 32
4
24
10
5 14
30
29 32
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Pseudocode
insertAtRoot(t, v):
Input: tree t, value v
Output: t with v inserted at the root
if t is empty:
return new node containing v
else if v < t->item:
t->left = insertAtRoot(t->left, v)
t = rotateRight(t)
else if v > t->item:
t->right = insertAtRoot(t->right, v)
t = rotateLeft(t)
return t
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Analysis
Analysis:
• Same time complexity as normal insertion: O(h)
• Tree is more likely to be balanced, but no guarantee
• Root insertion ensures recently inserted items are close to the root
• Useful for applications where recently added items are more likely to be
searched
• Major problem: ascending-ordered and descending-ordered data is still
a worst case for root insertion
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
BSTs don’t have control over insertion order.
Worst cases — (partially) ordered data — are common.
Idea:
Introduce some randomness into insertion algorithm:
Randomly choose whether to insert normally or insert at root
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
Pseudocode
insertRandom(t, v):
Input: tree t, value v
Output: t with v inserted
if t is empty:
return new node containing v
// p/q chance of inserting at root
if random() mod q < p:
return insertAtRoot(t, v)
else:
return insertAtLeaf(t, v)
Note: random()is a pseudo-random number generator
30% chance of root insertion ⇒ choose p = 3, q = 10
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
Remarks
Randomised insertion creates similar results to
inserting items in random order.
Tree is more likely to be balanced (but no guarantee)
COMP2521
25T3
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Summary
Advantages Disadvantages
Global
rebalancing Guarantees a balanced tree
Inefficient (O(n log n) per
rebalance), or periods of
degraded performance
Local
rebalancing
Efficient (adds only a
constant factor overhead to
insertion)
Not guaranteed to produce
a balanced tree


================================================================================

[12/15] week04lec02-graphs-intro.pdf
------------------------------------

COMP2521
25T3
Graphs
Graph ADT
Graph Reps
COMP2521 25T3
Graphs (I)
Introduction to Graphs
Sim Mautner
cs2521@cse.unsw.edu.au
graph fundamentals
graph adt
graph representations
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Fundamentals
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Motivation
Up to this point, we’ve seen a few collection types…
lists: a linear sequence of items
each node is connected to its next node
trees: a branched hierarchy of items
each node is connected to its child node(s)
what if we want something more general?
each node is connected to arbitrarily many nodes
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Motivation
Many applications need to model relationships between items.
… on a map: cities, connected by roads
… on the Web: pages, connected by hyperlinks
… in a game: states, connected by legal moves
… in a social network: people, connected by friendships
… in scheduling: tasks, connected by constraints
… in circuits: components, connected by traces
… in networking: computers, connected by cables
… in programs: functions, connected by calls
… etc. etc. etc.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
A graph is a data structure consisting of:
• A set of vertices V
• Also called nodes
• A set of edges E between pairs of vertices
v1
v2 v3
v4
V = {v1, v2, v3, v4}
E = {(v1, v2), (v1, v3), (v1, v4),
(v2, v3), (v3, v4)}
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Vertices are distinguished by a unique identifier.
• In this course, usually an integer between 0 and |V | − 1
Edges may be (optionally) directed, weighted and/or labelled.

COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Example
Example: Australian cities and roads
2716
4049
3051
732
2055
3429
1671
658
873
982
309
PER
ADL
DAR
MEL
BRI
CAN
SYD
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Problems
Questions we could answer with a graph:
• Is there a way to get from A to B?
• What is the best way to get from A to B?
• In general, what vertices can we reach from A?
• Is there a path that lets me visit all vertices?
• Can we form a tree linking all vertices?
• Are two graphs “equivalent”?
Graph problems are generally more complex to solve than linked list
problems:
• Items are not ordered
• Graphs may contain cycles
• Concrete representation is more complex
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Types of Graphs
Graphs can be a combination of these types:
undirected
unweighted
without loops
non-multigraph
or
or
or
or
directed
weighted
with loops
multigraph
... and others ...
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Undirected Graphs
In an undirected graph, edges do not have direction.
For example, Facebook friends.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Directed Graphs
In a directed graph or digraph, each edge has a direction.
For example, road maps, Twitter follows.
undirected graph directed graph
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Weighted Graphs
In a weighted graph, each edge has an associated weight.
For example, road maps, networks.
unweighted graph
3
5
1
2
weighted graph
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs with Loops
A loop is an edge from a vertex to itself.
Depending on the context,
a graph may or may not be able to have loops.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Multigraphs
In a multigraph,
multiple edges are allowed between two vertices.
For example, call graphs, maps.
Multigraphs will not be considered in this course.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
A simple graph is an undirected graph
with no loops and no multiple edges.
For now, we will only consider simple graphs.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
Question:
For a simple graph with V vertices,
what is the maximum possible number of edges?
(E = 0) E = V (V − 1)/2
Note on notation:
The number of vertices |V | and the number of edges |E|
are normally written as V and E for simplicity.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
Question:
For a simple graph with V vertices,
what is the maximum possible number of edges?
(E = 0) E = V (V − 1)/2
Note on notation:
The number of vertices |V | and the number of edges |E|
are normally written as V and E for simplicity.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(I)
Two vertices v and w are adjacent
if an edge e := (v, w) connects them;
we say e is incident on v and w.
The degree of a vertex v (deg(v))
is the number of edges incident on v.
0
1
2
3 4
deg(0) = 2
deg(1) = 3
deg(2) = 2
deg(3) = 1
deg(4) = 4
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(II)
The ratio E:V can vary considerably.
If E is closer to V 2, the graph is dense.
If E is closer to V , the graph is sparse.
dense graph sparse graph
Knowing whether a graph is dense or sparse will affect
our choice of representation and algorithms.
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(III)
A path is
a sequence of vertices where
each vertex has a edge to the next in the
sequence
A path is simple
if it has no repeating vertices
A cycle is a path where
only the first and last vertices are the same
0-1-2-0, 1-2-3-1, 0-1-3-2-0
0
1
2
3
4
5
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(IV)
A complete graph is a graph where
every vertex is connected to every other vertex via an edge.
In a complete graph, E = 1
2 V (V − 1).
K3 K5 K6
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(V)
A connected graph is a graph where
there is a path from every vertex to every other vertex.
0
1
2
3
4
5
Connected graph
0
1
2
3
4
5
Disconnected graph
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VI)
A tree is a connected graph with no cycles.
A tree has exactly one path between each pair of vertices.
0
1
2
3
4
5
Tree
0
1
2
3
4
5
Not a tree
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VII)
A subgraph of a graph G
is a graph that contains a subset of the vertices of G
and a subset of the edges between these vertices.
0
1
2
3
4
5
0
1
2
3
4
5
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VIII)
A connected component is a maximally connected subgraph.
A connected graph has one connected component — the graph itself.
A disconnected graph has two or more connected components.
0
1
2
3
4 5
6
7
8
9 10
11
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(IX)
A spanning tree of a graph G
is a subgraph that contains all the vertices of G
and is a single tree.
Spanning trees only exist for connected graphs.
0
1
2
3
4
0
1
2
3
4
0
1
2
3
4
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(X)
A spanning forest of a graph G
is a subgraph that contains all the vertices of G
and contains one tree for each connected component.
0
1
2
3
4 5
6
7
8
9 10
11
COMP2521
25T3
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(XI)
A clique is a complete subgraph.
A clique is non-trivial if it has 3 or more vertices.
0
1
2
3
4
5
6 7 8 9
10
11
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Graph ADT
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Graph ADT
What do we need to represent?
What operations do we need to support?
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Graph ADT
What do we need to represent?
A set of vertices V := {v1, · · · , vn }
A set of edges E := {(v, w) | v, w ∈ V }
What operations do we need to support?
create/destroy graph
add/remove edges
get #vertices, #edges
check if an edge exists
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Graph ADT
Operations
create/destroy
create a graph
free memory allocated to graph
query
get number of vertices
get number of edges
check if an edge exists
update
add edge
remove edge
We will extend this ADT with more complex operations later.
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Create/Destroy
typedef struct graph *Graph;
// vertices denoted by integers 0..V-1
typedef int Vertex;
/** Creates a new graph with nV vertices */
Graph GraphNew(int nV);
/** Frees all memory allocated to a graph */
void GraphFree(Graph g);
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Query
/** Returns the number of vertices in a graph */
int GraphNumVertices(Graph g);
/** Returns the number of edges in a graph */
int GraphNumEdges(Graph g);
/** Returns true if there is an edge between the given vertices
and false otherwise */
bool GraphIsAdjacent(Graph g, Vertex v, Vertex w);
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Update
/** Inserts an edge into a graph */
void GraphInsertEdge(Graph g, Vertex v, Vertex w);
/** Removes an edge from a graph */
void GraphRemoveEdge(Graph g, Vertex v, Vertex w);
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Graph Representations
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Graph Representations
3 main graph representations:
Adjacency Matrix
Edges defined by presence value in V × V matrix
Adjacency List
Edges defined by entries in array of V lists
Array of Edges
Explicit representation of edges as (v, w) pairs
We’ll consider these representations for unweighted, undirected graphs.
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
Implementation in C
struct graph {
int nV;
int nE;
bool **edges;
};
0
1
2
3
graph
edges
nV 4
nE 4
[0]
[1]
[2]
[3]
0 1 0 1
[0] [1] [2] [3]
1 0 0 1
0 0 0 1
1 1 1 0
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
Advantages and Disadvantages
Advantages
Efficient
edge insertion/deletion
and adjacency check ( O(1))
Disadvantages
Huge memory usage ( O(V 2))
sparse graph ⇒ wasted space!
undirected graph ⇒ wasted space!
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Implementation in C
struct graph {
int nV;
int nE;
struct adjNode **edges;
};
struct adjNode {
Vertex v;
struct adjNode *next;
};
0
1
2
3
graph
edges
nV 4
nE 4
[0]
[1]
[2]
[3]
1 3
0 3
3
0 1 2
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Advantages and Disadvantages
Advantages
Space-efficient for
sparse graphs
O(V + E) memory usage
Disadvantages
Inefficient
edge insertion/deletion (O(V ))
(matters less for sparse graphs)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Implementation in C
struct graph {
int nV;
int nE;
int maxE;
struct edge *edges;
};
struct edge {
Vertex v;
Vertex w;
};
0
1
2
3
graph
edges
nV 4
nE 4
maxE 8
(0,1) (0,3) (1,3) (2,3)
[0] [1] [2] [3] [4] [5] [6] [7]
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Advantages and Disadvantages
Advantages
Very space-efficient for
sparse graphs where E < V
Disadvantages
Inefficient
edge insertion/deletion (O(E))
COMP2521
25T3
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Summary of Graph Representations
Adjacency Matrix Adjacency List Array of Edges
Space usage O(V 2) O(V + E) O(E)
Create O(V 2) O(V ) O(1)
Destroy O(V ) O(V + E) O(1)
Insert edge O(1) O(V ) O(E)
Remove edge O(1) O(V ) O(E)
Is adjacent O(1) O(V ) O(E)*
Degree O(V ) O(V ) O(E)*
* Can be O(log E) if the array is ordered
and both directions of each edge are stored in an undirected graph


================================================================================

[13/15] week05lec01-graph-traversal.pdf
---------------------------------------

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
COMP2521 25T3
Graphs (II)
Graph Traversal
Sim Mautner
cs2521@cse.unsw.edu.au
bfs and dfs
path checking
path finding
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
Problems on Graphs
Common problems on graphs:
• Is there a path between two vertices?
• What is the shortest path between two vertices?
• Which vertices are reachable from a particular vertex?
• Is the graph connected?
• Is there a cycle?
• How many connected components are there?
• Is there a simple path/cycle that passes through all vertices?
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
All of the above problems can be solved by
a systematic exploration of a graph via its edges.
This systematic exploration is called traversal or search.
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
Two primary methods for graph traversal/search:
Breadth-first search (BFS)
• Prioritises exploring widely over exploring deeply
• “Go wide”
• Implemented iteratively (using a queue)
Depth-first search (DFS)
• Prioritises exploring deeply over exploring widely
• “Go deep”
• Implemented recursively or iteratively (using a stack)
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a tree
In what order would BFS and DFS visit the nodes of this tree?
(Assume that nodes towards the left have higher priority)
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a tree
Breadth-first search
1
2
5
10
16 17
6
11
3
7
12 13
18
4
8 9
14
19
15
Depth-first search
1
2
3
4
5 6
7
8
9
10
11 12
13
14
15 16
17
18
19
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a graph
In what order would BFS and DFS visit the vertices of this graph?
(Assume that nodes containing smaller letters have higher priority)
a
b
c
d
e
f
g
h
i
COMP2521
25T3
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a graph
Breadth-first search
a1
b2
c
3 d 4
e5
f8
g 6
h9
i 7
Depth-first search
a1
b2
c
3 d 4
e8
f7
g 6
h9
i 5
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Breadth-first search visits vertices
in order of distance from the starting vertex.
BFS is implemented iteratively using a queue.
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Data structures
Data structures used in BFS:
• Visited array
• To keep track of which vertices have been visited
• Predecessor array
• To keep track of the predecessor of each vertex
• The predecessor of v is the vertex from which we reached v
• i.e., the vertex before v on the path to v
• Queue
• First-in-first-out data structure
• Stores unvisited vertices in the order that they should be visited
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Algorithm
Algorithm:
1 Create/initialise data structures:
• Create visited array, initialised to false
• Create predecessor array, initialised to -1
• Create empty queue
2 Mark starting vertex as visited and enqueue it
3 While the queue is not empty:
1 Dequeue a vertex
• Let this vertex be v
2 Explore v - that is, for each of v’s unvisited neighbours:
1 Mark it as visited
2 Set its predecessor to v
3 Enqueue it
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Example
0
1
2
3
4
5
6
7
8
9
BFS starting at 0
Done
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
pred
-1 0 0 2 5 0 5 5 4 7
queue
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Example
0
1
2
3
4
5
6
7
8
9
BFS starting at 0
Done
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
pred -1 0 0 2 5 0 5 5 4 7
queue 0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Pseudocode
bfs(G, src):
Input: graph G, starting vertex src
create visited array, initialised to false
create predecessor array, initialised to -1
create queue Q
visited[src] = true
enqueue src into Q
while Q is not empty:
v = dequeue from Q
for each neighbour w of v in G where visited[w] = false:
visited[w] = true
predecessor[w] = v
enqueue w into Q
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Simplification
When using a predecessor array in BFS,
the predecessor array can double as a visited array
predecessor[v] = -1means v is not visited
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Simplification
bfs(G, src):
Input: graph G, starting vertex src
create predecessor array, initialised to -1
create queue Q
predecessor[src] = src // <- mark src as visited
enqueue src into Q
while Q is not empty:
v = dequeue from Q
for each neighbour w of v in G where predecessor[w] = -1:
predecessor[w] = v
enqueue w into Q
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Analysis
BFS is O(V + E) when using the adjacency list representation:
• Typical queue implementation has O(1) enqueue and dequeue
• Each vertex is visited at most once ⇒ O(V )
• For each vertex, all of its edges are considered once ⇒ O(E)
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
A BFS finds the shortest path between the starting vertex and all other
vertices.
• Shortest path in terms of the number of edges
The shortest path between src and dest can be found by tracing backwards
through the predecessor array (from dest to src).
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 → 4 →
8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 → 4 →
8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 →
4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 →
4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→
5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→
5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0 −→5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T3
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
bfsFindPath(G, src, dest):
Input: graph G, vertices src and dest
... BFS starting from src ...
if predecessor[dest] ̸= -1:
v = dest
while v ̸= src:
print v, "<-"
v = predecessor[v]
print src
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Iterative
Ideas/Issues
Appendix
Depth-First Search
Depth-first search goes as far down one path
as possible until it reaches a dead end,
then backtracks until it finds a new path to take,
then repeats
DFS can be implemented recursively or iteratively.
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Depth-first search is described recursively as:
1 Mark current vertex as visited
• The first time, this is the starting vertex
2 For each neighbour of the current vertex:
• If it has not been visited:
• Recursively traverse starting from that vertex
The recursion naturally induces backtracking.
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Pseudocode
dfs(G, src):
Input: graph G, starting vertex src
create visited array, initialised to false
dfsRec(G, src, visited)
dfsRec(G, v, visited):
Input: graph G, vertex v, visited array
visited[v] = true // "visit" v
for each neighbour w of v in G:
if visited[w] = false:
dfsRec(G, w, visited)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Example
0
1
2
3
4
5
6
7
8
9
DFS starting at 0
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0 0 0 0 0 0 0 0 0 0
visit order
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Example
0
1
2
3
4
5
6
7
8
9
Done p
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
visit order 0 1 5 3 2 4 7 8 9 6
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Analysis
Recursive DFS is O(V + E) when using the adjacency list representation:
• Each vertex is visited at most once ⇒ O(V )
• Function is called on each vertex at most once
• For each vertex, all of its edges are considered once ⇒ O(E)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Recursive DFS can be adapted to check if a path exists between two vertices.
Idea:
• To check if a path exists between src and dest:
• If src = dest, then there is a path (the empty path)
• Otherwise, for each neighbour of src, recursively check if there is a path
from that neighbour to dest
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Example
Does there exist a path between 0 and 7 in this graph?
0
1
2
3
4
5
6
7
8
9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Example
pAnswer: Yes p
0
1
2
3
4
5
6
7
8
9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Pseudocode
dfsHasPath(G, src, dest):
Input: graph G, vertices src and dest
Output: true if there is a path from src to dest
false otherwise
create visited array, initialised to false
return dfsHasPathRec(G, src, dest, visited)
dfsHasPathRec(G, v, dest, visited):
Input: graph G, vertices v and dest, visited array
visited[v] = true
if v = dest:
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHasPathRec(G, w, dest, visited):
return true
return false
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Analysis
O(V + E) when using the adjacency list representation:
• Algorithm is just a modified recursive DFS with return statements
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
How to get the path?
Idea:
• Record the predecessor of each vertex during the DFS
• Trace backwards through the path after the DFS
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Pseudocode
dfsFindPath(G, src, dest):
Input: graph G, vertices src and dest
create predecessor array, initialised to -1
predecessor[src] = src
if dfsFindPathRec(G, src, dest, predecessor):
v = dest
while v ̸= src:
print v, "<-"
v = predecessor[v]
print src
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Pseudocode
dfsFindPathRec(G, v, dest, predecessor):
if v = dest:
return true
for each neighbour w of v in G:
if predecessor[w] = -1:
predecessor[w] = v
if dfsFindPathRec(G, w, dest, predecessor):
return true
return false
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Example
Find a path from 0 to 7
0
1
2
3
4
5
6
7
8
9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Example
Path found:
0
1
2
3
4
5
6
7
8
9
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0 0 3 5 3 1 -1 4 -1 -1
Clearly, DFS is not guaranteed to find the shortest path.
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
DFS can be implemented iteratively.
Iterative DFS is similar to BFS, but there are a few crucial differences:
• DFS uses a stack instead of a queue
• DFS marks a vertex as visited after removing it from the stack, not when
adding it (which is what BFS does, but with a queue)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
Pseudocode
dfs(G, src):
Input: graph G, vertex src
create visited array, initialised to false
create predecessor array, initialised to -1
create stack S
push src onto S
while S is not empty:
v = pop from S
if visited[v] = true:
continue // i.e., return to start of loop
visited[v] = true
for each neighbour w of v in G where visited[w] = false:
predecessor[w] = v
push w onto S
COMP2521
25T3
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
Analysis
Iterative DFS is O(V + E) when using the adjacency list representation.
• Typical stack implementation has O(1) push and pop
• Each vertex visited at most once ⇒ O(V )
• For each vertex, all of its edges are considered ⇒ O(E)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Spanning Trees
The edges traversed in a graph traversal form a spanning tree.
Consider the following graph:
a
b
c
d
e
f
g
h
i
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Spanning Trees
A traversal starting at vertex ‘a’ forms the following spanning trees:
a
b
c
d
e
f
g
h
i
Breadth-first search
a
b
c
d
e
f
g
h
i
Depth-first search
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
If a graph is not connected,
a graph traversal starting from a given vertex
will not traverse the entire graph
0
1
2
3
4 5
6
7
8
9
010
11
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
Solution
After initial traversal is complete,
perform traversal again on an unvisited vertex,
repeat until all vertices are visited
This produces a spanning forest
0
1
2
3
4 5
6
7
8
9
010
11
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
dfs(G):
Input: graph G
create predecessor array, initialised to -1
for each vertex v in G:
if predecessor[v] = -1:
dfsRec(G, v, predecessor)
...
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Appendix
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we avoid revisiting the same tiles?
Mark tiles as they are visited!
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we avoid revisiting the same tiles?
Mark tiles as they are visited!
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we find our way back to the entrance?
For each tile that we visit,
keep note of the tile we were on directly before it!
This is called the predecessor.
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we find our way back to the entrance?
For each tile that we visit,
keep note of the tile we were on directly before it!
This is called the predecessor.
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done
pMark 0 as visited
pMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
00 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0
Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
00 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
0
0 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
0
0 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visited
pMark 1 as visited
pMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0 -1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
00
0 1
0 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0 -1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
00
0 1
0 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visited
pMark 2 as visited
pMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 1
0 1 2
0 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 1
0 1 2
0 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visited
pMark 5 as visited
Done exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visited
Done exploring 0
p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0
Dequeue 1
Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0
p0 is already visited
p5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visited
p5 is already visited
Done exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visited
Done exploring 1
p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1
Dequeue 2
Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1
p0 is already visited
pMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visited
pMark 3 as visited
Done exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visited
Done exploring 2
p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2
Dequeue 5
Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2
p0 is already visited
p1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visited
p1 is already visited
p3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visited
p3 is already visited
pMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visited
pMark 4 as visited
pMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 3
0 1 2 5 3 4
0 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 3
0 1 2 5 3 4
0 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visited
pMark 6 as visited
pMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5 -1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 4
0 1 2 5 3 4 6
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5 -1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 4
0 1 2 5 3 4 6
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visited
pMark 7 as visited
Done exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visited
Done exploring 5
p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5
Dequeue 3
Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5
p2 is already visited
p4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visited
p4 is already visited
p5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visited
p5 is already visited
Done exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visited
Done exploring 3
p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3
Dequeue 4
Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3
p3 is already visited
p5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visited
p5 is already visited
p7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5
7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visited
p7 is already visited
pMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5
7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visited
pMark 8 as visited
Done exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visited
Done exploring 4
p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4
Dequeue 6
Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4
p5 is already visited
Done exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visited
Done exploring 6
p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6
Dequeue 7
Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6
p4 is already visited
p5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visited
p5 is already visited
p8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visited
p8 is already visited
pMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visited
pMark 9 as visited
Done exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visited
Done exploring 7
p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7
Dequeue 8
Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7
p4 is already visited
p7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visited
p7 is already visited
p9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visited
p9 is already visited
Done exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visited
Done exploring 8
p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8
Dequeue 9
Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8
p7 is already visited
p8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visited
p8 is already visited
Done exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visited
Done exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9
Done
pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0
Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0
Mark 0 as visited
1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited
1 has not been visited
Recurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visited
Recurse into 1
Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1
Mark 1 as visited
5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited
5 has not been visited
Recurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visited
Recurse into 5
Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5
Mark 5 as visited
3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited
3 has not been visited
Recurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visited
Recurse into 3
Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3
Mark 3 as visited
2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited
2 has not been visited
Recurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visited
Recurse into 2
Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2
Mark 2 as visited
Return4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visited
Return
4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn
4 has not been visited
Recurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visited
Recurse into 4
Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4
Mark 4 as visited
7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited
7 has not been visited
Recurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visited
Recurse into 7
Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7
Mark 7 as visited
8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
8 has not been visited
Recurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visited
Recurse into 8
Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8
Mark 8 as visited
9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited
9 has not been visited
Recurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visited
Recurse into 9
Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9
Mark 9 as visited
ReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visited
Return
ReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturn
Return
ReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturn
Return
ReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturn
Return
Return6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturn
Return
6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn
6 has not been visited
Recurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visited
Recurse into 6
Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6
Mark 6 as visited
ReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visited
Return
ReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturn
Return
ReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturn
Return
Return
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturn
Return
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?
Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?
Mark 0 as visited
1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited
1 has not been visited
Recurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visited
Recurse into 1
Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1
Mark 1 as visited
5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited
5 has not been visited
Recurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visited
Recurse into 5
Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5
Mark 5 as visited
3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited
3 has not been visited
Recurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visited
Recurse into 3
Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3
Mark 3 as visited
2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited
2 has not been visited
Recurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visited
Recurse into 2
Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2
Mark 2 as visited
Return false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visited
Return false
4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false
4 has not been visited
Recurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visited
Recurse into 4
Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4
Mark 4 as visited
7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited
7 has not been visited
Recurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visited
Recurse into 7
Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7
Mark 7 as visited
Return trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T3
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?


================================================================================

[14/15] week05lec02-directed-weighted-graphs.pdf
------------------------------------------------

COMP2521
25T3
Directed
Graphs
Weighted
Graphs
COMP2521 25T3
Graphs (IV)
Directed and Weighted Graphs
Sim Mautner
cs2521@cse.unsw.edu.au
directed graphs
weighted graphs
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Generalising Graphs
In graphs representing real-world scenarios,
edges are often directional and may have a sense of cost.
Thus, we need to consider directed and weighted graphs.
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Directed Graphs
Some applications require us to consider
directional edges: v → w ̸= w → v
e.g., ‘follow’ on Twitter, one-way streets, etc.
In a directed graph or digraph:
edges have direction.
Each edge (v, w) has a source v and a destination w.
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Directed Graphs
Example
a
d
g
f
b
c
e
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Directed Graphs
Applications
application vertex is… edge is…
WWW web page hyperlink
chess board state legal move
scheduling task precedence
program function function call
journals article citation
make target dependency
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Digraph Terminology
(I)
in-degree
deg−(v) or in(v)
the number of incoming edges to a vertex
out-degree
deg+(v) or out(v)
the number of outgoing edges from a vertex
0
1
2 3
in(0) = 1
in(1) = 2
in(2) = 1
in(3) = 2
out(0) = 1
out(1) = 0
out(2) = 3
out(3) = 2
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Digraph Terminology
(II)
A directed path is
a sequence of vertices where
each vertex has an outgoing edge to
the next vertex in the sequence
If there is a directed path from v to w,
then we say that w is reachable from v
A directed cycle is
a directed path where
the first and last vertices are the same
e.g., 0-2-3-1-0, 1-2-3-1
0
1
2
3
4
5
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Digraph Terminology
(III)
A digraph is strongly connected if
there is a directed path from every vertex to every other vertex
0
1
2
3
4
strongly connected
0
1
2
3
4
not strongly connected
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Digraph Terminology
(IV)
A strongly-connected component is a
maximally strongly-connected subgraph.
A digraph that is not strongly connected has
two or more strongly-connected components.
0 1 2 3
4 5 6 7
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Directed Graphs
Representations
Same representations as for undirected graphs:
• Adjacency matrix
• Adjacency list
• Array of edges
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Directed Graphs
Representations
0
1
2 3
0 1 0 0
0 0 0 0
1 1 0 1
0 0 1 1
[0]
[1]
[2]
[3]
1
0 1 3
2 3
[0]
[1]
[2]
[3]
0 1
2 0
2 1
2 3
3 2
3 3
Adjacency matrix Adjacency list Array of edges
COMP2521
25T3
Directed
Graphs
Applications
Terminology
Representations
Weighted
Graphs
Digraph Complexity
Adjacency Matrix Adjacency List Array of Edges
Space usage O(V 2) O(V + E) O(E)
Insert edge O(1) O(deg(v)) O(E)
Remove edge O(1) O(deg(v)) O(E)
Contains edge O(1) O(deg(v)) O(log(E))
Real digraphs tend to be sparse (large V , small average deg(v)),
so we use deg(v) to denote the degree of the source vertex v.
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graphs
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graphs
Some applications require us to consider a cost or weight
assigned to a relation between two nodes.
In a weighted graph, each edge ( s, t, w) has a weight w.
0 1
2 3
4
5
3 5
8
2
7
Weighted Graph
0 1
2 3
4
4
3
6
4
2
2 7
6
Directed Weighted Graph
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graphs
Example: Major airline routes in Australia
2. 1
3.2
2.5
3.0
3.0 2. 1
0.8
2.0
1.5
1.8
0.8
1. 1
0.8
0.6
PER
ADL
DAR
MEL
BRI
CAN
SYD
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graphs
Representations
Adjacency matrix:
• store weight in each cell, not just true/false
• need a value to signify “no edge”
Adjacency list:
• add weight to each list node
Array of edges:
• add weight to each edge
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graphs
Representations: Adjacency Matrix
0
1 2
3
4
0.5


0 1 1 1 0
1 0 1 0 0
1 1 0 1 1
1 0 1 0 1
0 0 1 1 0


undirected, unweighted
0
1 2
3
4
0.2
0.4
0.5
0.5
0. 1
0. 1
0.9


− 0.2 0 .4 0 .5 −
0.2 − 0.5 − −
0.4 0 .5 − 0.1 0 .1
0.5 − 0.1 − 0.9
− − 0.1 0 .9 −


undirected, weighted
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graph
Representations: Adjacency Matrix
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
* 0.2 0.4 * *
* 0.3 0.6 * *
* 0.5 * 0. 1 *
0.7 * * * 0.9
* * 0. 1 * *
[0]
[1]
[2]
[3]
[4]
edges
nV
nE
5
9
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graph
Representations: Adjacency List
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
1 0.2 2 0.4
1 0.3 2 0.6
1 0.5 3 0. 1
0 0.7 4 0.9
2 0. 1
[0]
[1]
[2]
[3]
[4]
edges
nV
nE
5
9
COMP2521
25T3
Directed
Graphs
Weighted
Graphs
Representations
Weighted Graph
Representations: Array of Edges
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
edges
nV
nE
maxE
5
9
...
0 1 0.2
0 2 0.4
1 1 0.3
1 2 0.6
2 1 0.5
2 3 0. 1
3 0 0.7
3 4 0.9
4 2 0. 1


================================================================================

[15/15] week05lec02-graph-problems.pdf
--------------------------------------

COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
COMP2521 25T3
Graphs (III)
Graph Problems
Sim Mautner
cs2521@cse.unsw.edu.au
cycle checking
connected components
hamiltonian paths/circuits
eulerian paths/circuits
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Graph Problems
Basic graph problems:
• Is there a cycle?
• How many connected components are there?
• Is there a simple path/cycle that passes through all vertices?
• Is there a path/cycle that passes through each edge exactly once?
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
A cycle is a path of length > 2
where the start vertex = end vertex
and no edge is used more than once
0 1
2
3
4 5 6
This graph has three distinct cycles:
1-2-5-1, 2-5-6-2, 1-2-6-5-1
(two cycles are distinct if they have different sets of edges)
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
How to check if a graph has a cycle?
Idea:
• Perform a DFS, starting from any vertex
• During the DFS, if the current vertex has an edge to an already-visited
vertex, then there is a cycle
0 1
2
3
4 5 6
tests/cycle1.txt
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
pick any vertex v in G
create visited array, initialised to false
return dfsHasCycle(G, v, visited)
dfsHasCycle(G, v, visited):
visited[v] = true
for each neighbour w of vin G:
if visited[w] = true:
return true
else if dfsHasCycle(G, w, visited):
return true
return false
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
Problem:
• The algorithm does not check whether the neighbour w is the vertex that
it just came from
• Therefore, it considers moving back and forth along a single edge to be a
cycle (e.g., 0-1-0)
0 1
2
3
4 5 6
tests/cycle2.txt
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
Improved idea:
• Perform a DFS, starting from any vertex
• Keep track of previous vertex during DFS
• During the DFS, if the current vertex has an edge to an already-visited
vertex which is not the previous vertex , then there is a cycle
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
pick any vertex v in G
create visited array, initialised to false
return dfsHasCycle(G, v, v, visited)
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each neighbour w of v in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
Problem:
• The algorithm only checks one connected component
• The connected component that the initially chosen vertex belongs to
0 1
2
3
4 5 6
tests/cycle3.txt
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Working Solution
Working idea:
• Perform a DFS, starting from any vertex
• Keep track of previous vertex during DFS
• During the DFS, if the current vertex has an edge to an already-visited
vertex which is not the previous vertex, then there is a cycle
• After the DFS, if any vertex has not yet been visited, perform another
DFS, this time starting from that vertex
• Repeat until all vertices have been visited
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Working Solution
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
create visited array, initialised to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, v, visited):
return true
return false
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each neighbour w of v in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
COMP2521
25T3
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Analysis
Analysis for adjacency list representation:
• Algorithm is a slight modification of DFS
• A full DFS traversal is O(V + E)
• Thus, worst-case time complexity of cycle checking is O(V + E)
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
A connected component
is a maximally connected subgraph
For example, this graph has three connected components:
0 1
2
3
4 5 6
7
8
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Definitions:
subgraph
a subset of vertices and edges of original graph
connected subgraph
there is a path between every pair of vertices in the subgraph
maximally connected subgraph
no way to include more edges/vertices from original graph into the subgraph
such that subgraph is still connected
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Problems:
How many connected components are there?
Are two vertices in the same connected component?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Goal:
• Compute an array which indicates which connected component each
vertex is in
• Let this array be called componentOf
• componentOf[v]contains the component number of vertex v
• For example:
0 1
2
3
4 5 6
7
8
[0]
0
[1]
0
[2]
1
[3]
1
[4]
0
[5]
1
[6]
1
[7]
2
[8]
2
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Idea:
• Choose a vertex and perform a DFS starting at that vertex
• During the DFS, assign all vertices visited to component 0
• After the DFS, if any vertex has not been assigned a component,
perform a DFS starting at that vertex
• During this DFS, assign all vertices visited to component 1
• Repeat until all vertices are assigned a component, increasing the
component number each time
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
components(G):
Input: graph G
Output: componentOf array
create componentOf array, initialised to -1
compNo = 0
for each vertex v in G:
if componentOf[v] = -1:
dfsComponents(G, v, componentOf, compNo)
compNo = compNo + 1
return componentOf
dfsComponents(G, v, componentOf, compNo):
componentOf[v] = compNo
for each neighbour w of v in G:
if componentOf[w] = -1:
dfsComponents(G, w, componentOf, compNo)
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Analysis
Analysis for adjacency list representation:
• Algorithm performs a full DFS, which is O(V + E)
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Suppose we frequently need to answer the following questions:
• How many connected components are there?
• Are v and w in the same connected component?
• Is there a path between v and w?
Note: The last two questions are actually equivalent in an undirected graph.
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Solution:
• Cache the components array in the graph struct
struct graph {
...
int nC; // number of connected components
int *cc; // componentOf array
};
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
This allows us to answer the questions very easily:
// How many connected components are there?
int numComponents(Graph g) {
return g->nC;
}
// Are v and w in the same connected component?
bool inSameComponent(Graph g, Vertex v, Vertex w) {
return g->cc[v] == g->cc[w];
}
// Is there a path between v and w?
bool hasPath(Graph g, Vertex v, Vertex w) {
return g->cc[v] == g->cc[w];
}
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
However, this information needs to be maintained as the graph changes:
• Inserting an edge may reduce nC
• If the endpoint vertices were in different components
• Removing an edge may increase nC
• If the endpoint vertices were in the same component and there is no other
path between them
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
A Hamiltonian path is
a path that includes each vertex exactly once
A Hamiltonian circuit is
a cycle that includes each vertex exactly once
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Named after
Irish mathematician, astronomer and physicist
Sir William Rowan Hamilton (1805-1865)

COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Consider the following graph:
0
1
2
3
4
0
1
2
3
4
Hamiltonian path
0
1
2
3
4
pHamiltonian circuit p
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
How to check if a graph has a Hamiltonian path?
Idea:
• Brute force
• Use DFS to check all possible paths
• Recursive DFS is perfect, as it naturally allows backtracking
• Keep track of the number of vertices left to visit
• Stop when this number reaches 0
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
hasHamiltonianPath(G):
Input: graph G
Output: true if G has a Hamiltonian path
false otherwise
create visited array, initialised to false
for each vertex v in G:
if dfsHamiltonianPath(G, v, visited, #vertices(G)):
return true
return false
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
dfsHamiltonianPath(G, v, visited, numVerticesLeft):
visited[v] = true
numVerticesLeft = numVerticesLeft - 1
if numVerticesLeft = 0:
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHamiltonianPath(G, w, visited, numVerticesLeft):
return true
visited[v] = false
return false
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
Why set visited[v]to false at the end of dfsHamiltonianPath?
0
1
2
3
4
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Circuit
How to check if a graph has a Hamiltonian circuit?
• Similar approach as Hamiltonian path
• Don’t need to try all starting vertices
• After a Hamiltonian path is found, check if the final vertex is adjacent to
the starting vertex
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Circuit
hasHamiltonianCircuit(G):
Input: graph G
Output: true if G has a Hamiltonian circuit
false otherwise
if #vertices(G) < 3:
return false
create visited array, initialised to false
return dfsHamiltonianCircuit(G, 0, visited, #vertices(G))
dfsHamiltonianCircuit(G, v, visited, numVerticesLeft):
visited[v] = true
numVerticesLeft = numVerticesLeft - 1
if numVerticesLeft = 0 and adjacent(G, v, 0):
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHamiltonianCircuit(G, w, visited, numVerticesLeft):
return true
visited[v] = false
return false
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Analysis
Analysis:
• Worst-case time complexity: O(V !)
• There are at most V ! paths to check ( ≈
√
2πV (V /e)V by Stirling’s
approximation)
• There is no known polynomial time algorithm, so the Hamiltonian path
problem is NP-hard
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
An Eulerian path is
a path that visits each edge exactly once
An Eulerian circuit is
an Eulerian path that starts and ends at the same vertex
0 1
2 3
4
Eulerian path:
4-2-0-1-3-0
0 1
2 3
4
Eulerian circuit:
4-2-0-1-3-4
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
Problem is named after
Swiss mathematician, physicist, astronomer, logician and engineer
Leonhard Euler (1707-1783)

COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
Problem was introduced by Euler while trying to solve the
Seven Bridges of Konigsberg problem in 1736.
Is there a way to cross all the bridges exactly once on a walk through the
town?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
This is a graph problem:
vertices represent pieces of land
edges represent bridges

COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
How to check if a graph has an Eulerian path or circuit?
Can use the following theorems:
A graph has an Eulerian path if and only if
exactly zero or two vertices have odd degree,
and all vertices with non-zero degree belong to the same connected
component
A graph has an Eulerian circuit if and only if
every vertex has even degree,
and all vertices with non-zero degree belong to the same connected
component
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Which of these graphs have an Eulerian path? How about an Eulerian circuit?
0 1
2
0 1
2 3
4
0 1
2 3
4 5
6
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Why
“all vertices with non-zero degree belong to the same connected
component”?
0 1
2 3
4
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path
hasEulerianPath(G):
Input: graph G
Output: true if G has an Eulerian path
false otherwise
numOddDegree = 0
for each vertex v in G:
if degree(G, v) is odd:
numOddDegree = numOddDegree + 1
return (numOddDegree = 0 or numOddDegree = 2) and
eulerConnected(G)
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path
eulerConnected(G):
Input: graph G
Output: true if all vertices in G with non-zero degree
belong to the same connected component
false otherwise
create visited array, initialised to false
for each vertex v in G:
if degree(G, v) > 0:
dfsRec(G, v, visited)
break
for each vertex v in G:
if degree(G, v) > 0 and visited[v] = false:
return false
return true
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Circuit
hasEulerianCircuit(G):
Input: graph G
Output: true if G has an Eulerian circuit
false otherwise
for each vertex v in G:
if degree(G, v) is odd:
return false
return eulerConnected(G)
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Analysis
Analysis for adjacency list representation:
• Finding degree of every vertex is O(V + E)
• Checking connectivity requires a DFS which is O(V + E)
• Therefore, worst-case time complexity is O(V + E)
So unlike the Hamiltonian path problem, the Eulerian path problem can be
solved in polynomial time.
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
Many graph problems are intractable – that is,
there is no known “efficient” algorithm to solve them.
In this context, “efficient” usually means polynomial time.
A tractable problem is one that is known to have a
polynomial-time solution.
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T3
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Bonus Round!
a
b
c
d
e
f
g
h
1 2
34
5 6
78
Graph isomorphism:
Can we make two given graphs identical by renaming vertices?


================================================================================

