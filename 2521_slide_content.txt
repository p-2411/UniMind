PDFs to Text — Consolidated Output (pypdf-only)
===============================================

Source folder: /Users/parhamsepasgozar/Desktop/UniMind/slides/comp2521
Matched PDFs: 24
Generated at: 2025-09-30 20:15:02

[1/24] week01lec01-intro.pdf
----------------------------

COMP2521
25T2
Introduction
Tools
Welcome!
COMP2521 25T2
Data Structures and Algorithms
COMP2521
25T2
Introduction
Tools
COMP2521 25T2
Introduction
Sim Mautner
cs2521@cse.unsw.edu.au
course introduction
tools of the trade
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Course Goals
to get you thinking like a computer scientist
not just a programmer
• know and understand fundamental data structures, algorithms
• reason about applicability + effectiveness
• analyse behaviour/correctness of programs
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assumed Knowledge
We assume that you can:
• Produce a correct C program from a specification
• Use fundamental control structures
(sequence, selection ( if), iteration (while))
• Use fundamental C data types and data structures
(char, int, double, arrays, structs, pointers, linked lists)
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acquired Knowledge
In this course, you will learn:
• data structures: trees, graphs, hash tables, tries
• data structure/algorithm analysis: time/space complexity
• sorting and searching techniques
• graph algorithms
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acquired Skills
By the end of this course, you should be able to:
• Implement solutions to a wider range of problems
• Analyse performance characteristics of algorithms
• Analyse performance characteristics of data structures
• Make decisions about appropriate data structures and algorithms
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Course Staff
Convenor John Shepherd
Lecturer Sim Mautner
Admins Kevin Luxa, Ethan Brown and Ryan Berlee
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Contact
Website https://webcms3.cse.unsw.edu.au/COMP2521/25T2/
Email cs2521@cse.unsw.edu.au
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Teaching/Assessment Methods
Lectures
Tutorials
Labs
Quizzes
Assignments
Exam
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Lectures
Four hours of lectures per week
• Monday 11:00–13:00; Wednesday 14:00–16:00
• In person in Keith Burrows Theatre
• Also livestreamed via YouTube
• Link to livestream on the lectures page
• Feel free to ask questions in the chat
• Recordings will be on YouTube
• present a brief overview of theory
• demonstrate problem-solving methods
• give practical demonstrations
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Tutorials
Weekly one-hour tutorials
• tutorials start in week 1
• run every week, except flex week
• online classes are via Blackboard Collaborate
• tutorials clarify lecture material
• work through problems related to lecture topics
• questions available (usually) the week before
• answers available Friday evening
To get the best out of tutorials
• read and attempt the problems yourself beforehand
• don’t keep quiet in tutorials… talk, discuss, …
• ask if you don’t understand something
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Labs
Each tutorial is followed by a two-hour lab class
• several exercises, mostly small implementation/analysis tasks
• aim to improve your coding and analysis skills
• give you experience applying algorithms and techniques
• done individually, unless specified
• submitted via give, before Monday 17:00 09:00 the following week
• many labs have a handmarking component (see spec for details)
• handmarking completed by showing your work to your tutor in the lab
within two weeks of the lab
• worth 15% of your final mark, best 7 of 8 labs used to calculate the 15%
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Quizzes
Weekly quizzes
• on WebCMS
• questions about previous week’s lectures
• different kinds of questions
• multiple choice, multiple select, fill-in-the-blank…
• aim to test your knowledge and understanding of the theory
• done individually
• due Monday 17:00 09:00 the following week
• can submit multiple times, only last submission is marked
• worth 10% of your final mark, best 7 of 8 quizzes used to calculate the
10%
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assignments
Two assignments
• each worth 15% of your final mark
• give you experience applying algorithms to larger problems
• done individually
• help sessions will be available to assist with assignments
• will be very busy in the last days before an assignment is due
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Late Penalties
Labs, quizzes and assignments all have the same late penalty
• UNSW standard late penalty
• 0.2% of the maximum mark taken from your raw mark for each hour late
• equivalent to 4.8% per day
• submissions later than 5 days not allowed (automatically enforced)
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Sample Solutions and Marking
Due to the UNSW standard late penalty allowing late submissions up to 5
days after the deadline, along with extensions for special consideration:
• sample solutions for labs will be released 12 days after the due date
• marks for labs will be released a week after the due date
• answers and marks for quizzes will be released 5 days after the due date
• sample solutions for assignments are not released
• marks for assignments are released in two parts
• automarking will be released a week after the due date
• handmarking (style, automarking adjustments) takes longer and will be
released 2 weeks after the automarking
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Final Exam
• 3 hour in-person exam, during exam period
• Limited resources provided
• Two sections:
• Theory - short-answer questions
• Programming - programming questions
• To pass the exam hurdle, you must:
• score at least 18/45 (40%) on the final exam
• score at least 25% in the theory section of the exam
• score at least 25% in the programming section of the exam
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Special Consideration
• Have you been impacted by unforeseen adverse circumstances?
• Has it affected your ability to complete coursework?
• You can apply for special consideration via myUNSW
• Find out how to apply here:
https://student.unsw.edu.au/special-consideration
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assessment
Summary:
15% labs
10% quizzes
15% assignment 1
15% assignment 2
45% final exam
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Assessment
To pass COMP2521, you must:
• score at least 50/100 overall
• pass the exam hurdle
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Academic Integrity
• Labs, quizzes and assignments must be entirely your own work
• Plagiarism will be checked for and penalised
• Plagiarism may result in suspension from UNSW
• Scholarship students may lose their scholarship
• International students may lose their visa
• Supplying your work to any other person may result in loss of all your
marks for the lab/assignment
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Academic Integrity
Generative AI Tools
• Use of generative AI tools, e.g., GitHub Copilot, ChatGPT, with the
intention of generating answers/solutions for assessment tasks is not
permitted
• Use of generative AI tools for learning is permitted
• You must still be critical of any response you get from these tools
• Generative AI tools have great potential to assist coders, but use of them
requires good understanding of the language/system
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Resources
Additional Help
• Discourse forum
• Weekly consultations
• Starting from week 3
• Monday 1pm-2pm
• In person at K17 (room to be confirmed)
• For clarification of course content
• Help sessions
• Starting from week 2
• Schedule on course website
• For help with labs and assignments
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Resources
Additional Exercises
• Attempt lecture excercises by yourself using the startercode provided
• Practice exercises by topic: here
• Extra lab exercises
• LeetCode/HackerRank problems for more practice: here
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Expectations
What we expect from you
• Check your email regularly
• Announcements will be sent to your email
• Your tutor will send you emails
• Reminders of unsubmitted work will be sent to your email
• Read the spec before asking questions
• Don’t ask questions that are already answered in the spec
• Attempt to debug your program yourself before asking for help
• Debugging may involve adding print statements or using gdb to check the
state of the program at various points, or drawing diagrams to visualise
the program’s execution
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Expectations
What you can expect from us
• Regular announcements/updates
• Lecture slides released before lectures
• Minimal typos/mistakes in lecture slides
• Tutorial questions/lab exercises released on time (by the weekend
before)
• Assignments released on time
• Assignments marked on time
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Advice
• Keep up with lectures
Labs and quizzes require you to know content from recent lectures
• Attend tutorials, especially if you are falling behind
Tutors will not judge you for falling behind
• Always try to understand, instead of just memorise
Understanding something makes it easier to remember
Exam questions will be different from what you’ve seen
• Programming is a skill that improves with practice
The more you practice, the easier labs, assignments and the exam will be
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Advice
Engage, ask questions, go to consults, do practice exercises...
You can improve if you put in the effort!
COMP2521
25T2
Introduction
Outline
People
Teaching
Assessment
Resources
Resources
Expectations
Advice
Acknowledgements
Tools
Acknowledgements
COMP2521 material drawn from...
• slides by Jashank Jeremy (COMP2521 19T0)
• slides by Angela Finlayson (COMP2521 18x1)
• slides by John Shepherd (COMP1927 16s2)
• slides by Gabriele Keller (COMP1927 12s2)
• lectures by Richard Buckland (COMP1927 09s2)
• slides by Manuel Chakravarty (COMP1927 08s1)
• notes by Aleks Ignjatovic (COMP2011 ’05)
• slides and books by Robert Sedgewick
• Book Cormen, Thomas H.; Lieserson, Charles E.; Rivest, Ronald L.; Stein,
Clifford, Introduction to Algorithms (4th ed.). MIT Press and McGraw-Hill,
2022
• slides by Kevin Luxa (COMP2521 25T1)
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
The Tools of the Trade
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation

COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Compilation
clang
COMP2521 uses the clang compiler. Basic compilation command:
clang -Wall -Werror -g -o prog prog.c
• -Wallenables (almost) all warnings
• Catches many possible syntax errors
• -Werrorturns warnings into errors
• Prevents compilation if there are warnings
• -gpreserves information useful for debugging
• Line numbers, function and variable names, etc.
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
{Address, Leak, Memory, Thread, DataFlow,UndefinedBehavior}Sanitizer
a family of compiler plugins, developed by Google
which instrument executing code with sanity checks
use-after-free, array overruns, value overflows, uninitialised values, and more
you’ve been using ASan+UBSan already: dcc uses them!
usable on your own *nix systems (Linuxes, BSDs, ‘macOS’) too!
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer
• Detects invalid memory accesses, such as:
• Out-of-bounds array accesses
• Use-after-free errors
• Double-free errors
• …and many others
• To use AddressSanitizer, compile with -fsanitize=address
• Our Makefiles compile with AddressSanitizer by default
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer - Example
#include <stdio.h>
#define SIZE 5
int main(void) {
int arr[SIZE];
int i = 0;
while (scanf("%d", &arr[i]) == 1) {
i++;
}
...
}
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
AddressSanitizer - Example

COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
LeakSanitizer
• Detects memory leaks
• To use LeakSanitizer, compile with -fsanitize=leak
• Example of error that would be caught by LeakSanitizer:
#include <stdlib.h>
int main(void) {
int *a = malloc(sizeof(int));
*a = 42;
// free(a);
}
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
MemorySanitizer
• Detects uninitialized memory access
• To use MemorySanitizer, compile with -fsanitize=memory
• Example of error that would be caught by MemorySanitizer:
#include <stdio.h>
int main(void) {
int arr[10];
arr[0] = 42;
if (arr[1] == 0) {
printf("zero\n");
}
}
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
Sanitizers
UndefinedBehaviorSanitizer
• Detects wide range of undefined behaviours
• To use UndefinedBehaviorSanitizer, compile with
-fsanitize=undefined
• Example of error that would be caught by UndefinedBehaviorSanitizer:
#include <limits.h>
#include <stdio.h>
int main(void) {
int a = INT_MAX;
printf("%d\n", a + 1);
}
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
valgrind
• finding memory leaks
… not free’ing memory that you malloc’d
• finding memory errors
… illegally trying access memory
$ valgrind ./prog
...
==29601== HEAP SUMMARY:
==29601== in use at exit: 64 bytes in 1 blocks
==29601== total heap usage: 1 allocs, 0 frees, 64 bytes allocated
==29601==
==29601== LEAK SUMMARY:
==29601== definitely lost: 64 bytes in 1 blocks
Valgrind doesn’t play well with ASan. Compile without ASan if you want to use it.
COMP2521
25T2
Introduction
Tools
Compilation
Sanitizers
valgrind
make
make
Can’t be bothered typing long compilation commands?
make lets you specify
rules, dependencies, variables
in a Makefile
to define what a program needs to be compiled
With a Makefile, all you need to do to compile is to type
make


================================================================================

[2/24] week01lec01-recursion.pdf
--------------------------------

COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
COMP2521 25T2
Recursion
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion

COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Definition
Recursion is a problem solving strategy
where problems are solved via solving subproblems
(smaller or simpler instances of the same problem)
In programming, we solve problems recursively by
using functions that call themselves
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion
The Sierpinski triangle
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid

COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Iteratively
1
 2
3
 4
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Iteratively
To build a pyramid of width n:
• For each width w from n down to 1 (decrementing by 2 each time):
• Build a w × w layer of blocks on top
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
1
Build a 7 x 7 layer of blocks
2
Build a pyramid of width 5 on top!
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
What’s wrong with this method?
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
What’s wrong with this method?
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Building a Pyramid
Recursively
To build a pyramid of width n:
1 If n ≤ 0, do nothing
2 Otherwise:
1 Build an n × n layer
2 Then build a pyramid of width n − 2 on top
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
The factorial of n (where n ≥ 0)
denoted by n!
is the product of all positive integers
less than or equal to n.
n! =n × (n − 1) × (n − 2) × · · · ×2 × 1
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Iteratively
Iterative method:
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Observation:
n! =n × (n − 1) × (n − 2) × · · · ×2 × 1
= n × (n − 1)!
For example:
4! = 4× 3 × 2 × 1
= 4× 3!
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
return n * factorial(n - 1);
}
What’s wrong with this function?
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
return n * factorial(n - 1);
}
What’s wrong with this function?
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Recursively
Recursive method:
int factorial(int n) {
if (n == 0) {
return 1;
} else {
return n * factorial(n - 1);
}
}
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Factorial
Example:
factorial(3) = 3 * factorial(2)
= 3 * (2 * factorial(1))
= 3 * (2 * (1 * factorial(0)))
= 3 * (2 * (1 * 1))
= 3 * (2 * 1)
= 3 * 2
= 6
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
• A recursive function calls itself
• This is possible because there is a difference between a function and a
function call
• Each function call creates a new mini-environment, called a stack frame,
that holds all the local variables used by the function call
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Consider this program (no recursion):
int main(void) {
a(5);
}
void a(int val) {
b(val);
}
void b(int val) {
printf("%d\n", val);
}
This is how the state of the stack changes:
main() main()
a(5)
main()
a(5)
b(5)
main()
a(5)
main()
main calls a a calls b b returns a returns
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Now consider factorial(2):
int factorial(int n) {
if (n == 0) {
return 1;
} else {
return n * factorial(n - 1);
}
}
This is how the state of the stack changes:
fact(2) fact(2)
fact(1)
fact(2)
fact(1)
fact(0)
fact(2)
fact(1)
fact(2)
fact(2)
calls
fact(1)
fact(1)
calls
fact(0)
fact(0)
returns
1
fact(1)
returns
1 x 1 = 1
fact(2)
returns
2 x 1 = 2
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
When the function recurses, that is called “winding”
When recursive calls return, that is called “unwinding”
fact(4) fact(4)
fact(3)
fact(4)
fact(3)
fact(2)
fact(4)
fact(3)
fact(2)
fact(1)
fact(4)
fact(3)
fact(2)
fact(1)
fact(0)
fact(4)
fact(3)
fact(2)
fact(1)
fact(4)
fact(3)
fact(2)
fact(4)
fact(3)
fact(4)
winding unwinding
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How Recursion Works
Pre-order operations
Operations before the recursive call occur during winding.
Post-order operations
Operations after the recursive call occur during unwinding.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion on Linked Lists
Recall that recursion is
a problem solving strategy where problems are solved via
solving smaller or simpler instances of the same problem
How do we apply recursion to linked lists?
list 4 5 7
smaller linked list
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion on Linked Lists
Recall that recursion is
a problem solving strategy where problems are solved via
solving smaller or simpler instances of the same problem
How do we apply recursion to linked lists?
list 4 5 7
smaller linked list
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Example: summing values of a list
• Base case: empty list
• Sum of an empty list is zero
• Non-empty lists
• I can’t solve the whole problem directly
• But I do know the first value in the list
• And if I can sum the rest of the list (smaller than whole list)
• Then I can add the first value to the sum of the rest of the list, giving the
sum of the whole list
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Example:
listSum([3, 1, 4]) = 3 + listSum([1, 4])
= 3 + (1 + listSum([4]))
= 3 + (1 + (4 + listSum([])))
= 3 + (1 + (4 + 0))
= 3 + (1 + 4)
= 3 + 5
= 8
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - Summing a List
Recursive method:
struct node {
int value;
struct node *next;
};
int listSum(struct node *list) {
if (list == NULL) {
return 0;
} else {
return list->value + listSum(list->next);
}
}
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
How to Write a Recursive Function
First, think:
• How can the solution be expressed in terms of subproblems?
• What would the subproblem(s) be?
• How can you relate the original problem to the subproblem(s)?
• What are the base cases?
Then, implement:
• Implement base case(s) first
• Then implement recursive cases
• Each subproblem corresponds to a recursive call
• Assume that the function works for the subproblem(s)
• Like in Mathematical Induction!
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Exercises
Exercise 1:
• Given a linked list, print the items in the list in reverse.
Exercise 2:
• Given a linked list, print every second item.
Exercise 3:
• Given a linked list and an index, return the value at that index. Index 0
corresponds to the first value, index 1 the second value, and so on.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Example: append a value to a list
struct node *listAppend(struct node *list, int value) {
...
}
listAppendshould insert the given value at the end of the given list and
return a pointer to the start of the updated list.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
What’s wrong with this solution?
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
Consider this list…
myList
4
…and this function call:
listAppend(myList, 5);
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 listAppend(list->next, value);
6 return list;
7 }
8 }
The recursive call on line 5 creates a new node and returns it...
list
4 5
…but this new node is not attached to the list!
The node containing 4 still points to NULL.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Correct solution:
1 struct node *listAppend(struct node *list, int value) {
2 if (list == NULL) {
3 return newNode(value);
4 } else {
5 list->next = listAppend(list->next, value);
6 return list;
7 }
8 }
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
Why does this work?
list->next = listAppend(list->next, value);
Consider the following list:
list
4 rest of the list
Two cases to consider:
(1) The rest of the list is empty
(2) The rest of the list is not empty
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 1: The rest of the list is empty
list
4
5
In this case, listAppend(list->next, value)will return a new node
list->next = ... causes list->nextto point to this new node
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 …
5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 … 5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Example - List Append
list->next = listAppend(list->next, value);
Case 2: The rest of the list is not empty
list
4 … 5
In this case, listAppend(...) will append the value to the rest of the list
and return a pointer to the (start of the) rest of the list
list->next = ... causes list->nextto point to the start of the rest of
the list (which it was already pointing to)
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
More Exercises
Exercise 1:
• Given a linked list, return a copy of the linked list.
Exercise 2:
• Given a linked list and a value, delete the first instance of the value from
the list (if it exists), and return the updated list.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Sometimes, recursive solutions require recursive helper functions
• Data structure uses a “wrapper” struct
• Recursive function needs to take in extra information (e.g., state)
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
Wrapper struct for a linked list:
struct list
head
4 5 7 struct node {
int value;
struct node *next;
};
struct list {
struct node *head;
};
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
Example: Implement this function:
void listAppend(struct list *list, int value);
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
void listAppend(struct list *list, int value);
We can’t recurse with this function because our recursive function needs to
take in a struct nodepointer.
Solution: Use a recursive helper function!
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Wrapper structs
void listAppend(struct list *list, int value) {
list->head = doListAppend(list->head, value);
}
struct node *doListAppend(struct node *node, int value) {
if (node == NULL) {
return newNode(value);
} else {
node->next = doListAppend(node->next, value);
return node;
}
}
Our convention for naming recursive helper functions is to prepend “do” to
the name of the original function.
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Passing extra information
Problem:
• Print a linked list in a numbered list format, starting from 1.
void printNumberedList(struct node *list);
Example:
• Suppose the input list contains the following elements: [11, 9, 2023]
• We expect the following output:
1. 11
2. 9
3. 2023
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursive Helper Functions
Passing extra information
We need to keep track of the current number.
Solution:
• Use a recursive helper function that takes in an extra integer
void printNumberedList(struct node *list) {
doPrintNumberedList(list, 1);
}
void doPrintNumberedList(struct node *list, int num) {
if (list == NULL) return;
printf("%d. %d\n", num, list->value);
doPrintNumberedList(list->next, num + 1);
}
COMP2521
25T2
Definition
Example -
Pyramid
Example -
Factorial
How
Recursion
Works
Recursion on
Linked Lists
Example - List
Sum
How to Use
Recursion
Exercises
Example - List
Append
More
Exercises
Recursive
Helper
Functions
Recursion vs.
Iteration
Recursion vs. Iteration
• If there is a simple iterative solution, a recursive solution will
generally be slower
• Due to a stack frame needing to be created for each function call
• A recursive solution will generally use more memory than an iterative
solution


================================================================================

[3/24] week01lec02-analysis.pdf
-------------------------------

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
COMP2521 25T2
Analysis of Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Motivation
• Program efficiency is critical for many applications:
• Finance, robotics, games, database systems, ...
• We may want to compare programs to decide which one to use
• We may want to determine whether a program will be “fast enough”
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Program Efficiency
What determines how fast a program runs?
• The operating system?
• Compilers?
• Hardware?
• E.g., CPU, GPU, cache
• Load on the machine?
• Most important: the data structures and algorithms used
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Algorithm Efficiency
• The running time of an algorithm tends to be a function of input size
• Typically: larger input ⇒ longer running time
• Small inputs: fast running time , regardless of algorithm
• Larger inputs: slower, but how much slower?

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
What to Analyse?
• Best-case performance
• Not very useful
• Usually only occurs for specific types of input
• Average-case performance
• Difficult; need to know how the program is used
• Worst-case performance
• Most important; determines how long the program could possibly run
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Time Complexity
Time complexity is
the amount of time it takes to run an algorithm,
as a function of the input size
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Time Complexity
Example functions:
n2
6n
n log2 n
20 log2 n
input size
time
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Analysing Time Complexity
The time complexity of an algorithm can be analysed in two ways:
• Empirically: Measuring the time that a program implementing the
algorithm takes to run
• Theoretically: Counting the number of operations or “steps” performed
by the algorithm as a function of input size
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Searching
The search problem:
Given an array of size n and a value,
return the index containing the value if it exists,
otherwise return -1.
[0]
2
[1]
16
[2]
11
[3]
1
[4]
9
[5]
4
[6]
15
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
1 Write a program that implements the algorithm
2 Run the program with inputs of varying size and composition
3 Measure the running time of the algorithm
4 Plot the results
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
We can measure the running time of an algorithm using clock(3).
• The clock() function determines the amount of processor time used
since the start of the process.
#include <time.h>
clock_t start = clock();
// algorithm code here...
clock_t end = clock();
double seconds = (double)(end - start) / CLOCKS_PER_SEC;
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Absolute times will differ
between machines, between languages
…so we’re not interested in absolute time.
We are interested in the relative change
as the input size increases
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Which algorithm is more efficient?

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Timing Execution
Compare growth rates, not absolute times

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
Let’s empirically analyse the following search algorithm:
// Returns the index of the given value in the array
// if it exists, or -1 otherwise
int linearSearch(int arr[], int size, int val) {
for (int i = 0; i < size; i++) {
if (arr[i] == val) {
return i;
}
}
}
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
// Returns the index of the given value in the array if it exists,
// or -1 otherwise
int linearSearch(int arr[], int size, int val) {
for (int i = 0; i < size; i++) {
if (arr[i] == val) {
return i;
}
}
return -1;
}
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis
Sample results:
Input Size Running Time
1,000,000 0.002
10,000,000 0.023
100,000,000 0.240
200,000,000 0.471
300,000,000 0.702
400,000,000 0.942
500,000,000 1.196
1,000,000,000 2.384
The worst-case running time of linear search
grows linearly as the input size increases.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Empirical Analysis

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Measuring running
time
Demonstration
Limitations
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Limitations of Empirical Analysis
• Requires implementation of algorithm
• Different choice of input data ⇒ different results
• Choosing good inputs is extremely important
• Timing results affected by runtime environment
• E.g., load on the machine
• In order to compare two algorithms...
• Need “comparable” implementation of each algorithm
• Must use same inputs, same hardware, same O/S, same load
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Theoretical Analysis
• Uses high-level description of algorithm (pseudocode)
• Can use the code if it is implemented already
• Characterises running time as a function of input size
• Allows us to evaluate the efficiency of the algorithm
• Independent of the hardware/software environment
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Pseudocode
• Pseudocode is a plain language description of the steps in an algorithm
• Uses structural conventions of a regular programming language
• if statements, loops
• Omits language-specific details
• variable declarations
• allocating/freeing memory
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Pseudocode
Pseudocode for linear search:
linearSearch(A, val):
Input: array A of size n, value val
Output: index of val in A if it exists
-1 otherwise
for i from 0 up to n − 1:
if A[i] = val:
return i
return -1
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Primitive Operations
Every algorithm uses a core set of basic operations.
Examples:
• Assignment
• Indexing into an array
• Calling/returning from a function
• Evaluating an expression
• Increment/decrement
We call these operations primitive operations.
Assume that primitive operations take the same constant amount of time.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Example
How many primitive operations are performed by this line of code?
for (int i = 0; i < n; i++)
The assignment i = 0occurs 1 time
The comparison i < noccurs n + 1 times
The increment i++occurs n times
Total: 1 + ( n + 1) + n primitive operations
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Example
How many primitive operations are performed by this line of code?
for (int i = 0; i < n; i++)
The assignment i = 0occurs 1 time
The comparison i < noccurs n + 1 times
The increment i++occurs n times
Total: 1 + ( n + 1) + n primitive operations
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
By inspecting the pseudocode, we can determine the maximum number of
primitive operations executed by an algorithm as a function of the input size.
linearSearch(A, val):
Input: array A of size n, value val
Output: index of val in A if it exists
-1 otherwise
for i from 0 up to n − 1: 1 + (n + 1) + n
if A[i] = val: 2n
return i
return -1 1
---------------
4n + 3 (total)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Counting Primitive Operations
Linear search requires 4n + 3 primitive operations in the worst case.
If the time taken by a primitive operation is c, then the time taken by linear
search in the worst case is c(4n + 3).
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
We are mainly interested in
how the running time of an algorithm changes
as the input size increases.
This is called the asymptotic behaviour of the running time.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Lower-Order Terms
Asymptotic behaviour is not affected by lower-order terms.
• For example, suppose the running time of an algorithm is 4n + 100.
• As n increases, the lower-order term (i.e., 100) becomes less significant
(i.e., becomes a smaller proportion of the running time)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Constant Factors
Asymptotic behaviour is not affected by constant factors.
Example: Suppose the running time T (n) of an algorithm is n2.
• What happens when we double the input size?
T (2n) = (2 n)2
= 4 n2
= 4 T (n)
When we double the input size, the time taken quadruples.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
Constant Factors
Example: Now suppose the running time T (n) of an algorithm is 10n2.
• Now what happens when we double the input size?
T (2n) = 10 × (2n)2
= 10 × 4n2
= 4 × 10n2
= 4 T (n)
When we double the input size, the time taken also quadruples!
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
To summarise:
• Asymptotic behaviour is unaffected by lower-order terms
• Asymptotic behaviour is unaffected by constant factors
This means we can ignore lower-order terms and constant factors when
characterising the asymptotic behaviour of an algorithm.
Examples:
• If T (n) = 100 n + 500, ignoring lower-order terms and constant factors
gives n
• If T (n) = 5 n2 + 2n + 3, ignoring lower-order terms and constant factors
gives n2
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Asymptotic Analysis
This also means that for sufficiently large inputs, the algorithm that has the
running time with the highest-order term will always take longer.

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Big-Oh notation
is used to classify the asymptotic behaviour of an algorithm,
and this is how we usually express time complexity in this course.
For example, linear search is O(n) in the worst case.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Big-Oh notation allows us to easily compare the efficiency of algorithms
• For example, if algorithm A has a time complexity of O(n) and algorithm
B has a time complexity of O(n2), then we can say that for sufficiently
large inputs, algorithm A will perform better.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Big-Oh Notation
Formally, big-Oh is actually a notation used to describe the asymptotic
relationship between functions.
Formally:
Given functions f (n) and g(n), we say that f (n) is O(g(n)) if:
• There are positive constants c and n0 such that:
• f (n) ≤ c · g(n) for all n ≥ n0
Informally:
Given functions f (n) and g(n), we say that f (n) is O(g(n)) if for sufficiently
large n, f (n) is bounded above by some multiple of g(n).
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Relatives of Big-Oh
All The Mathematics!
f (n) is O(g(n))
if f (n) is asymptotically less than or equal to g(n)
f (n) is Ω(g(n))
if f (n) is asymptotically greater than or equal to g(n)
f (n) is Θ(g(n))
if f (n) is asymptotically equal to g(n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Analysing Complexity
Since time complexity is not affected by constant factors, instead of counting
primitive operations, we can simply count line executions.
linearSearch(A, value):
Input: array A of size n, value
Output: index of value in A if it exists
-1 otherwise
for i from 0 up to n − 1: n
if A[i] = value: n
return i
return -1 1
---------------
2n + 1 (total)
Worst-case time complexity: O(n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Analysing Complexity
To determine the worst-case time complexity of an algorithm:
• Determine the number of line executions performed in the worst case in
terms of the input size
• Discard lower-order terms and constant factors
• The worst-case time complexity is then the big-Oh of the term that
remains
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Common Functions
Commonly encountered functions in algorithm analysis:
• Constant: 1
• Logarithmic: log n
• Linear: n
• N-Log-N: n log n
• Quadratic: n2
• Cubic: n3
• Exponential: 2n
• Factorial: n!
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Pseudocode
Primitive operations
Asymptotic analysis
Big-Oh notation
Analysing complexity
Binary Search
Multiple
Variables
Appendix
Common Functions

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Back to Linear Search
Linear search requires 4n + 3 primitive operations in the worst case.
Therefore, linear search is O(n) in the worst case.
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Searching in a Sorted Array
Is there a faster algorithm for searching an array?
Yes... if the array is sorted.
[0]
1
[1]
2
[2]
4
[3]
9
[4]
11
[5]
15
[6]
16
Let’s start in the middle.
• If a[N /2] = val, we found val; we’re done!
• Otherwise, we split the array:
… if val < a[N /2], we search the left half ( a[0] to a[(N /2) − 1)])
… if val > a[N /2], we search the right half ( a[(N /2) + 1)] to a[N − 1])
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Binary search is a more efficient search algorithm for sorted arrays:
int binarySearch(int arr[], int size, int val) {
int lo = 0;
int hi = size - 1;
while (lo <= hi) {
int mid = (lo + hi) / 2;
if (val < arr[mid]) {
hi = mid - 1;
} else if (val > arr[mid]) {
lo = mid + 1;
} else {
return mid;
}
}
return -1;
}
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Example
Successful search for 6:
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
6 > 5
6 < 8
lo mid hi
lo mid hi
lo
mid
hi
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Example
Unsuccessful search for 7:
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
[0]
2
[1]
3
[2]
5
[3]
6
[4]
8
[5]
9
7 > 5
7 < 8
7 > 6
lo mid hi
lo mid hi
lo
mid
hi
lohi
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
Analysis
How many iterations of the loop?
• Best case: 1 iteration
• Item is found right away
• Worst case: log2 n iterations
• Item does not exist
• Every iteration, the size of the subarray being searched is halved
Thus, binary search is O(log2 n) or simply O(log n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
O(log n)
O(log2 n) = O(log n)
Why drop the base?
According to the change of base formula:
loga n = logb n
logb a
If a and b are constants,
loga n and logb n differ by a constant factor
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Binary Search
O(log n)
For example:
log2 n = log5 n
log5 2
≈ 2.32193 log5 n

COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
What if an algorithm takes multiple arrays as input?
If there is no constraint on the relative sizes of the arrays,
their sizes would be given as two variables, usually n and m
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example time complexities with two variables:
O(n + m)
O(nm)
O(max(n, m))
O(min(n, m))
O(n log m)
O(n log m + m log n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example
Problem:
Given two arrays, where each array contains no repeats,
find the number of elements in common
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Multiple Variables
Example
numCommonElements(A, B):
Input: array A of size n
array B of size m
Output: number of elements in common
numCommon = 0
for i from 0 up to n − 1:
for j from 0 up to m − 1:
if A[i] = B[j]:
numCommon = numCommon + 1
return numCommon
Time complexity: O(nm)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Appendix
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Predicting Time
If I know my algorithm is quadratic (i.e., O(n2)),
and I know that for a dataset of 1000 items,
it takes 1.2 seconds to run …
• how long for 2000?
4.8 seconds
• how long for 10,000?
120 seconds (2 mins)
• how long for 100,000?
12000 seconds (3.3 hours)
• how long for 1,000,000?
1200000 seconds (13.9 days)
(answers on the next slide)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Predicting Time
If I know my algorithm is quadratic (i.e., O(n2)),
and I know that for a dataset of 1000 items,
it takes 1.2 seconds to run …
• how long for 2000? 4.8 seconds
• how long for 10,000? 120 seconds (2 mins)
• how long for 100,000? 12000 seconds (3.3 hours)
• how long for 1,000,000? 1200000 seconds (13.9 days)
(answers on the next slide)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 1
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
for (int k = 1; k <= n; k++) {
// constant-time statement
}
}
}
Time complexity?
O(n3)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 1
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
for (int k = 1; k <= n; k++) {
// constant-time statement
}
}
}
Time complexity? O(n3)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 2
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= i; j++) {
// constant-time statement
}
}
Time complexity?
O(n2)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 2
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= i; j++) {
// constant-time statement
}
}
Time complexity? O(n2)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 3
for (int i = 1; i <= n; i = i * 2) {
// constant-time statement
}
Time complexity?
O(log n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 3
for (int i = 1; i <= n; i = i * 2) {
// constant-time statement
}
Time complexity? O(log n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 4
int p = 0;
for (int i = 1; p <= n; i++) {
p = p + i;
}
Time complexity?
O(√n)
COMP2521
25T2
Motivation
Efficiency
Time
Complexity
Searching
Empirical
Analysis
Theoretical
Analysis
Binary Search
Multiple
Variables
Appendix
Exercise
Analysis Examples
Analysis Examples
Example 4
int p = 0;
for (int i = 1; p <= n; i++) {
p = p + i;
}
Time complexity? O(√n)


================================================================================

[4/24] week02lec01-divide-and-conquer-sorts.pdf
-----------------------------------------------

COMP2521
25T2
Merge Sort
Quick Sort
Comparison
Summary COMP2521 25T2
Sorting Algorithms (III)
Divide-and-Conquer Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
merge sort
quick sort
COMP2521
25T2
Merge Sort
Quick Sort
Comparison
Summary
Divide-and-Conquer Algorithms
divide-and-conquer algorithms
split a problem into two or more subproblems,
solve the subproblems recursively,
and then combine the results.
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Invented by John von Neumann
in 1945

COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
A divide-and-conquer sorting algorithm:
split the array into two roughly equal-sized parts
recursively sort each of the partitions
merge the two now-sorted partitions into a sorted array
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
unsorted unsorted
mergesort mergesort
sorted sorted
merge
sorted
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort

COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Splitting
How do we split the array?
• We don’t physically split the array
• We simply calculate the midpoint of the array
• mid = (lo + hi) / 2
• Then recursively sort each half by passing in appropriate indices
• Sort between indices loand mid
• Sort between indices mid + 1and hi
• This means the time complexity of splitting the array is O(1)
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging
How do we merge two sorted subarrays?
• We merge the subarrays into a temporary array
• Keep track of the smallest element that has not been merged in each
subarray
• Copy the smaller of the two elements into the temporary array
• If the elements are equal, take from the left subarray
• Repeat until all elements have been merged
• Then copy from the temporary array back to the original array
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1
2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1
2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2
2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2
2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2
3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2
3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3
4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3
4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4
5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4
5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5
6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5
6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6
7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6
7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 1
2 4 5 7 1 2 3 6
When items are equal, merge takes from the left subarray
(this ensures stability) 
Now copy back to original array
1 2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2
5
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2
5
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging - Example 2
5 2
Now copy back to original array
2 5
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Merging
• The time complexity of merging two sorted subarrays is O(n), where n is
the total number of elements in both subarrays
• Therefore:
• Merging two subarrays of size 1 takes 2 “steps”
• Merging two subarrays of size 2 takes 4 “steps”
• Merging two subarrays of size 4 takes 8 “steps”
• …
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
C Implementation: Sort
void mergeSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
int mid = (lo + hi) / 2;
mergeSort(items, lo, mid);
mergeSort(items, mid + 1, hi);
merge(items, lo, mid, hi);
}
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
C Implementation: Merge
void merge(Item items[], int lo, int mid, int hi) {
Item *tmp = malloc((hi - lo + 1) * sizeof(Item));
int i = lo, j = mid + 1, k = 0;
// Scan both segments, copying to `tmp'.
while (i <= mid && j <= hi) {
if (le(items[i], items[j])) {
tmp[k++] = items[i++];
} else {
tmp[k++] = items[j++];
}
}
// Copy items from unfinished segment.
while (i <= mid) tmp[k++] = items[i++];
while (j <= hi) tmp[k++] = items[j++];
// Copy `tmp' back to main array.
for (i = lo, k = 0; i <= hi; i++, k++) {
items[i] = tmp[k];
}
free(tmp);
}
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Split
n − 1 splits
(log2 n levels
of splitting)
Merge
We have to merge
n numbers exactly
log2 n times
O(n)
O(n log n)
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Split
n − 1 splits
(log2 n levels
of splitting)
Merge
We have to merge
n numbers exactly
log2 n times
O(n)
O(n log n)
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis
Analysis:
• Merge sort splits the array into equal-sized partitions
halving at each level ⇒ log2 n levels
• The same operations happen at every recursive level
• Each ‘level’ requires ≤ n comparisons
Therefore:
• The time complexity of merge sort is O(n log n)
• Best-case, average-case, and worst-case time complexities are all the same
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Analysis - Alternative Method
Note: Not required knowledge in COMP2521!
Let T (n) be the time taken to sort n elements.
Splitting arrays into two halves takes constant time.
Merging two sorted arrays takes n steps.
So we have that:
T (n) = 2T (n/2) +n
Then the Master Theorem (see COMP3121) can be used to
show that the time complexity is O(n log n).
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort
Properties
Stable
Due to taking from left subarray if items are equal during merge
Non-adaptive
O(n log n) best case, average case, worst case
Not in-place
Merge uses a temporary array of size up to n
Note: Merge sort also uses O(log n) stack space
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Quick Sort
Comparison
Summary
Merge Sort on Lists
It is possible to apply merge sort on linked lists.
5 2 4 7 3 1 2 6
split
5 2 4 7
a
3 1 2 6
b
mergesort(a) mergesort(b)
2 4 5 7
a
1 2 3 6
b
merge(a, b)
1 2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
An approach that works non-recursively!
• On each pass, our array contains sorted runs of length m.
• Initially, n sorted runs of length 1.
• The first pass merges adjacent elements into runs of length 2.
• The second pass merges adjacent elements into runs of length 4.
• Continue until we have a single sorted run of length n.
Can be used for external sorting;
e.g., sorting disk-file contents
COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
Example

COMP2521
25T2
Merge Sort
Method
Splitting
Merging
Implementation
Analysis
Properties
Sorting Lists
Bottom-Up
Implementation
Quick Sort
Comparison
Summary
Bottom-Up Merge Sort
C Implementation
void mergeSortBottomUp(Item items[], int lo, int hi) {
for (int m = 1; m <= hi - lo; m *= 2) {
for (int i = lo; i <= hi - m; i += 2 * m) {
int end = min(i + 2 * m - 1, hi);
merge(items, i, i + m - 1, end);
}
}
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Invented by Tony Hoare
in 1959

COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Method:
1 Choose an item to be a pivot
2 Rearrange (partition) the array so that
• All elements to the left of the pivot are less than (or equal to) the pivot
• All elements to the right of the pivot are greater than (or equal to) the pivot
3 Recursively sort each of the partitions
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
x unsorted
partition
≤ x, unsorted x ≥ x, unsorted
quicksort quicksort
≤ x, sorted x ≥ x, sorted
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
How to partition an array?
• Assume the pivot is stored at index lo
• Create index lto start of array (lo + 1)
• Create index rto end of array (hi)
• Until land rmeet:
• Increment luntil a[l]is greater than pivot
• Decrement runtil a[r]is less than pivot
• Swap items at indices land r
• Swap the pivot with index lor l - 1(depending on the item at index l)
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2 7
2
3 6
14
1
6
2
7
5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3 6
14
1
6 2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the two elements
Increment left index while element is ≤ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elements
Increment left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1
2
7
2 3
6
1
4 1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1 2
7
2 3
61
4
1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 1
4
1 2
7
2 3
61
4
1
6
2
7 5
≤ 4 ≥ 4
Pivot is 4Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the two elementsIncrement left index while element is ≤ pivotSwap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1
Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivot
Decrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivot
Swap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Example 2
1 2 3 4 5
≥ 1
Pivot is 1Create left and right indices
Until the indices meet:
Increment left index while element is ≤ pivotDecrement right index while element is ≥ pivotSwap the pivot into the middle (be careful!)
Done
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Example 1
Example 2
Analysis
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Partitioning
Analysis
• Partitioning is O(n), where n is the number of elements being
partitioned
• About n comparisons are performed, at most n
2 swaps are performed
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
C Implementation: Sort
void naiveQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
int pivotIndex = partition(items, lo, hi);
naiveQuickSort(items, lo, pivotIndex - 1);
naiveQuickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
C Implementation: Partition
int partition(Item items[], int lo, int hi) {
Item pivot = items[lo];
int l = lo + 1;
int r = hi;
while (l < r) {
while (l < r && le(items[l], pivot)) l++;
while (l < r && ge(items[r], pivot)) r--;
if (l == r) break;
swap(items, l, r);
}
if (lt(pivot, items[l])) l--;
swap(items, lo, l);
return l;
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Best case: O(n log n)
• Choice of pivot gives two equal-sized partitions
• Same happens at every recursive call
• Resulting in log2 n recursive levels
• Each “level” requires approximately n comparisons
≤ x ≤x≥ ≥ x
recursively sort recursively sort
≤ y ≤y≥ ≥ y ≤ z ≤z≥ ≥ z
… … … …
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Worst case: O(n2)
• Always choose lowest/highest value for pivot
• Resulting in partitions of size 0 and n − 1
• Resulting in n recursive levels
• Each “level” requires one less comparison than the level above
x ≥ x
y ≥ y
z ≥ z
…
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Analysis
Average case: O(n log n)
• If array is randomly ordered, chance of repeatedly choosing a bad pivot
is very low
• Can also show empirically by generating random sequences and sorting
them
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort
Properties
Unstable
Due to long-range swaps
Non-adaptive
O(n log n) average case, sorted input does not improve this
In-place
Partitioning is done in-place
Stack depth is O(n) worst-case, O(log n) average
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Issues with Quick Sort
Choice of pivot can have a significant effect:
• Ideal pivot is the median value
• Always choosing largest/smallest ⇒ worst case
Therefore, always picking the first or last element as pivot is not a good idea:
• Existing order is a worst case
• Existing reverse order is a worst case
• Will result in partitions of size n − 1 and 0
• This pivot selection strategy is called naïve quick sort
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Take three values: left-most, middle, right-most.
Pick the median of these three values as our pivot.
Ordered data is no longer a worst-case scenario.
In general, doesn’t eliminate the worst-case …
… but makes it much less likely.
lo (lo + hi)/2 hi
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
lo (lo + hi)/2 hi
1 Sort a[lo], a[(lo + hi)/2], a[hi], such that a[(lo + hi)/2] ≤ a[lo] ≤ a[hi]
2 Partition on a[lo] to a[hi]
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?
Answer: 5
2
5
lo
3 7 8
2
(lo + hi)/2
1 4 6 5
8
hi
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?
Answer: 5
2
5
lo
3 7 8
2
(lo + hi)/2
1 4 6 5
8
hi
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
Example
Which element is selected as the pivot?Answer: 5
2
5
lo
3 7
8
2
(lo + hi)/2
1 4 6
5
8
hi
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Median-of-Three Partitioning
C Implementation
void medianOfThreeQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
medianOfThreeQuickSort(items, lo, pivotIndex - 1);
medianOfThreeQuickSort(items, pivotIndex + 1, hi);
}
void medianOfThree(Item a[], int lo, int hi) {
int mid = (lo + hi) / 2;
if (gt(a[mid], a[lo])) swap(a, mid, lo);
if (gt(a[lo], a[hi])) swap(a, lo, hi);
if (gt(a[mid], a[lo])) swap(a, mid, lo);
// now, we have a[mid] <= a[lo] <= a[hi]
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Randomised Partitioning
Idea: Pick a random value for the pivot
This makes it nearly impossible to
systematically generate inputs that would lead to
O(n2) performance
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort with Randomised Partitioning
C Implementation
void randomisedQuickSort(Item items[], int lo, int hi) {
if (lo >= hi) return;
swap(items, lo, randint(lo, hi));
int pivotIndex = partition(items, lo, hi);
randomisedQuickSort(items, lo, pivotIndex - 1);
randomisedQuickSort(items, pivotIndex + 1, hi);
}
int randint(int lo, int hi) {
int i = rand() % (hi - lo + 1);
return lo + i;
}
Note: rand()is a pseudo-random number generator provided by <stdlib.h>.
The generator should be initialised with srand().
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
For small sequences (when n < 5, say),
quick sort is expensive
because of the recursion overhead.
Solution: Handle small partitions with insertion sort
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
C Implementation - Version 1
#define THRESHOLD 5
void quickSort(Item items[], int lo, int hi) {
if (hi - lo < THRESHOLD) {
insertionSort(items, lo, hi);
return;
}
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
quickSort(items, lo, pivotIndex - 1);
quickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Insertion Sort
Sorting Lists
Comparison
Summary
Insertion Sort Improvement
C Implementation - Version 2
#define THRESHOLD 5
void quickSort(Item items[], int lo, int hi) {
doQuickSort(items, lo, hi);
insertionSort(items, lo, hi);
}
void doQuickSort(Item items[], int lo, int hi) {
if (hi - lo < THRESHOLD) return;
medianOfThree(items, lo, hi);
int pivotIndex = partition(items, lo, hi);
doQuickSort(items, lo, pivotIndex - 1);
doQuickSort(items, pivotIndex + 1, hi);
}
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort on Lists
It is possible to quick sort a linked list:
1 Pick first element as pivot
• Alternatively, can use median-of-three or random pivot
2 Create two empty linked lists A and B
3 For each element in original list (excluding pivot):
• If element is less than (or equal to) pivot, add it to A
• If element is greater than pivot, add it to B
4 Recursively sort A and B
5 Form sorted linked list using sorted A, the pivot, and then sorted B
COMP2521
25T2
Merge Sort
Quick Sort
Method
Partitioning
Implementation
Analysis
Properties
Issues
Median-of-Three
Partitioning
Randomised
Partitioning
Improvements
Sorting Lists
Comparison
Summary
Quick Sort on Lists
5 2 4 7 3 1 2 6
partition
5
pivot
2 4 3 1 2
a
7 6
b
quicksort(a) quicksort(b)
5
pivot
1 2 2 3 4
a
6 7
b
combine
1 2 2 3 4 5 6 7
COMP2521
25T2
Merge Sort
Quick Sort
Comparison
Summary
Quick Sort vs Merge Sort
Design of modern cpus mean,
for sorting arrays in ram
quick sort generally outperforms merge sort.
Quick sort is more ‘cache friendly’:
good locality of access on arrays.
On the other hand, merge sort is
readily stable, readily parallel,
a good choice for sorting linked lists
COMP2521
25T2
Merge Sort
Quick Sort
Comparison
Summary
Summary of Divide-and-Conquer Sorts
Time complexity Properties
Best Average Worst Stable Adaptive
Merge sort O(n log n) O(n log n) O(n log n) Yes No
Quick sort O(n log n) O(n log n) O(n2) No No


================================================================================

[5/24] week02lec01-elementary-sorts.pdf
---------------------------------------

COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
COMP2521 25T2
Sorting Algorithms (II)
Elementary Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
selection sort
bubble sort
insertion sort
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Method:
• Find the smallest element, swap it with the first element
• Find the second-smallest element, swap it with the second element
• …
• Find the second-largest element, swap it with the second-last element
Each iteration improves the “sortedness” of the array by one element.
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
Example
4 1 7 3 8 6 5 2
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Example
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 2 7 3 8 6 5 4
1 2 3 7 8 6 5 4
1 2 3 4 8 6 5 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 8 7
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
C Implementation
void selectionSort(Item items[], int lo, int hi) {
for (int i = lo; i < hi; i++) {
int min = i;
for (int j = i + 1; j <= hi; j++) {
if (lt(items[j], items[min])) {
min = j;
}
}
swap(items, i, min);
}
}
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Analysis
Cost analysis:
• In the first iteration, n − 1 comparisons, 1 swap
• In the second iteration, n − 2 comparisons, 1 swap
• …
• In the final iteration, 1 comparison, 1 swap
• C = (n − 1) + (n − 2) +. . .+ 1 =1
2 n(n − 1) ⇒ O(n2)
• S = n − 1
Cost is the same, regardless of the sortedness of the original array.
COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Properties
Selection sort is unstable
• Due to long-range swaps
• For example, sort these cards by value:

COMP2521
25T2
Selection Sort
Example
Implementation
Analysis
Properties
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Selection Sort
Properties
Unstable
Due to long-range swaps
Non-adaptive
Performs same steps, regardless of sortedness of original array
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Method:
• Make multiple passes from left ( lo) to right
• On each pass, swap any out-of-order adjacent pairs
• Elements “bubble up” until they meet a larger element
• Stop if there are no swaps during a pass
• This means the array is sorted
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Example
4 3 6 1 2 5
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
First pass
4 3 6 1 2 5
3 4 6 1 2 5
3 4 6 1 2 5
3 4 1 6 2 5
3 4 1 2 6 5
3 4 1 2 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Second pass
3 4 1 2 5 6
3 4 1 2 5 6
3 1 4 2 5 6
3 1 2 4 5 6
3 1 2 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Third pass
3 1 2 4 5 6
1 3 2 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Example
Fourth pass
1 2 3 4 5 6
1 2 3 4 5 6
No swaps made; stop
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
C Implementation
void bubbleSort(Item items[], int lo, int hi) {
for (int i = hi; i > lo; i--) {
bool swapped = false;
for (int j = lo; j < i; j++) {
if (gt(items[j], items[j + 1])) {
swap(items, j, j + 1);
swapped = true;
}
}
if (!swapped) break;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Best case: Array is sorted
• Only a single pass required
• n − 1 comparisons, no swaps
• Best-case time complexity: O(n)
1 2 3 4 5 6
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Worst case: Array is reverse-sorted
• n − 1 passes required
• First pass: n − 1 comparisons
• Second pass: n − 2 comparisons
• …
• Final pass: 1 comparison
• Total comparisons: (n − 1) + (n − 2) +. . .+ 1 =1
2 n(n − 1)
• Every comparison leads to a swap ⇒ 1
2 n(n − 1) swaps
• Worst-case time complexity: O(n2)
6 5 4 3 2 1
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Analysis
Average-case time complexity: O(n2)
• It can be proven that for a randomly ordered array, bubble sort needs to
perform 1
4 n(n − 1) swaps on average ⇒ O(n2)
• See appendix for details
• Can show empirically by generating random sequences and sorting them
COMP2521
25T2
Selection Sort
Bubble Sort
Example
Implmentation
Analysis
Properties
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble Sort
Properties
Stable
Comparisons are between adjacent elements only
Elements are only swapped if out of order
Adaptive
Bubble sort is O(n2) on average, O(n) if input array is sorted
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Method:
• Take first element and treat as sorted array (of length 1)
• Take next element and insert into sorted part of array so that order is
preserved
• This increases the length of the sorted part by one
• Repeat for remaining elements
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
Example
4 1 7 3 8 6 5 2
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Example
4 1 7 3 8 6 5 2
4 1 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 4 7 3 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 7 8 6 5 2
1 3 4 6 7 8 5 2
1 3 4 5 6 7 8 2
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
C Implementation
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Best case: Array is sorted
• Inserting each element requires one comparison
• n − 1 comparisons
• Best-case time complexity: O(n)
1 2 3 4 5 6 7 8
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Worst case: Array is reverse-sorted
• Inserting i-th element requires i comparisons
• Inserting index 1 element requires 1 comparison
• Inserting index 2 element requires 2 comparisons
• …
• Total comparisons: 1 + 2 +. . .+ (n − 1) =1
2 n(n − 1)
• Worst-case time complexity: O(n2)
8 7 6 5 4 3 2 1
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Analysis
Average-case time complexity: O(n2)
• Same reason as for bubble sort
• Can show empirically by generating random sequences and sorting them
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Example
Implementation
Analysis
Properties
Summary
Sorting Lists
Appendix
Insertion Sort
Properties
Stable
Elements are always inserted to the right of any equal elements
Adaptive
Insertion sort is O(n2) on average, O(n) if input array is sorted
In-place
Sorting is done within original array; does not use temporary arrays
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Summary of Elementary Sorts
Time complexity Properties
Best Average Worst Stable Adaptive
Selection sort O(n2) O(n2) O(n2) No No
Bubble sort O(n) O(n2) O(n2) Yes Yes
Insertion sort O(n) O(n2) O(n2) Yes Yes
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Aside: Sorting Linked Lists
Selection sort:
• Let L = original list, S = sorted list (initially empty)
• Repeat the following until L is empty:
• Find the node V containing the largest value in L, and unlink it
• Insert V at the front of S
Bubble sort:
• Traverse the list, comparing adjacent values
• If value in current node is greater than value in next node, swap values
• Repeat the above until no swaps required in one traversal
Insertion sort:
• Let L = original list, S = sorted list (initially empty)
• For each node in L:
• Insert the node into S in order
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Appendix
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Note: Not required knowledge in COMP2521!
New concept: inversion
An inversion is a pair of elements from a sequence where
the left element is greater than the right element.
For example, consider the following array:
4 2 1 5 3
The array contains 5 inversions:
(4, 2), (4, 1), (4, 3), (2, 1), (5, 3)
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Observation:
• In bubble sort, every swap reduces the number of inversions by 1
The goal of the proof: Show that the average number of inversions in a
randomly sorted array is O(n2).
• This implies the number of swaps required by bubble sort is O(n2) …
• Which implies that the average-case time complexity of bubble sort is
O(n2) or slower
• (but we know that it can’t be slower than O(n2) since the worst-case time
complexity of bubble sort is O(n2))
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
In a randomly sorted array:
• The minimum possible number of inversions is 0
(sorted array)
• The maximum possible number of inversions is 1
2 n(n − 1)
(reverse-sorted array)
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Let k be the number of inversions in a random permutation.
By reversing this permutation, one can obtain a permutation with
1
2 n(n − 1) − k inversions.
For example, suppose n = 5:
3 2 4 1 5
4 inversions
reverse 5 1 4 2 3
6 inversions
1 2 3 4 5
0 inversions
reverse 5 4 3 2 1
10 inversions
1 3 4 5 2
3 inversions
reverse
2 5 4 3 1
7 inversions
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Bubble Sort - Proof of O(n2) Average Case
Continued
Thus, if we take all the possible permutations of an array and pair each
permutation with its reverse, the total number of inversions in each pair is
1
2 n(n − 1).
This implies that the average number of inversions across all permutations is
1
4 n(n − 1), which is O(n2).
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
Sort the following array:
4 2 1 5 3
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
42
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
21
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item2
153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
43
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
jj
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
2
4
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
4
2
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i
i
i i i
j
j
j
j
j
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
2
1
53
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i
i
i i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
21
5
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5
item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j
j
jj
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
1
4
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i
i
i
j
j
j
jj
j j
j
j
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5 item
215
3
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5
item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}
COMP2521
25T2
Selection Sort
Bubble Sort
Insertion Sort
Summary
Sorting Lists
Appendix
Bubble sort average
case
Insertion sort
walkthrough
Insertion Sort Walkthrough
lo hi
i i i i
i
j
j
j
jj
j j
jj
[0]
42
1
[1]
24
2
[2]
14
3
[3]
5
4
[4]
3
5
item2153
void insertionSort(Item items[], int lo, int hi) {
for (int i = lo + 1; i <= hi; i++) {
Item item = items[i];
int j = i;
for (; j > lo && lt(item, items[j - 1]); j--) {
items[j] = items[j - 1];
}
items[j] = item;
}
}


================================================================================

[6/24] week02lec01-sorting-intro.pdf
------------------------------------

COMP2521
25T2
COMP2521 25T2
Sorting Algorithms (I)
Introduction to Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
sorting
properties of sorting algorithms
COMP2521
25T2 Motivation
• Sorting enables faster searching
• Binary search
• Sorting provides a useful intermediate for other algorithms
• For example, duplicate detection/removal, merging two collections
COMP2521
25T2 Sorting
• Sorting involves arranging a collection of items in order
• Arrays, linked lists, files
• Items are sorted based on some property (called the key), using an
ordering relation on that property
• Numbers are sorted numerically
• Strings are sorted alphabetically
COMP2521
25T2 Sorting
We sort arrays of Items, which could be:
• Simple values: int, char, double
• Aggregate values: strings
• Structured values: struct
The items are sorted based on a key, which could be:
• The entire item, if the item is a single value
• One or more fields, if the item is a struct
COMP2521
25T2 Sorting
Example: Each student has an ID and a name
5151515
John
5012345
Jane
3456789
Bob
5050505
Alice
5555555
John
5432109
Andrew
Sorting by ID (i.e., key is ID):
3456789
Bob
5012345
Jane
5050505
Alice
5151515
John
5432109
Andrew
5555555
John
Sorting by name (i.e., key is name):
5050505
Alice
5432109
Andrew
3456789
Bob
5012345
Jane
5151515
John
5555555
John
COMP2521
25T2 Sorting
Arrange items in array slice a[lo..hi]into sorted order:
a
lo hi
unordered
sort(a, lo, hi)
a
lo hi
ordered
To sort an entire array of size N, lo == 0and hi == N - 1.
COMP2521
25T2 Examples of Sorting Algorithms
Elementary sorting algorithms:
• Selection sort
• Bubble sort
• Insertion sort
• Shell sort
Divide-and-conquer sorting algorithms:
• Merge sort
• Quick sort
Non-comparison-based sorting algorithms:
• Radix sort
• Key-indexed counting sort
COMP2521
25T2 Analysis of Sorting Algorithms
Three main cases to consider for input order:
• Random order
• Sorted order
• Reverse-sorted order
When analysing sorting algorithms, we consider:
• n: the number of items ( hi− lo+ 1)
• C : the number of comparisons between items
• S: the number of times items are swapped
COMP2521
25T2 Properties of Sorting Algorithms
Properties:
• Stability
• Adaptability
• In-place
COMP2521
25T2 Properties of Sorting Algorithms
Stability
• A stable sort preserves the relative order of items with equal keys.
• Formally: For all pairs of items x and y where key(x) ≡ key(y), if x
precedes y in the original array, then x precedes y in the sorted array.
A stable sorting algorithm always performs a stable sort.
COMP2521
25T2 Properties of Sorting Algorithms
Stability
Example: Each card has a value and a suit
A stable sort on value: p

COMP2521
25T2 Properties of Sorting Algorithms
Stability
Example: Each card has a value and a suit
Example of an unstable sort on value:

COMP2521
25T2 Properties of Sorting Algorithms
Stability
When is stability important?
• When sorting the same array multiple times on different keys
• Some sorting algorithms rely on this, for example, radix sort
COMP2521
25T2 Properties of Sorting Algorithms
Stability
Example: Array of first names and last names
Alice
Wunder
Andrew
Bennett
Jake
Renzella
Alice
Hatter
Andrew
Taylor
John
Shepherd
Sort by last name:
Andrew
Bennett
Alice
Hatter
Jake
Renzella
John
Shepherd
Andrew
Taylor
Alice
Wunder
Then sort by first name (using stable sort):
Alice
Hatter
Alice
Wunder
Andrew
Bennett
Andrew
Taylor
Jake
Renzella
John
Shepherd
COMP2521
25T2 Properties of Sorting Algorithms
Stability
Stability doesn’t matter if...
• All items have unique keys
• Example: Sorting students by ID
• The key is the entire item
• Example: Sorting an array of integer values
COMP2521
25T2 Properties of Sorting Algorithms
Adaptability
• An adaptive sorting algorithm takes advantage of existing order in its
input
• The nature of the algorithm allows sorted or nearly-sorted inputs to be
sorted much quicker than other inputs
COMP2521
25T2 Properties of Sorting Algorithms
Adaptability
Warning!
Just because a sorting algorithm
sorts sorted input faster than it sorts random/reverse-sorted input,
does not mean that it is adaptive.
COMP2521
25T2 Properties of Sorting Algorithms
Adaptability
Example of data for non-adaptive sorting algorithm:

COMP2521
25T2 Properties of Sorting Algorithms
Adaptability
Example of data for adaptive sorting algorithm:

COMP2521
25T2 Properties of Sorting Algorithms
In-place
• An in-place sorting algorithm sorts the data within the original structure,
without using temporary arrays
COMP2521
25T2 Implementing Sorting Algorithms
Generic sort function:
void sort(Item a[], int lo, int hi);
Helper function to swap elements at indices iand j:
void swap(Item a[], int i, int j);
COMP2521
25T2 Implementing Sorting Algorithms
Itemis a typedef,
which is a way to give a new name to a type.
For example, if we want to sort integers:
typedef int Item;
For example, if we want to sort strings:
typedef char *Item;
COMP2521
25T2 Implementing Sorting Algorithms
We also define macros which indicate
(1) how to extract keys from an item, and
(2) how items should be compared.
For example, when sorting integers:
typedef int Item;
#define key(A) (A)
#define lt(A, B) (key(A) < key(B)) // less than
#define le(A, B) (key(A) <= key(B)) // less than or equal to
#define ge(A, B) (key(A) >= key(B)) // greater than or equal to
#define gt(A, B) (key(A) > key(B)) // greater than
COMP2521
25T2 Implementing Sorting Algorithms
When sorting structs:
typedef struct {
char *name;
char *course;
} Item;
#define key(A) (A.name)
#define lt(A, B) (strcmp(key(A), key(B)) < 0)
#define le(A, B) (strcmp(key(A), key(B)) <= 0)
#define ge(A, B) (strcmp(key(A), key(B)) >= 0)
#define gt(A, B) (strcmp(key(A), key(B)) > 0)


================================================================================

[7/24] week02lec02-non-comparison-sorts.pdf
-------------------------------------------

COMP2521
25T2
n log n Lower
Bound
Radix Sort
COMP2521 25T2
Sorting Algorithms (IV)
Non-Comparison-Based Sorting Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
n log n lower bound
radix sort
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
All of the sorting algorithms so far have been
comparison-based sorts.
It can be shown that these algorithms require Ω(n log n) comparisons.
That is, they require at least kn log n comparisons for some constant k.
Why?
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we need to sort 3 items.
Obviously, one comparison is not sufficient to sort them.
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we need to sort 3 items.
Even two comparisons are not sufficient to sort them. Why?
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
If we have 3 items, there are 3! = 6 ways to order them:
Assuming items are unique, one of these permutations is in sorted order.
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Suppose we performed the following comparisons:
<
<
Four combinations of results are possible:
(true, true), (true, false), (false, true), (false, false)
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
The two comparisons create four groups, and
each permutation of items belongs to one of these groups
true
true
true
false
false
true
false
false
<
<
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Mathematically,
If we have 3 items, then there are 3! = 6 ways to order them.
In other words, 6 possible permutations.
But if we only perform 2 comparisons, then there are only 22 = 4 groups,
so at least one group will contain more than one permutation.
We need at least 3 comparisons, because this creates 23 = 8 groups,
so each permutation can belong in its own group.
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
If we have n items, then there are n! permutations.
If we perform k comparisons, that creates up to 2k groups.
So given n items, we must perform enough comparisons k such that
2k ≥ n!
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
So given n items, we must perform enough comparisons k such that
2k ≥ n!
Taking the log2 of both sides gives
log2 2k ≥ log2 n!
Since log2 2k = k, we get
k ≥ log2 n!
Using Stirling’s approximation, we get
k ≥ n log2 n − n log2 e + O(log2 n)
Removing lower-order terms gives
k = Ω( n log2 n)
COMP2521
25T2
n log n Lower
Bound
Radix Sort
The n log n Lower Bound
Therefore:
The theoretical lower bound on
worst-case execution time
for comparison-based sorts is Ω(n log n).
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Non-Comparison-Based Sorting
If we aren’t limited to just comparing keys,
we can achieve better than O(n log n) worst-case time.
Non-comparison-based sorting algorithms exploit specific properties
of the data to sort it.
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Radix sort is a non-comparison-based sorting algorithm.
It requires us to be able to decompose our keys into individual symbols
(digits, characters, bits, etc.), for example:
• The key 372 is decomposed into (3, 7, 2)
• The key “sydney” is decomposed into (‘s’ , ‘y’ , ‘d’ , ‘n’ , ‘e’ , ‘y’)
Formally, each key k is decomposed into a tuple ( k1, k2, k3, …, km ).
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Ideally, the range of possible symbols is reasonably small, for example:
• Numeric: 0-9
• Alphabetic: a-z
The number of possible symbols is known as the radix, and is denoted by R.
• Numeric: R = 10 (for base 10)
• Alphabetic: R = 26
If the keys have different lengths, pad them with a suitable symbol, for
example:
• Numeric: 123, 015, 007
• Alphabetic: “ abc” , “zz␣” , “t␣␣”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Method:
• Perform stable sort on km
• Perform stable sort on km−1
• …
• Perform stable sort on k1
Example:

COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Pseudocode
radixSort(A):
Input: array A of keys where
each key consists of m symbols from an "alphabet"
initialise R buckets // one for each symbol
for i from m down to 1:
empty all buckets
for each key in A:
append key to bucket key[i]
clear A
for each bucket (in order):
for each key in bucket:
append key to A
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Assume alphabet is {‘ a’ , ‘b’ , ‘c’}, so R = 3 .
We want to sort the array:
[“abc” , “cab” , “baa” , “a” , “ca”]
First, pad keys with blank characters:
[“abc” , “cab” , “baa” , “a␣␣” , “ca␣”]
Each key contains three characters, so m = 3 .
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣ a b c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“abc” “cab” “baa” “a␣␣” “ca␣”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
“ca␣”
a
“baa”
b
“cab”
c
“abc”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣ a b c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣”
“baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa”
“cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab”
“abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣
“a␣␣”
a
“ca␣”
“baa”
“cab”
b
“abc”
c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ca␣” “baa” “cab” “abc”
Buckets:
␣ a b c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “ ca␣” “baa” “cab” “abc”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣”
“abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc”
“baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc”
“baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa”
“ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa”
“ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣”
“cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a
“a␣␣”
“abc”
b
“baa”
c
“ca␣”
“cab”
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Example
Array:
“a␣␣” “abc” “baa” “ca␣” “cab”
Buckets:
␣ a b c
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Analysis
Analysis:
• Array contains n keys
• Each key contains m symbols
• Radix sort uses R buckets
• A single stable sort runs in time O(n + R)
• Radix sort uses stable sort m times
Hence, time complexity for radix sort is O(m(n + R)).
• ≈ O(mn), assuming R is small
Therefore, radix sort performs better than comparison-based sorting
algorithms:
• When keys are short (i.e., m is small) and arrays are large (i.e., n is large)
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Radix Sort
Properties
Stable
All sub-sorts performed are stable
Non-adaptive
Same steps performed, regardless of sortedness
Not in-place
Uses O(R + n) additional space for buckets
and storing keys in buckets
COMP2521
25T2
n log n Lower
Bound
Radix Sort
Pseudocode
Example
Analysis
Properties
Other Non-Comparison-Based Sorts
• Bucket sort
• MSD Radix Sort
• The version shown was LSD
• Key-indexed counting sort
• …and others


================================================================================

[8/24] week03lec01-adts.pdf
---------------------------

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
COMP2521 25T2
Abstract Data Types
Sim Mautner
cs2521@cse.unsw.edu.au
abstraction
abstract data types
stacks and queues
sets
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Abstraction
is the process of
hiding or generalising
the details of an object or system
to focus on its high-level meaning or behaviour
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We drive a car by using a steering wheel and pedals

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We drive a car by using a steering wheel and pedals

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We operate a television through a remote control

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We operate a television through a remote control

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We deposit and withdraw money to/from our bank account via an ATM

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
We deposit and withdraw money to/from our bank account via an ATM

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
How many of these are examples of abstraction?
Using a computer
Executing a sorting program
Calling a function in C
Using an intin C
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
How many of these are examples of abstraction?
Using a computer
Executing a sorting program
Calling a function in C
Using an intin C
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Functions abstract away the steps of a computation
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
int res = factorial(5);
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Modern programming languages abstract away assembly code
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-0x14], edi
mov DWORD PTR [rbp-0x04], 0x1
mov DWORD PTR [rbp-0x08], 0x1
jmp 25 <fn+0x25>
mov eax, DWORD PTR [rbp-0x04]
imul eax, DWORD PTR [rbp-0x08]
mov DWORD PTR [rbp-0x04], eax
add DWORD PTR [rbp-0x08], 0x1
mov eax, DWORD PTR [rbp-0x08]
cmp eax, DWORD PTR [rbp-0x14]
jle 17 <fn+0x17>
mov eax, DWORD PTR [rbp-0x04]
pop rbp
ret
int factorial(int n) {
int res = 1;
for (int i = 1; i <= n; i++) {
res *= i;
}
return res;
}
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Abstraction
Examples
Assembly languages abstract away machine code
0000000000000000 <fn>:
0: 55 push rbp
1: 48 89 e5 mov rbp, rsp
4: 89 7d ec mov DWORD PTR [rbp-0x14], edi
7: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x04], 0x1
e: c7 45 f8 01 00 00 00 mov DWORD PTR [rbp-0x08], 0x1
15: eb 0e jmp 25 <fn+0x25>
17: 8b 45 fc mov eax, DWORD PTR [rbp-0x04]
1a: 0f af 45 f8 imul eax, DWORD PTR [rbp-0x08]
1e: 89 45 fc mov DWORD PTR [rbp-0x04], eax
21: 83 45 f8 01 add DWORD PTR [rbp-0x08], 0x1
25: 8b 45 f8 mov eax, DWORD PTR [rbp-0x08]
28: 3b 45 ec cmp eax, DWORD PTR [rbp-0x14]
2b: 7e ea jle 17 <fn+0x17>
2d: 8b 45 fc mov eax, DWORD PTR [rbp-0x04]
30: 5d pop rbp
31: c3 ret
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
An abstract data type…
is a conceptual model
that defines a set of operations for a data structure
without specifying how these operations are implemented
or how data is stored in memory.
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
An analogy...
Ordering from a restaurant...
The menu...
The kitchen...

COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
Example of an ADT: Stack
A stack is a linear collection of items
with two main operations:
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Example
User
push 8
push 3
push 7
pop
pop ⇒ 7
pop
pop ⇒ 3
push 1
Stack
8
3
7
1
Operations
push
adds an item to the top of the stack
pop
removes the item at the top of the stack
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Interface
The set of operations provided by an ADT is called the interface.
Users of an ADT only see and interact with the interface.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Interface
An ADT interface must:
1. clearly describe the behaviour of each operation
2. describe the conditions under which each operation can be used
Example:
pop
removes the item at
the top of the stack
assumes that the stack is not empty
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Implementation
Builders of an ADT provide an implementation of its operations.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
Implementation
create(...) {
...
}
destroy(...) {
...
}
push(...) {
...
}
pop(...) {
...
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types
Implementation
Users of an ADT do not see the implementation.
User
create
push 6
push 8
pop
...
Interface
create
destroy
push
pop
...
Implementation
create(...) {
...
}
destroy(...) {
...
}
push(...) {
...
}
pop(...) {
...
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
In C, abstract data types are implemented using two files:
a .h file that contains the interface
a .c file that contains the implementation
Stack.h
Interface
Stack.c
Implementation
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Interface — .hfile
The interface includes:
• forward declaration of the struct for the concrete representation
• via typedef struct t *T
• the struct is not defined in the interface
• function prototypes for all operations
• clear description of operations
• via comments
• a contract between the ADT and clients
• documentation describes how an operation can be used
• and what the expected result is as long as the operation is used correctly
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Interface — .hfile
Stack.h
typedef structstack *Stack;
/** Creates a new empty stack */
Stack StackNew(void);
/** Frees memory allocated to the stack */
void StackFree(Stack s);
/** Adds an item to the top of the stack */
void StackPush(Stack s, int item);
/** Removes the item at the top of the stack
Assumes that the stack is not empty */
int StackPop(Stack s);
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Implementation — .cfile
The implementation includes:
• concrete definition of the data structures
• definition of struct t
• function implementations for all operations
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Implementation — .cfile
Stack.c
struct stack {
...
};
Stack StackNew(void) {
...
}
void StackFree(Stack s) {
...
}
void StackPush(Stack s, int item) {
...
}
int StackPop(Stack s) {
...
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
User
A user of an ADT #includes the interface and uses the interface functions to
interact with the ADT.
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Users of an ADT only see and interact with the interface —
they do not see the implementation!
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
#include "Stack.h"
int main(void) {
Stack s = StackNew();
// this is not valid!
s->...
}
Stack.h
typedef struct stack *Stack;
...
Stack.c
struct stack {
...
};
This means users cannot access the concrete representation (struct) directly.
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
Users of an ADT only see and interact with the interface —
they do not see the implementation!
user.c
#include "Stack.h"
int main(void) {
Stack s = StackNew();
StackPush(s, 6);
StackPush(s, 8);
int item = StackPop(s);
...
}
#include "Stack.h"
int main(void) {
Stack s = StackNew();
// this is not valid!
s->...
}
Stack.h
typedef struct stack *Stack;
...
Stack.c
struct stack {
...
};
This means users cannot access the concrete representation (struct) directly.
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Abstract Data Types in C
COMP2521 Conventions
Naming conventions:
• ADTs are defined in files whose names start with an uppercase letter
• For example, for a Stack ADT:
• The interface is defined in Stack.h
• The implementation is defined in Stack.c
• ADT interface function names are in PascalCaseand begin with the
name of the ADT
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Creating/Using Abstract Data Types
1 Decide what operations you want to provide
• Operations to create, query, manipulate
• What are their inputs and outputs?
• What are the conditions under which they can be used (if any)?
2 Provide the function signatures and documentation for these operations
in a .hfile
3 The “developer” builds a concrete implementation for the ADT in a .cfile
4 The “user” #includes the interface in their program and uses the
provided functions
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Lists
Everything that we’ve just learned also applies to Lists - a Data Type you’re
familiar with from COMP1511.
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Lists
Signatures and Documentation
Function signatures and documentation for these operations in a .hfile:
Interface file for List ADT
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Lists
Concrete Implementation
Concrete implementation for the ADT in a .cfile:
... could be done in so many ways...
Summary of Some Possible Concrete Implementations of List ADT
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Lists
Using the Provided Functions
The “user” #includes the interface in their program and uses the provided
functions:
Test List Code
Demonstrate how to run the code with each of the different .cfiles.
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
What operations can you perform on a simple bank account?
• Open an account
• Check balance
• Deposit money
• Withdraw money
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
Interface (Account.h)
typedef struct account *Account;
/** Opens a new account with zero balance */
Account AccountOpen(void);
/** Closes an account */
void AccountClose(Account acc);
/** Returns account balance */
int AccountBalance(Account acc);
/** Withdraws money from account
Returns true if enough balance, false otherwise
Assumes amount is positive */
bool AccountWithdraw(Account acc, int amount);
/** Deposits money into account
Assumes amount is positive */
void AccountDeposit(Account acc, int amount);
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
User
int main(void) {
Account acc = AccountOpen();
printf("Balance: %d\n", AccountBalance(acc));
AccountDeposit(acc, 50);
printf("Balance: %d\n", AccountBalance(acc));
AccountWithdraw(acc, 20);
printf("Balance: %d\n", AccountBalance(acc));
AccountWithdraw(acc, 40);
printf("Balance: %d\n", AccountBalance(acc));
AccountClose(acc);
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Example - Bank Account
User
Invalid usage of an ADT (breaking abstraction):
int main(void) {
Account acc = AccountOpen();
acc->balance = 1000000;
// I'm a millionaire now, woohoo!
printf("Balance: %d\n", AccountBalance(acc));
AccountClose(acc);
}
COMP2521
25T2
Abstraction
ADTs
Example
Interface
Implementation
ADTs in C
Example - bank
account
Other examples
Stacks
Queues
Sets
Examples of ADTs
• Stack
• Queue
• Set
• Multiset
• Map
• Graph
• Priority Queue
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stacks
A stack is a collection of items,
such that the last item to enter
is the first item to leave:
Last In, First Out (lifo)
(Think stacks of books, plates, etc.)
• web browser history
• text editor undo/redo
• balanced bracket checking
• HTML tag matching
• rpn calculators
(…and programming languages!)
• function calls
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stacks
Operations
A stack supports the following operations:
push
add a new item to the top of the stack
pop
remove the topmost item from the stack
size
return the number of items on the stack
peek
get the topmost item on the stack without removing it
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
A Stack ADT can be used to check for balanced brackets.
Example of balanced brackets:
( [ { } ] )
Examples of unbalanced brackets!
( ) ) ) ( (
( [ { } ) ]
( [ ] ) ( [
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ] )
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
] ( [= ]
) (= )
eof is empty
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADTs
Example: Balancing Brackets
Sample input: ( [ { } ) ]
char stack check
-
( ( -
[ ( [ -
{ ( [ { -
} ( [ {= }
) ( [̸= )
fail!
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Queues
Sets
Stack ADT Interface
"Stack.h"
typedef struct stack *Stack;
/** Creates a new, empty Stack */
Stack StackNew(void);
/** Frees memory allocated for a Stack */
void StackFree(Stack s);
/** Adds an item to the top of a Stack */
void StackPush(Stack s, Item it);
/** Removes an item from the top of a Stack
Assumes that the Stack is not empty */
Item StackPop(Stack s);
/** Gets the number of items in a Stack */
int StackSize(Stack s);
/** Gets the item at the top of a Stack
Assumes that the Stack is not empty */
Item StackPeek(Stack s);
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
How to implement a stack?
array
linked list
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADTs
Array implementation
Dynamically allocate an array with an initial capacity
Fill the array sequentially — s[0], s[1], …
Maintain a counter of the number of items on the stack
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
4
6
7
3
struct stack
capacity 8
size 4
items
4 6 7 3
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
Example
Perform the following operations:
push(9), push(2), push(6), pop, pop, push(8)
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size 0
123212
items
9 28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
0
1
23212
items
9
28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
01
2
3212
items
9 2
8 6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
012
3
212
items
9 2
8
6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop
⇒ 2
push(8)
9
2
6
8
struct stack
capacity 8
size
0123
2
12
items
9 2
8 6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
capacity 8
size
01232
1
2
items
9
28 6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
capacity 8
size
012321
2
items
9
2
8
6
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Array implementation - Analysis
Cost of push:
• Inserting item at index sizeis O(1)
• What if array is full?
• If we double the size of the array with realloc(3) each time it is full, push
will still be O(1) on average
Cost of pop:
• Accessing item at index ( size - 1) is O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
Store items in a linked list
To push an item, insert it at the beginning of the list
To pop an item, remove it from the beginning of the list
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
4
6
7
3
struct stack
size 4
items
3 7 6 4
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
Example
Perform the following operations:
push(9), push(2), push(6), pop, pop, push(8)
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size 0
123212
items NULL
6 82 9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
0
1
23212
items
NULL
6 82
9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
01
2
3212
items
NULL
6 8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop
⇒ 6
pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
012
3
212
items
NULL
6
8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop
⇒ 2
push(8)
9
2
6
8
struct stack
size
0123
2
12
items
NULL
6 8
2 9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
size
01232
1
2
items
NULL
6 82
9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation
push(9) push(2) push(6) pop ⇒ 6 pop ⇒ 2 push(8)
9
2
6
8
struct stack
size
012321
2
items
NULL
6
8
2
9
Stack
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Example Usage
Interface
Implementation
Array
Linked list
Queues
Sets
Stack ADT
Linked list implementation - Analysis
Cost of push:
• Inserting at the beginning of a linked list is O(1)
Cost of pop:
• Removing from the beginning of a linked list is O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues
A queue is a collection of items,
such that the first item to enter
is the first item to leave:
First In, First Out (fifo)
(Think queues of people, etc.)
• waiting lists
• call centres
• access to shared resources
(e.g., printers)
• processes in a computer
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues

COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queues
Operations
A queue supports the following operations:
enqueue
add a new item to the end of the queue
dequeue
remove the item at the front of the queue
size
return the number of items in the queue
peek
get the frontmost item of the queue, without removing it
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Sets
Queue ADT Interface
"Queue.h"
typedef struct queue *Queue;
/** Create a new, empty Queue */
Queue QueueNew(void);
/** Free memory allocated to a Queue */
void QueueFree(Queue q);
/** Add an item to the end of a Queue */
void QueueEnqueue(Queue q, Item it);
/** Remove an item from the front of a Queue
Assumes that the Queue is not empty */
Item QueueDequeue(Queue q);
/** Get the number of items in a Queue */
int QueueSize(Queue q);
/** Get the item at the front of a Queue
Assumes that the Queue is not empty */
Item QueuePeek(Queue q);
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Implementation
How to implement a queue?
array
linked list (easier)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
To enqueue an item, insert it at the end of the list
To dequeue an item, remove it from the beginning of the list
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
What’s the problem with this design?
4
6
7
3
front
back
struct queue
size 4
items
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
Improved design
4
6
7
3
front
back
struct queue
size 4
back
front
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
Example
Perform the following operations:
enQ(9), enQ(2), enQ(6), deQ, deQ, enQ(8)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size 0
123212
back NULL
front NULL
9 2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
0
1
23212
back
NULL
front
NULL
9
2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
01
2
3212
back
NULL
front
NULL
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
012
3
212
back
NULL
front
NULL
9 2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
0123
2
12
back
NULL
front
NULL
9
2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
01232
1
2
back
NULL
front
NULL
9 2
6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
size
012321
2
back
NULL
front
NULL
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Linked list implementation - Analysis
Cost of enqueue:
• Inserting at the end of the linked list is O(1)
Cost of dequeue:
• Removing from the beginning of the linked list is O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
Dynamically allocate an array with an initial capacity
Maintain an index to the front of the queue
Maintain a counter of the number of items in the queue
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
4
6
7
3
front
back
struct queue
front 0
capacity 8
size 4
items
4 6 7 3
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
Example
Perform the following operations:
enQ(9), enQ(2), enQ(6), deQ, deQ, enQ(8)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size 0
123212
items
9 2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
0
1
23212
items
9
2 6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
01
2
3212
items
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ
⇒ 9
deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front 0
12
capacity 8
size
012
3
212
items
9 2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ
⇒ 2
enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
0
1
2
capacity 8
size
0123
2
12
items
9
2 6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
01
2
capacity 8
size
01232
1
2
items
9 2
6
8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation
enQ(9) enQ(2) enQ(6) deQ ⇒ 9 deQ ⇒ 2 enQ(8)
9
2
6
2
6
6
8
front
back
struct queue
front
01
2
capacity 8
size
012321
2
items
9 2
6 8
Queue
Conceptual
model Concrete representation
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Interface
Implementation
Linked list
Array
Sets
Queue ADT
Array implementation - Analysis
Cost of enqueue:
• Dequeue involves calculating insertion index
and inserting item at that index ⇒ O(1)
Cost of dequeue:
• Dequeue involves accessing item at index front⇒ O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Sets
A set is an unordered collection of distinct elements.
4 7
8
15
17
23 26
30
39
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Basic set operations:
• Create an empty set
• Insert an item into the set
• Delete an item from the set
• Check if an item is in the set
• Get the size of the set
• Display the set
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Interface
#include <stdbool.h>
typedef struct set *Set;
/** Creates a new empty set */
Set SetNew(void);
/** Free memory used by set */
void SetFree(Set set);
/** Inserts an item into the set */
void SetInsert(Set set, int item);
/** Deletes an item from the set */
void SetDelete(Set set, int item);
/** Checks if an item is in the set */
bool SetContains(Set set, int item);
/** Returns the size of the set */
int SetSize(Set set);
/** Displays the set */
void SetShow(Set set);
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set
Example Usage
Counting and displaying distinct numbers:
#include <stdio.h>
#include "Set.h"
int main(void) {
Set s = SetNew();
int val;
while (scanf("%d", &val) == 1) {
SetInsert(s, val);
}
printf("Number of distinct values: %d\n", SetSize(s));
printf("Values: ");
SetShow(s);
SetFree(s);
}
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Different ways to implement a set:
• Unordered array
• Ordered array
• Ordered linked list
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
struct set
capacity 8
size 5
elems
4 7 5 1 9
Set
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we check if an element exists?
• Perform linear scan of array ⇒ O(n)
bool SetContains(Set s, int elem) {
for (int i = 0; i < s->size; i++) {
if (s->elems[i] == elem) {
return true;
}
}
return false;
}
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we insert an element?
• If the element doesn’t exist, insert it after the last element
void SetInsert(Set s, int elem) {
if (SetContains(s, elem)) {
return;
}
if (s->size == s->capacity) {
// error message
}
s->elems[s->size] = elem;
s->size++;
}
Time complexity: O(n)
• SetContains is O(n) and inserting after the last element is O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Unordered array
How do we delete an element?
• If the element exists, overwrite it with the last element
void SetDelete(Set s, int elem) {
for (int i = 0; i < s->size; i++) {
if (s->elems[i] == elem) {
s->elems[i] = s->elems[s->size - 1];
s->size--;
return;
}
}
}
Time complexity: O(n)
• Finding the element is O(n), overwriting it with the last element is O(1)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
struct set
capacity 8
size 5
elems
1 4 5 7 9
Set
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we check if an element exists?
• Perform binary search ⇒ O(log n)
bool SetContains(Set s, int elem) {
int lo = 0;
int hi = s->size - 1;
while (lo <= hi) {
int mid = (lo + hi) / 2;
if (elem < s->elems[mid]) {
hi = mid - 1;
} else if (elem > s->elems[mid]) {
lo = mid + 1;
} else {
return true;
}
}
return false;
}
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1 4
2
5
4
7
5
9
7 9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1
42 5
4
7
5
9
7 9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we insert an element?
• Use binary search to find the index of the smallest element which is
greater than or equal to the new element
• If this element is equal to the new element, then it already exists, so no
need to do anything
• Otherwise, shift the element and everything greater than it up, and then
insert the new element at that index
Insert 2
1
4
2
5
4
7
5
9
7 9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
Time complexity of insertion?
• Binary search lets us find the insertion point in O(log n) time
• …but we still have to potentially shift up to n elements, which is O(n)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1 4
5
5
7
7
9
9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1 4
5
5
7
7
9
9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
How do we delete an element?
• Use binary search to find the element
• If the element exists, shift everything greater than it down
Delete 4
1
4
5
5
7
7
9
9
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered array
Time complexity of deletion?
• Binary search lets us find the element in O(log n) time
• …but we still have to potentially shift up to n − 1 elements, which is O(n)
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
struct set
size 3
elems
4 5 7
Set
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
How do we check if an element exists?
• Traverse the list ⇒ O(n)
bool SetContains(Set s, int elem) {
for (struct node *curr = s->elems; curr != NULL; curr = curr->next) {
if (curr->elem == elem) {
return true;
}
}
return false;
}
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Unordered array
Ordered array
Linked list
Summary
Set Implementation
Ordered linked list
We always have to traverse the list from the start. Therefore…
• Insertion and deletion are also O(n)
However, this analysis hides a crucial advantage of linked lists:
• Finding the insertion/deletion point is O(n)
• But inserting/deleting a node is O(1), as no shifting is required
COMP2521
25T2
Abstraction
ADTs
Stacks
Queues
Sets
Interface
Example Usage
Implementation
Summary
Set ADT Summary
Data Structure Contains Insert Delete
Unordered array O(n) O(n) O(n)
Ordered array O(log n) O(n) O(n)
Ordered linked list O(n) O(n) O(n)


================================================================================

[9/24] week03lec02-bsts.pdf
---------------------------

COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
COMP2521 25T2
Binary Search Trees
Sim Mautner
cs2521@cse.unsw.edu.au
trees
binary search trees
binary search tree operations
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees

COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
A tree is a hierarchical data structure
consisting of a set of connected nodes where:
Each node may have multiple other nodes as children
(depending on the type of tree)
Each node is connected to one parent except the root node
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - File System Tree
/
etc
hosts network
interfaces
bin home
andrewt
public_html
hsmith
public_html
index.html
webappdev
css html js
examples notes
lesson1.txt lesson2.txt
ts
jas
public_html
index.html
lib var
Source: https:/ /www.openbookproject.net/tutorials/getdown/unix/lesson2.html
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Abstract Syntax Tree
function decl
type: int(int)
name: fn
parameter list
parameter decl
type: int
name: n
statement list
if
==
variable
name: n
constant
value: 0
return
constant
value: 1
return
*
variable
name: n
function call
function
name: fn
argument list
-
variable
name: n
constant
value: 1
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Search Trees
5
2
1 4
7
9
13
3 23 25
2 6 8 9 14 20 24 29 30
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Decision Tree
Are you nervous?
Savings account.
Yes
Will you need to access most of the
money within the next 5 years?
Money market fund.
Yes
Are you willing to accept risks in
exchange for higher expected returns?
Stock portfolio.
Yes
Diversified portfolio with stocks,
bonds and short-term instruments.
No
No
No
Source: “Data Structures and Algorithms in Java” (6th ed) by Goodrich et al.
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Trees
Example - Decoding Morse Code
start
E
I
S
H
5 4
V
3
U
F A
2
A
R
L
W
P J
1
T
N
D
B
6
X
K
C Y
M
G
Z
7
Q
O
0
8
0
9 0
Dot Dash
COMP2521
25T2
Trees
Examples
Binary Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Trees
A binary tree is a tree where
each node can have up to two child nodes,
referred to as the left child and the right child.
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
A binary search tree is an ordered binary tree, where for each node :
• All values in the left subtree are less than the value in the node
• All values in the right subtree are greater than the value in the node
20
10
5
2
14
12 17
30
24
29
32
31
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Tree
Why?
We need a more efficient way to search and maintain large amounts of data.
We have already explored some approaches:
Ordered array Ordered linked list
Searching/finding the
insertion/deletion point O(log n) O(n)
Inserting/deleting
after finding the
insertion/deletion point
O(n) O(1)
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Why?
Binary search trees are efficient to search and maintain:
• Searching in a binary search tree is similar to how binary search works
• A binary search tree is a linked data structure (like a linked list), so there
is no need to shift elements when inserting/deleting
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Concrete Representation
Binary trees are typically represented by node structures
• Where each node contains a value and pointers to child nodes
struct node {
int item;
struct node *left;
struct node *right;
};
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Concrete Representation
4
2
1 3
6
5 7
4
2 6
1 3 5 7
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
The root node is the node with no parent node.
A leaf node is a node that has no child nodes.
An internal node is a node that has at least one child node.
4
2
1 3
8
6 9
leaf
root internal
node
internal
node
internal
node
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
Height of a tree: Maximum path length from the root node to a leaf
• The height of an empty tree is considered to be -1
• The height of the following tree is 3
5
2
1 3
4
8
6 9
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a tree with n nodes:
The maximum possible height is n − 1
1
2
3
…
n
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a tree with n nodes:
The minimum possible height is ⌊log2 n⌋
n minimum height = ⌊log2 n⌋ tree
1 0
2-3 1
4-7 2
… … …
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Terminology
For a given number of nodes, a tree is said to be
balanced if its height is minimal (or close to minimal), and
degenerate if its height is maximal (or close to maximal).
balanced degenerate
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations
Key operations on binary search trees:
• Insert
• Search
• Traverse
• Join
• Delete
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations - Analysis
The height h of a binary search tree
determines the efficiency of many operations,
so we will use both n and h in our analyses.
n = 20 h = 4
COMP2521
25T2
Trees
BSTs
Motivation
Representation
Terminology
Operations
Insertion
Search
Traversal
Join
Deletion
Exercises
Binary Search Trees
Operations - Recursion
Many BST operations can be implemented recursively.
A binary search tree is either:
• empty; or
• consists of a node with two subtrees
• ...which are also binary search trees
4
2
1 3
8
6 9
4’s left subtree 4’s right subtree
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Insertion
bstInsert(t, v)
Given a BST t and a value v,
insert v into the BST
and return the root of the updated BST
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Insertion is straightforward:
• Start at the root
• Compare value to be inserted with value in the node
• If value being inserted is less, descend to left child
• If value being inserted is greater, descend to right child
• Repeat until...
you have to go left/right but current node has no left/right child
• Create new node and attach to current node
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Method
Recursive method:
• t is empty
⇒ make a new node with v as the root of the new tree
• v < t->item
⇒ insert v into t’s left subtree
• v > t->item
⇒ insert v into t’s right subtree
• v = t->item
⇒ tree unchanged (assuming no duplicates)
exercise Try writing an iterative version.
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 1
Insert the following values into an empty tree:
4 2 6 5 1 7 3
4
2
1 3
6
5 7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 1
Insert the following values into an empty tree:
4 2 6 5 1 7 3
4
2
1 3
6
5 7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 2
Insert the following values into an empty tree:
5 6 2 3 4 7 1
5
2
1 3
4
6
7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 2
Insert the following values into an empty tree:
5 6 2 3 4 7 1
5
2
1 3
4
6
7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 3
Insert the following values into an empty tree:
1 2 3 4 5 6 7
1
2
3
4
5
6
7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Example 3
Insert the following values into an empty tree:
1 2 3 4 5 6 7
1
2
3
4
5
6
7
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Pseudocode
bstInsert(t, v):
Input: tree t, value v
Output: t with v inserted
if t is empty:
return new node containing v
else if v < t->item:
t->left = bstInsert(t->left, v)
else if v > t->item:
t->right = bstInsert(t->right, v)
return t
COMP2521
25T2
Trees
BSTs
Insertion
Method
Examples
Pseudocode
Analysis
Search
Traversal
Join
Deletion
Exercises
BST Insertion
Analysis
Analysis:
• At most one node is visited per level
• Number of operations performed per node is constant
• Therefore, the worst-case time complexity of insertion is O(h) where h is
the height of the BST
COMP2521
25T2
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Search
bstSearch(t, v)
Given a BST t and a value v,
return true if v is in the BST
and false otherwise
COMP2521
25T2
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Method
Recursive method:
• t is empty:
⇒ return false
• v < t->item
⇒ search for v in t’s left subtree
• v > t->item
⇒ search for v in t’s right subtree
• v = t->item
⇒ return true
exercise Try writing an iterative version.
COMP2521
25T2
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Example
Search for 4 and 7 in the following BST:
6
2
1 3
5
8
7 9
COMP2521
25T2
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Pseudocode
bstSearch(t, v):
Input: tree t, value v
Output: true if v is in t
false otherwise
if t is empty:
return false
else if v < t->item:
return bstSearch(t->left, v)
else if v > t->item:
return bstSearch(t->right, v)
else:
return true
COMP2521
25T2
Trees
BSTs
Insertion
Search
Method
Example
Pseudocode
Analysis
Traversal
Join
Deletion
Exercises
BST Search
Analysis
Analysis:
• At most one node is visited per level
• Number of operations performed per node is constant
• Therefore, the worst-case time complexity of search is O(h) where h is
the height of the BST
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Traversal
Given a BST,
visit every node of the tree
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
There are 4 common ways to traverse a binary tree:
1 Pre-order (NLR):
visit root, then traverse left subtree, then traverse right subtree
2 In-order (LNR):
traverse left subtree, then visit root, then traverse right subtree
3 Post-order (LRN):
traverse left subtree, then traverse right subtree, then visit root
4 Level-order:
visit root, then its children, then their children, and so on
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Pseudocode
Pseudocode:
preorder(t):
Input: tree t
if t is empty:
return
visit(t)
preorder(t->left)
preorder(t->right)
inorder(t):
Input: tree t
if t is empty:
return
inorder(t->left)
visit(t)
inorder(t->right)
postorder(t):
Input: tree t
if t is empty:
return
postorder(t->left)
postorder(t->right)
visit(t)
Note:
Level-order traversal is difficult to implement recursively.
It is typically implemented using a queue.
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Example: Binary Search Tree
20
10
5
2
14
12 17
30
24
29
32
31
Pre-order 20 10 5 2 14 12 17 30 24 29 32 31
In-order 2 5 10 12 14 17 20 24 29 30 31 32
Post-order 2 5 12 17 14 10 29 24 31 32 30 20
Level-order 20 10 30 5 14 24 32 2 12 17 29 31
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Example: Expression Tree
Expression tree for 1 * 3 + (5 * 7 - 9)
+
*
1 3
-
*
5 7
9
Pre-order + * 1 3 - * 5 7 9
In-order 1 * 3 + 5 * 7 - 9
Post-order 1 3 * 5 7 * 9 - +
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Applications
Pre-order traversal:
• Useful for reconstructing a tree
In-order traversal:
• Useful for traversing a BST in ascending order
Post-order traversal:
• Useful for evaluating an expression tree
• Useful for freeing a tree
Level-order traversal:
• Useful for printing a tree
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Pseudocode
Examples
Analysis
Join
Deletion
Exercises
Tree Traversal
Analysis
Analysis:
• Each node is visited once
• Hence, time complexity of tree traversal is O(n), where n is the number
of nodes
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Join
bstJoin(t1, t2)
Given two BSTs t1 and t2
where max (t1) < min (t2)
return a BST containing all items from t1 and t2
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Method
Method:
1 Find the minimum node min in t2
2 Replace min by its right subtree (if it exists)
3 Elevate min to be the new root of t1 and t2
t1 t2
join(t1, t2)
t1 t′
2
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Example 1
t1
10
5 14
t2
30
24
29
26
32
join(t1, t2)
24
10
5 14
30
29
26
32
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Example 2
t1
10
5 14
t2
24
29
30
32
join(t1, t2)
24
10
5 14
29
30
32
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Pseudocode
bstJoin(t1, t2):
Input: trees t1, t2
Output: t1 and t2 joined together
if t1 is empty:
return t2
else if t2 is empty:
return t1
else if t2->left is empty:
t2->left = t1
return t2
else:
curr = t2
parent = NULL
while curr->left ̸= NULL:
parent = curr
curr = curr->left
parent->left = curr->right
curr->left = t1
curr->right = t2
return curr
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Method
Examples
Pseudocode
Analysis
Deletion
Exercises
BST Join
Analysis
Analysis:
• The join algorithm simply finds the minimum node in t2
• Thus, at most one node is visited per level of t2
• Therefore, the worst-case time complexity of join is O(h2) where h2 is the
height of t2
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Deletion
bstDelete(t, v)
Given a BST t and a value v
delete v from the BST
and return the root of the updated BST
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Method
Recursive method:
• t is empty:
⇒ result is empty
• v < t->item
⇒ delete v from t’s left subtree
• v > t->item
⇒ delete v from t’s right subtree
• v = t->item
⇒ three sub-cases:
• t is a leaf
⇒ result is empty tree
• t has one subtree
⇒ replace with subtree
• t has two subtrees
⇒ join the two subtrees
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
If the node being deleted is a leaf, then the result is an empty tree
5 delete 5 NULL
9
4
1 6
15
11
12
18
delete 6
9
4
1
15
11
12
18
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
Node to be deleted has one subtree
9
4
1 6
5
15
11
12
18
delete 11
9
4
1 6
5
15
12 18
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Examples
Node to be deleted has two subtrees
9
4
1 6
15
11
12
18
delete 9
11
4
1 6
15
12 18
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Pseudocode
bstDelete(t, v):
Input: tree t, value v
Output: t with v deleted
if t is empty:
return empty tree
else if v < t->item:
t->left = bstDelete(t->left, v)
else if v > t->item:
t->right = bstDelete(t->right, v)
else:
if t->left is empty:
new = t->right
else if t->right is empty:
new = t->left
else:
new = bstJoin(t->left, t->right)
free(t)
t = new
return t
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Method
Examples
Pseudocode
Analysis
Exercises
BST Deletion
Analysis
Analysis:
• The deletion algorithm traverses down just one branch
• First, the item being deleted is found
• If the item exists and has two subtrees, its successor is found
• Thus, at most one node is visited per level
• Therefore, the worst-case time complexity of deletion is O(h) where h is
the height of the BST
COMP2521
25T2
Trees
BSTs
Insertion
Search
Traversal
Join
Deletion
Exercises
BST Exercises
• bstFree
free all nodes of a tree
• bstSize
return the size of a tree
• bstHeight
return the height of a tree
• bstPrune
given values lo and hi, remove all values outside the range [lo, hi]


================================================================================

[10/24] week04lec01-avl-trees.pdf
---------------------------------

COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
COMP2521 25T2
AVL Trees
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Invented by Georgy Adelson-Velsky and Evgenii Landis in 1962

COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Approach:
• Keep tree height-balanced
• Repair balance as soon as imbalance occurs
• During insertion or deletion
• Repairs are done locally, not by restructuring entire tree
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Height of an AVL tree
Since AVL trees are always height-balanced,
the height of an AVL tree is guaranteed to be at most
logφ (n + 1.1708) − 1.3277 (where φ is the golden ratio)
≈ 1.4404 log2(n + 1.1708) − 1.3277 =O(log n)
If you are interested in this:
https://github.com/COMP2521UNSW/gists/blob/main/height_of_
height-balanced_trees.pdf
(written by a former COMP2521 tutor)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
AVL Trees
Note:
AVL trees are not necessarily size-balanced.
For example, the following is a perfectly valid AVL tree:
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Method:
• Insert item recursively
• Check balance at each node along the insertion path in reverse
• i.e., from bottom to top
• Fix imbalances as they are found
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Example: Insert 5 into this tree
6
3
2
1 4
3
9
8
Balance must be checked at 4, then at 2, then at 6
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Example: Insert 5 into this tree
6
3
2
2
1 4
1
3 5
9
8
Balance must be checked at 4, then at 2, then at 6
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
How to check balance along insertion path in reverse?
• Perform balance checking as a postorder operation in the insertion
function
• In other words - add balance checking code below recursive calls
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Outline of insertion process:
1 if the tree is empty:
• return new node
2 insert recursively
3 check (and fix) balance
4 return root of updated tree
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Pseudocode
avlInsert(t, v):
Input: AVL tree t, item v
Output: t with v inserted
if t is empty:
return new node containing v
else if v < t->item:
t->left = avlInsert(t->left, v)
else if v > t->item:
t->right = avlInsert(t->right, v)
else:
return t
return avlRebalance(t)
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Pseudocode
avlRebalance(t):
Input: possibly unbalanced tree t
Output: balanced t
bal = balance(t)
if bal > 1:
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
return t
balance(t):
Input: tree t
Output: balance factor of t
return height(t->left) - height(t->right)
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
There are 4 rebalancing cases:
Left Left
Left Right
Right Left
Right Right
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
g Left Left g
bal = balance(t)
if bal > 1: (true)
if balance(t->left) < 0: (false)
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
1
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Left Right
bal = balance(t)
if bal > 1: (true)
if balance(t->left) < 0: (true)
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
2
1
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Right Left
bal = balance(t)
if bal > 1: (false)
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1: (true)
if balance(t->right) > 0: (true)
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
2
1
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing
Right Right
bal = balance(t)
if bal > 1: (false)
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1: (true)
if balance(t->right) > 0: (false)
t->right = rotateRight(t->right)
t = rotateLeft(t)
t
1
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
Insert 7 into this tree:
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
6 3
2 2
1 0 5 1
3 0
9 2
8 1
7 0
Check for balance at 8, then at 9, then at 6.
9 is unbalanced.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 1 - Left Left
6 3
2 2
1 0 5 1
3 0
9 2
8 1
7 0
6 3
2 2
1 0 5 1
3 0
8 1
7 0 9 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
Insert 4 into this tree:
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
6 4
2 3
1 0 5 2
3 1
4 0
9 1
8 0
Check for balance at 3, then at 5, then at 2, then at 6.
5 is unbalanced.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Rebalancing Example 2 - Left Right
6 4
2 3
1 0 5 2
3 1
4 0
9 1
8 0
1
2
6 3
2 2
1 0 4 1
3 0 5 0
9 1
8 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
AVL tree insertion requires balance checking
at each node on the insertion path…
…which requires the height of many subtrees to be computed
In an ordinary binary search tree, computing the height is O(n)!
(need to traverse whole (sub)tree)
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
Solution:
For each node, store the height of its subtree in the node itself:
struct node {
int item;
struct node *left;
struct node *right;
int height;
};
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Storing Height Data
Height of each node’s subtree is stored in the node itself
6 3
2 2
1 0 5 1
3 0
9 1
8 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data
When does height data need to be maintained?
• Whenever a node is inserted
• Heights of all ancestors may be affected
• Whenever a rotation is performed
• Heights of original root and new root may be affected
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
Whenever a node is inserted…
…heights of all ancestors may be affected
Example: Insert 4 into this tree
6 2
2 1
1 0 5 0
9 1
8 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 ?
4 0
9 1
8 0
Recompute height of each ancestor (from bottom to top)
using the heights stored in its children.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 ?
4 0
9 1
8 0
The heights of 5’s children are 0 and -1 (empty tree).
Thus, the height of 5 is max(0, −1) + 1 = 1.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 ?
1 0 5 1
4 0
9 1
8 0
The heights of 2’s children are 0 and 1.
Thus, the height of 2 is max(0, 1) + 1 = 2.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 ?
2 2
1 0 5 1
4 0
9 1
8 0
The heights of 6’s children are 2 and 1.
Thus, the height of 6 is max(2, 1) + 1 = 3.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Insertions
6 3
2 2
1 0 5 1
4 0
9 1
8 0
Done.
Note that recomputing the height of each node was done in O(1) time.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
Whenever a rotation is performed…
…heights of original root and new root may be affected
n1
n2
A B
C ⇌
n2
A n1
B C
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
Example: Perform a right rotation at 7
7 3
4 2
2 1
1 0
6 0
9 0
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 ?
6 0 9 0
Recompute height of original root
then recompute height of new root
using the heights stored in their children.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 ?
6 0 9 0
The height of 7’s children are 0 and 0.
Thus, the height of 7 is max(0, 0) + 1 = 1.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 ?
2 1
1 0
7 1
6 0 9 0
The height of 4’s children are 1 and 1.
Thus, the height of 4 is max(1, 1) + 1 = 2.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Maintaining Height Data - Rotations
4 2
2 1
1 0
7 1
6 0 9 0
Done.
Every rotation, two height updates are performed, each in O(1) time.
COMP2521
25T2
AVL Trees
Insertion
Pseudocode
Rebalancing
Height data
Analysis
Search
Deletion
Summary
AVL Tree Insertion
Analysis
Analysis:
• Height of an AVL tree is O(log n)
• In the worst case, length of insertion path is O(log n)
• Have to maintain height data and check/fix balance at each node on
insertion path
• This is O(1) per node
• Therefore, worst-case time complexity of AVL tree insertion is O(log n)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
AVL Tree Search
Exactly the same as for regular BSTs.
Worst-case time complexity is O(log n),
since AVL trees are height-balanced.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Method:
• Delete item recursively
• Check balance at each node along the deletion path ∗ in reverse
• Fix imbalances as they are found
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 10 from this tree
13
2
6
3
2
10
9
15
18
Balance must be checked at 6, then at 13
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 10 from this tree
13
2
6
1
3
2
9
15
18
Balance must be checked at 6, then at 13
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Important:
If the item being deleted has two child nodes,
the deletion path includes the path to its successor
(the smallest value in its right subtree)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 13 from this tree
13
3
8
3
5
11
23
17
15
16
22
25
28
, 13 will be replaced by 15 (its in-order successor) ,
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Example: Delete 13 from this tree
15
3
8
3
5
11
23
2
17
1
16
16
22
25
28
(y Balance must be checked at 17, then at 23, then at 15 y)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Pseudocode
avlDelete(t, v):
Input: AVL tree t, item v
Output: t with v deleted
if t is empty:
return empty tree
else if v < t->item:
t->left = avlDelete(t->left, v)
else if v > t->item:
t->right = avlDelete(t->right, v)
else:
if t->left is empty:
temp = t->right
free(t)
return temp
else if t->right is empty:
temp = t->left
free(t)
return temp
else:
successor = minimum value in t->right
t->item = successor
t->right = avlDelete(t->right, successor)
return avlRebalance(t)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Pseudocode
Note: This is the same as in AVL tree insertion
avlRebalance(t):
Input: possibly unbalanced tree t
Output: balanced t
bal = balance(t)
if bal > 1:
if balance(t->left) < 0:
t->left = rotateLeft(t->left)
t = rotateRight(t)
else if bal < -1:
if balance(t->right) > 0:
t->right = rotateRight(t->right)
t = rotateLeft(t)
return t
balance(t):
Input: tree t
Output: balance factor of t
return height(t->left) - height(t->right)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing
AVL tree deletion
has the same rebalancing cases
as AVL tree insertion.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
Delete 2 from this tree:
9 4
5 2
2 1
3 0
7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
9 4
5 1
3 0 7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
Check for balance at 5 and 9
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
9 4
5 1
3 0 7 0
16 3
12 2
11 0 13 1
15 0
17 1
20 0
1
2
9 is unbalanced
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 1 - Right Left
12 3
9 2
5 1
3 0 7 0
11 0
16 2
13 1
15 0
17 1
20 0
Balanced
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
Delete 8 from this tree:
8 4
3 2
1 0 6 1
4 0
13 3
9 1
10 0
17 2
15 1
14 0
18 1
20 0
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
13 3
10 0 17 2
15 1
14 0
18 1
20 0
Check for balance at 13 and 9
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
13 3
10 0 17 2
15 1
14 0
18 1
20 0
13 is unbalanced
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Examples
Height data
Analysis
Summary
AVL Tree Deletion
Rebalancing Example 2 - Right Right
9 4
3 2
1 0 6 1
4 0
17 3
13 2
10 0 15 1
14 0
18 1
20 0
Balanced
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data
Height data also needs to be maintained…
• Whenever a node is deleted
• Heights of all nodes on deletion path may be affected
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
Example: Delete 6 from this tree
19 4
6 3
5 1
1 0
16 2
11 1
12 0
17 0
25 2
23 0 28 1
29 0
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 ?
12 0 17 0
25 2
23 0 28 1
29 0
Recompute height of each node on the deletion path
using the heights stored in its children.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 ?
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 16’s children are 0 and 0.
Thus, the height of 16 is max(0, 0) + 1 = 1.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 ?
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 11’s children are 1 and 1.
Thus, the height of 11 is max(1, 1) + 1 = 2.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 ?
11 2
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
The heights of 19’s children are 2 and 2.
Thus, the height of 19 is max(2, 2) + 1 = 3.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Maintenance
Analysis
Summary
AVL Tree Deletion
Maintaining Height Data - Deletions
19 3
11 2
5 1
1 0
16 1
12 0 17 0
25 2
23 0 28 1
29 0
Done.
Note that recomputing the height of each node was done in O(1) time.
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Pseudocode
Rebalancing
Height data
Analysis
Summary
AVL Tree Deletion
Analysis
Analysis:
• Height of an AVL tree is O(log n)
• In the worst case, length of deletion path is O(log n)
• Have to maintain height data and check/fix balance at each node on
deletion path
• This is O(1) per node
• Therefore, worst-case time complexity of AVL tree deletion is O(log n)
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
Summary
• AVL trees are always height-balanced
• This means the height of an AVL tree is O(log n)
• Rotations are used to fix imbalances during insertion and deletion
• Balance is checked efficiently by storing height data in each node, which
needs to be maintained
• Worst-case time complexity of O(log n) for insertion, search and deletion
COMP2521
25T2
AVL Trees
Insertion
Search
Deletion
Summary
Set ADT Implementations
We now have a new data structure for implementing the Set ADT.
Data Structure Contains Insert Delete
Unordered array O(n) O(n) O(n)
Ordered array O(log n) O(n) O(n)
Ordered linked list O(n) O(n) O(n)
AVL tree O(log n) O(log n) O(log n)


================================================================================

[11/24] week04lec01-balancing-bsts.pdf
--------------------------------------

COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
COMP2521 25T2
Balancing Binary Search Trees
Sim Mautner
cs2521@cse.unsw.edu.au
balancing operations
balancing methods
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Recap
Height of a tree: Maximum path length from the root node to a leaf
• The height of an empty tree is considered to be -1
• The height of the following tree is 3
5
2
1 3
4
8
6 9
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The structure, height, and hence
performance
of a binary search tree
depends on the order of insertion.
5
3
1 4
7
9
1
3
4
5
7
9
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The Best Case
Best case
Items are inserted evenly on the left and right throughout the tree
Height of tree will be O(log n)
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
The Worst Case
Worst case
Items are inserted in ascending or descending order
such that tree consists of a single branch
Height of tree will be O(n)
…
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Binary Search Trees
A binary tree of n nodes is said to be
balanced if its height is minimal (or close to minimal) ( O(log n)), and
degenerate if it its height is maximal (or close to maximal) ( O(n)).
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
size-balanced
a size-balanced tree has,
for every node,
|size (l) − size (r)| ≤ 1
height-balanced
a height-balanced tree has,
for every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
3
5
6
5
2 2
1 1
2
1 1
0 0
Size-balanced?
Yes
For every node,
|size (l) − size (r)| ≤ 1
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
2
1 3
5
5
3 1
1 1
2
1 0
0 0
Size-balanced?
No
At node 4,
|size (l) − size (r)|
= |3 − 1| = 2> 1
||
Height-balanced?
Yes
For every node,
|height (l) − height (r)| ≤ 1
||
||
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T2
BSTs Recap
Balance
Examples
Balancing
Operations
Balancing
Methods
Types of Balance
Example
4
3
2
1
5
6
6
3 2
2 1
1
3
2 1
1 0
0
Size-balanced?
No
At node 3,
|size (l) − size (r)|
= |2 − 0| = 2> 1
Height-balanced?
No
At node 3,
|height (l) − height (r)|
= |1 − (−1)| = 2> 1
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Balancing
Methods
Balancing Operations
Rotation
• Left rotation
• Right rotation
Partition
• Rearrange tree around a specified node by rotating it up to the root
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
left rotation and right rotation:
a pair of operations
that change the balance of a tree
n1
n2
t1 t2
t3
Right rotation
Left rotation
n2
t1
n1
t2 t3
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Rotations maintain the order of a search tree:
n1
n2
t1 t2
t3
Right rotation
Left rotation
n2
t1
n1
t2 t3
(all values in t1) < n2 < (all values in t2) < n1 < (all values in t3)
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 5
5
3
2 4
6
3
2 5
4 6
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 5
5
3
2 4
6
3
2 5
4 6
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate left at 3
3
2 5
4 6
5
3
2 4
6
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate left at 3
3
2 5
4 6
5
3
2 4
6
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 23
23
7
3 16
11
10
20
30
28 35
7
3 23
16
11
10
20
30
28 35
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Example
Rotate right at 23
23
7
3 16
11
10
20
30
28 35
7
3 23
16
11
10
20
30
28 35
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
struct node *rotateLeft(struct node *root) {
if (root == NULL || root->right == NULL) return root;
struct node *newRoot = root->right;
root->right = newRoot->left;
newRoot->left = root;
return newRoot;
}
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Implementation
struct node *rotateRight(struct node *root) {
if (root == NULL || root->left == NULL) return root;
struct node *newRoot = root->left;
root->left = newRoot->right;
newRoot->right = root;
return newRoot;
}
7
4 9
1 5
root
newRoot
4
1 7
5 9
newRoot
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Examples
Implementation
Analysis
Partition
Balancing
Methods
Rotations
Analysis
Time complexity: O(1)
• Rotation requires only a few localised pointer re-arrangements
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
partition(tree, i)
Rearrange the tree so that the element with index i becomes the root
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
6
[3]
10
[5]
17
[8]
16
[7]
20
[10]
19
[9]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Method:
• Find element with index i
• Perform rotations to lift it to the root
• If it is the left child of its parent, perform right rotation at its parent
• If it is the right child of its parent, perform left rotation at its parent
• Repeat until it is at the root of the tree
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
Partition this tree around index 3:
10
[1]
5
[0]
14
[2]
30
[4]
29
[3]
32
[5]
3
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
Partition this tree around index 3:
10
[1]
5
[0]
14
[2]
30
[4]
29
[3]
32
[5]
1
2
3
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After right rotation at 30:
10
5 14
29
30
32
2
3
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After left rotation at 14:
10
5 29
14 30
32
3
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Example
After left rotation at 10:
29
10
5 14
30
32
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode
partition(t, i):
Input: tree t, index i
Output: tree with i-th item moved to root
leftSize = size(t->left)
if i < leftSize:
t->left = partition(t->left, i)
t = rotateRight(t)
else if i > leftSize:
t->right = partition(t->right, i - leftSize - 1)
t = rotateLeft(t)
return t
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Partition this tree around index 4
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 6, and 4 < 6...
so partition left subtree around index 4
and then rotate right at 13
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 6, and 4 < 6...
so partition left subtree around index 4
and then rotate right at 13
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 2, and 4 > 2...
so partition right subtree around index (4 - 2 - 1 = 1)
and then rotate left at 5
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 2, and 4 > 2...
so partition right subtree around index (4 - 2 - 1 = 1)
and then rotate left at 5
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
7
[3]
10
[5]
17
[8]
16
[7]
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 1, and 1 = 1...
so we have found the desired node
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Size of left subtree is 1, and 1 = 1...
so we have found the desired node
13
[6]
5
[2]
3
[1]
1
[0]
8
[4]
[1]7
[3]
[0]
10
[5]
[2]
17
[8]
16
[7]
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Unwinding...
Rotate left at 5
13
5
3
1
8
7 10
17
16
2
1
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Unwinding...
Rotate right at 13
13
8
5
3
1
7
10
17
16
2
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Pseudocode - Example
Done
8
5
3
1
7
13
10 17
16
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Analysis
Analysis:
• size() operation is expensive
• Can cause partition to be O(n2) in the worst case
• For example, in the following tree:
n
n-1
n-2
…
2
1
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Rotations
Partition
Example
Pseudocode
Analysis
Balancing
Methods
Partition
Analysis
Analysis (continued):
• To improve efficiency, can change node structure so that each node
stores the size of its subtree in the node itself
• However, this will require extra work in other functions to maintain
struct node {
int item;
struct node *left;
struct node *right;
int size;
};
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Balancing Methods
Two categories:
global rebalancing
visit every node and balance its subtree;
⇒ perfectly balanced tree — at cost.
local rebalancing
perform small, efficient, localised operations
to try to improve the overall balance of the tree
… at the cost of imperfect balance
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Idea:
Completely rebalance whole tree so it is size-balanced
Method:
Lift the median node to the root
by partitioning on index size(t)/2,
then rebalance both subtrees (recursively)
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
First, partition on index n/2…
a
0 (indices)
t1
n/2 n - 1
t2
b
x y
partition
b
n/2
a
0
t1
x
n - 1
t′
2
y
…then rebalance both subtrees
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Pseudocode
rebalance(t):
Input: tree t
Output: rebalanced t
if size(t) < 3:
return t
t = partition(t, size(t) / 2)
t->left = rebalance(t->left)
t->right = rebalance(t->right)
return t
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Rebalance the following tree:
15
12
5
4
2
10
8
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
First, partition the tree on index 7/2 = 3(node 8)
15
12
5
4
2
10
8
1
2
3
4
8
5
4
2
15
12
10
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
First, partition the tree on index 7/2 = 3(node 8)
15
12
5
4
2
10
8
1
2
3
4
8
5
4
2
15
12
10
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Then, recursively rebalance subtrees
8
5
4
2
15
12
10
8
4
2 5
12
10 15
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Example
Then, recursively rebalance subtrees
8
5
4
2
15
12
10
8
4
2 5
12
10 15
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Analysis
Worst-case time complexity: O(n log n)
• Assume nodes store the size of their subtrees
• First step: partition entire tree on index n/2
• This takes at most n recursive calls, n rotations ⇒ n steps
• Result is two subtrees of size ≈ n/2
• Then partition both subtrees
• Partitioning these subtrees takes n/2 steps each ⇒ n steps in total
• Result is four subtrees of size ≈ n/4
• …and so on…
• About log2 n levels of partitioning in total, each requiring n steps
⇒ O(n log n)
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Global Rebalancing
Problems
What if we insert more items?
• Options:
• Rebalance on every insertion
• Not feasible
• Rebalance every k insertions; what k is good?
• Rebalance when imbalance exceeds threshold.
• It’s a tradeoff…
• We either have more costly insertions
• Or we have degraded performance for periods of time
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Periodic Rebalancing
bstInsert(t, v):
Input: tree t, value v
Output: t with v inserted
t = insertAtLeaf(t, v)
if size(t) mod k = 0:
t = rebalance(t)
return t
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Periodic Rebalancing
Remarks
• Good if tree is not modified very often
• Otherwise…
• Insertion will be slow occasionally due to rebalancing
• Performance will gradually degrade until next rebalance
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Local Rebalancing
Perform small, efficient, localised operations
in an attempt to improve the overall balance of the tree
1. root insertion
2. randomised insertion
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Idea:
Rotations change the structure of a tree
If we perform some rotations every time we insert,
that may restructure the tree randomly enough
such that it is more balanced
One systematic way to perform these rotations:
Insert new values at the root
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Method:
Insert new value normally (at the leaf) …
… and then rotate the new node up to the root.
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Insert 24 at the root of this tree:
10
5 14
30
29 32
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Insert 24 at the root of this tree:
10
5 14
30
29
24
32
1
2
3
4
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate right at 29
10
5 14
30
29
24
32
1
2
3
4
10
5 14
30
24
29
32
2
3
4
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate right at 30
10
5 14
30
24
29
32
2
3
4
10
5 14
24
30
29 32
3
4
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate left at 14
10
5 14
24
30
29 32
3
4
10
5 24
14 30
29 32
4
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Example
Rotate left at 10
10
5 24
14 30
29 32
4
24
10
5 14
30
29 32
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Pseudocode
insertAtRoot(t, v):
Input: tree t, value v
Output: t with v inserted at the root
if t is empty:
return new node containing v
else if v < t->item:
t->left = insertAtRoot(t->left, v)
t = rotateRight(t)
else if v > t->item:
t->right = insertAtRoot(t->right, v)
t = rotateLeft(t)
return t
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Root Insertion
Analysis
Analysis:
• Same time complexity as normal insertion: O(h)
• Tree is more likely to be balanced, but no guarantee
• Root insertion ensures recently inserted items are close to the root
• Useful for applications where recently added items are more likely to be
searched
• Major problem: ascending-ordered and descending-ordered data is still
a worst case for root insertion
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
BSTs don’t have control over insertion order.
Worst cases — (partially) ordered data — are common.
Idea:
Introduce some randomness into insertion algorithm:
Randomly choose whether to insert normally or insert at root
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
Pseudocode
insertRandom(t, v):
Input: tree t, value v
Output: t with v inserted
if t is empty:
return new node containing v
// p/q chance of inserting at root
if random() mod q < p:
return insertAtRoot(t, v)
else:
return insertAtLeaf(t, v)
Note: random()is a pseudo-random number generator
30% chance of root insertion ⇒ choose p = 3, q = 10
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Root Insertion
Randomised
Insertion
Summary
Randomised Insertion
Remarks
Randomised insertion creates similar results to
inserting items in random order.
Tree is more likely to be balanced (but no guarantee)
COMP2521
25T2
BSTs Recap
Balance
Balancing
Operations
Balancing
Methods
Global Rebalancing
Local Rebalancing
Summary
Summary
Advantages Disadvantages
Global
rebalancing Guarantees a balanced tree
Inefficient (O(n log n) per
rebalance), or periods of
degraded performance
Local
rebalancing
Efficient (adds only a
constant factor overhead to
insertion)
Not guaranteed to produce
a balanced tree


================================================================================

[12/24] week04lec02-graphs-intro.pdf
------------------------------------

COMP2521
25T2
Graphs
Graph ADT
Graph Reps
COMP2521 25T2
Graphs (I)
Introduction to Graphs
Sim Mautner
cs2521@cse.unsw.edu.au
graph fundamentals
graph adt
graph representations
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Fundamentals
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Motivation
Up to this point, we’ve seen a few collection types…
lists: a linear sequence of items
each node is connected to its next node
trees: a branched hierarchy of items
each node is connected to its child node(s)
what if we want something more general?
each node is connected to arbitrarily many nodes
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Motivation
Many applications need to model relationships between items.
… on a map: cities, connected by roads
… on the Web: pages, connected by hyperlinks
… in a game: states, connected by legal moves
… in a social network: people, connected by friendships
… in scheduling: tasks, connected by constraints
… in circuits: components, connected by traces
… in networking: computers, connected by cables
… in programs: functions, connected by calls
… etc. etc. etc.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
A graph is a data structure consisting of:
• A set of vertices V
• Also called nodes
• A set of edges E between pairs of vertices
v1
v2 v3
v4
V = {v1, v2, v3, v4}
E = {(v1, v2), (v1, v3), (v1, v4),
(v2, v3), (v3, v4)}
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Vertices are distinguished by a unique identifier.
• In this course, usually an integer between 0 and |V | − 1
Edges may be (optionally) directed, weighted and/or labelled.

COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Example
Example: Australian cities and roads
2716
4049
3051
732
2055
3429
1671
658
873
982
309
PER
ADL
DAR
MEL
BRI
CAN
SYD
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Problems
Questions we could answer with a graph:
• Is there a way to get from A to B?
• What is the best way to get from A to B?
• In general, what vertices can we reach from A?
• Is there a path that lets me visit all vertices?
• Can we form a tree linking all vertices?
• Are two graphs “equivalent”?
Graph problems are generally more complex to solve than linked list
problems:
• Items are not ordered
• Graphs may contain cycles
• Concrete representation is more complex
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs
Types of Graphs
Graphs can be a combination of these types:
undirected
unweighted
without loops
non-multigraph
or
or
or
or
directed
weighted
with loops
multigraph
... and others ...
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Undirected Graphs
In an undirected graph, edges do not have direction.
For example, Facebook friends.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Directed Graphs
In a directed graph or digraph, each edge has a direction.
For example, road maps, Twitter follows.
undirected graph directed graph
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Weighted Graphs
In a weighted graph, each edge has an associated weight.
For example, road maps, networks.
unweighted graph
3
5
1
2
weighted graph
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graphs with Loops
A loop is an edge from a vertex to itself.
Depending on the context,
a graph may or may not be able to have loops.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Multigraphs
In a multigraph,
multiple edges are allowed between two vertices.
For example, call graphs, maps.
Multigraphs will not be considered in this course.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
A simple graph is an undirected graph
with no loops and no multiple edges.
For now, we will only consider simple graphs.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
Question:
For a simple graph with V vertices,
what is the maximum possible number of edges?
(E = 0) E = V (V − 1)/2
Note on notation:
The number of vertices |V | and the number of edges |E|
are normally written as V and E for simplicity.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Simple Graphs
Question:
For a simple graph with V vertices,
what is the maximum possible number of edges?
(E = 0) E = V (V − 1)/2
Note on notation:
The number of vertices |V | and the number of edges |E|
are normally written as V and E for simplicity.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(I)
Two vertices v and w are adjacent
if an edge e := (v, w) connects them;
we say e is incident on v and w.
The degree of a vertex v (deg(v))
is the number of edges incident on v.
0
1
2
3 4
deg(0) = 2
deg(1) = 3
deg(2) = 2
deg(3) = 1
deg(4) = 4
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(II)
The ratio E:V can vary considerably.
If E is closer to V 2, the graph is dense.
If E is closer to V , the graph is sparse.
dense graph sparse graph
Knowing whether a graph is dense or sparse will affect
our choice of representation and algorithms.
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(III)
A path is
a sequence of vertices where
each vertex has a edge to the next in the
sequence
A path is simple
if it has no repeating vertices
A cycle is a path where
only the first and last vertices are the same
0-1-2-0, 1-2-3-1, 0-1-3-2-0
0
1
2
3
4
5
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(IV)
A complete graph is a graph where
every vertex is connected to every other vertex via an edge.
In a complete graph, E = 1
2 V (V − 1).
K3 K5 K6
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(V)
A connected graph is a graph where
there is a path from every vertex to every other vertex.
0
1
2
3
4
5
Connected graph
0
1
2
3
4
5
Disconnected graph
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VI)
A tree is a connected graph with no cycles.
A tree has exactly one path between each pair of vertices.
0
1
2
3
4
5
Tree
0
1
2
3
4
5
Not a tree
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VII)
A subgraph of a graph G
is a graph that contains a subset of the vertices of G
and a subset of the edges between these vertices.
0
1
2
3
4
5
0
1
2
3
4
5
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(VIII)
A connected component is a maximally connected subgraph.
A connected graph has one connected component — the graph itself.
A disconnected graph has two or more connected components.
0
1
2
3
4 5
6
7
8
9 10
11
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(IX)
A spanning tree of a graph G
is a subgraph that contains all the vertices of G
and is a single tree.
Spanning trees only exist for connected graphs.
0
1
2
3
4
0
1
2
3
4
0
1
2
3
4
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(X)
A spanning forest of a graph G
is a subgraph that contains all the vertices of G
and contains one tree for each connected component.
0
1
2
3
4 5
6
7
8
9 10
11
COMP2521
25T2
Graphs
Types of Graphs
Graph Terminology
Graph ADT
Graph Reps
Graph Terminology
(XI)
A clique is a complete subgraph.
A clique is non-trivial if it has 3 or more vertices.
0
1
2
3
4
5
6 7 8 9
10
11
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Graph ADT
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Graph ADT
What do we need to represent?
What operations do we need to support?
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Graph ADT
What do we need to represent?
A set of vertices V := {v1, · · · , vn }
A set of edges E := {(v, w) | v, w ∈ V }
What operations do we need to support?
create/destroy graph
add/remove edges
get #vertices, #edges
check if an edge exists
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Graph ADT
Operations
create/destroy
create a graph
free memory allocated to graph
query
get number of vertices
get number of edges
check if an edge exists
update
add edge
remove edge
We will extend this ADT with more complex operations later.
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Create/Destroy
typedef struct graph *Graph;
// vertices denoted by integers 0..V-1
typedef int Vertex;
/** Creates a new graph with nV vertices */
Graph GraphNew(int nV);
/** Frees all memory allocated to a graph */
void GraphFree(Graph g);
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Query
/** Returns the number of vertices in a graph */
int GraphNumVertices(Graph g);
/** Returns the number of edges in a graph */
int GraphNumEdges(Graph g);
/** Returns true if there is an edge between the given vertices
and false otherwise */
bool GraphIsAdjacent(Graph g, Vertex v, Vertex w);
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
A Graph ADT
"Graph.h"- Operations to Update
/** Inserts an edge into a graph */
void GraphInsertEdge(Graph g, Vertex v, Vertex w);
/** Removes an edge from a graph */
void GraphRemoveEdge(Graph g, Vertex v, Vertex w);
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Graph Representations
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Graph Representations
3 main graph representations:
Adjacency Matrix
Edges defined by presence value in V × V matrix
Adjacency List
Edges defined by entries in array of V lists
Array of Edges
Explicit representation of edges as (v, w) pairs
We’ll consider these representations for unweighted, undirected graphs.
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
A V × V matrix
Each cell represents a pair of vertices,
with a 1 indicating an edge between them
0
1
2
3
0 1 0 1
1 0 0 1
0 0 0 1
1 1 1 0
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
Implementation in C
struct graph {
int nV;
int nE;
bool **edges;
};
0
1
2
3
graph
edges
nV 4
nE 4
[0]
[1]
[2]
[3]
0 1 0 1
[0] [1] [2] [3]
1 0 0 1
0 0 0 1
1 1 1 0
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency Matrix
Advantages and Disadvantages
Advantages
Efficient
edge insertion/deletion
and adjacency check ( O(1))
Disadvantages
Huge memory usage ( O(V 2))
sparse graph ⇒ wasted space!
undirected graph ⇒ wasted space!
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Array of V lists
List at index v contains the neighbours of vertex v
0
1
2
3
[0] 1, 3
[1] 0, 3
[2] 3
[3] 0, 1, 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Implementation in C
struct graph {
int nV;
int nE;
struct adjNode **edges;
};
struct adjNode {
Vertex v;
struct adjNode *next;
};
0
1
2
3
graph
edges
nV 4
nE 4
[0]
[1]
[2]
[3]
1 3
0 3
3
0 1 2
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Adjacency List
Advantages and Disadvantages
Advantages
Space-efficient for
sparse graphs
O(V + E) memory usage
Disadvantages
Inefficient
edge insertion/deletion (O(V ))
(matters less for sparse graphs)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Explicit array of edges (pairs of vertices)
0
1
2
3
[0] (0,1)
[1] (0,3)
[2] (1,3)
[3] (2,3)
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Implementation in C
struct graph {
int nV;
int nE;
int maxE;
struct edge *edges;
};
struct edge {
Vertex v;
Vertex w;
};
0
1
2
3
graph
edges
nV 4
nE 4
maxE 8
(0,1) (0,3) (1,3) (2,3)
[0] [1] [2] [3] [4] [5] [6] [7]
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Array of Edges
Advantages and Disadvantages
Advantages
Very space-efficient for
sparse graphs where E < V
Disadvantages
Inefficient
edge insertion/deletion (O(E))
COMP2521
25T2
Graphs
Graph ADT
Graph Reps
Adjacency Matrix
Adjacency List
Array of Edges
Summary
Summary of Graph Representations
Adjacency Matrix Adjacency List Array of Edges
Space usage O(V 2) O(V + E) O(E)
Create O(V 2) O(V ) O(1)
Destroy O(V ) O(V + E) O(1)
Insert edge O(1) O(V ) O(E)
Remove edge O(1) O(V ) O(E)
Is adjacent O(1) O(V ) O(E)*
Degree O(V ) O(V ) O(E)*
* Can be O(log E) if the array is ordered
and both directions of each edge are stored in an undirected graph


================================================================================

[13/24] week05lec01-graph-traversal.pdf
---------------------------------------

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
COMP2521 25T2
Graphs (II)
Graph Traversal
Sim Mautner
cs2521@cse.unsw.edu.au
bfs and dfs
path checking
path finding
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
Problems on Graphs
Common problems on graphs:
• Is there a path between two vertices?
• What is the shortest path between two vertices?
• Which vertices are reachable from a particular vertex?
• Is the graph connected?
• Is there a cycle?
• How many connected components are there?
• Is there a simple path/cycle that passes through all vertices?
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
All of the above problems can be solved by
a systematic exploration of a graph via its edges.
This systematic exploration is called traversal or search.
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
Two primary methods for graph traversal/search:
Breadth-first search (BFS)
• Prioritises exploring widely over exploring deeply
• “Go wide”
• Implemented iteratively (using a queue)
Depth-first search (DFS)
• Prioritises exploring deeply over exploring widely
• “Go deep”
• Implemented recursively or iteratively (using a stack)
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a tree
In what order would BFS and DFS visit the nodes of this tree?
(Assume that nodes towards the left have higher priority)
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a tree
Breadth-first search
1
2
5
10
16 17
6
11
3
7
12 13
18
4
8 9
14
19
15
Depth-first search
1
2
3
4
5 6
7
8
9
10
11 12
13
14
15 16
17
18
19
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a graph
In what order would BFS and DFS visit the vertices of this graph?
(Assume that nodes containing smaller letters have higher priority)
a
b
c
d
e
f
g
h
i
COMP2521
25T2
Graph
Traversal
BFS and DFS
BFS
DFS
Ideas/Issues
Appendix
Graph Traversal
BFS vs. DFS in a graph
Breadth-first search
a1
b2
c
3 d 4
e5
f8
g 6
h9
i 7
Depth-first search
a1
b2
c
3 d 4
e8
f7
g 6
h9
i 5
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Breadth-first search visits vertices
in order of distance from the starting vertex.
BFS is implemented iteratively using a queue.
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Data structures
Data structures used in BFS:
• Visited array
• To keep track of which vertices have been visited
• Predecessor array
• To keep track of the predecessor of each vertex
• The predecessor of v is the vertex from which we reached v
• i.e., the vertex before v on the path to v
• Queue
• First-in-first-out data structure
• Stores unvisited vertices in the order that they should be visited
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Algorithm
Algorithm:
1 Create/initialise data structures:
• Create visited array, initialised to false
• Create predecessor array, initialised to -1
• Create empty queue
2 Mark starting vertex as visited and enqueue it
3 While the queue is not empty:
1 Dequeue a vertex
• Let this vertex be v
2 Explore v - that is, for each of v’s unvisited neighbours:
1 Mark it as visited
2 Set its predecessor to v
3 Enqueue it
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Example
0
1
2
3
4
5
6
7
8
9
BFS starting at 0
Done
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
pred
-1 0 0 2 5 0 5 5 4 7
queue
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Example
0
1
2
3
4
5
6
7
8
9
BFS starting at 0
Done
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
pred -1 0 0 2 5 0 5 5 4 7
queue 0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Pseudocode
bfs(G, src):
Input: graph G, starting vertex src
create visited array, initialised to false
create predecessor array, initialised to -1
create queue Q
visited[src] = true
enqueue src into Q
while Q is not empty:
v = dequeue from Q
for each neighbour w of v in G where visited[w] = false:
visited[w] = true
predecessor[w] = v
enqueue w into Q
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Simplification
When using a predecessor array in BFS,
the predecessor array can double as a visited array
predecessor[v] = -1means v is not visited
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Simplification
bfs(G, src):
Input: graph G, starting vertex src
create predecessor array, initialised to -1
create queue Q
predecessor[src] = src // <- mark src as visited
enqueue src into Q
while Q is not empty:
v = dequeue from Q
for each neighbour w of v in G where predecessor[w] = -1:
predecessor[w] = v
enqueue w into Q
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Breadth-First Search
Analysis
BFS is O(V + E) when using the adjacency list representation:
• Typical queue implementation has O(1) enqueue and dequeue
• Each vertex is visited at most once ⇒ O(V )
• For each vertex, all of its edges are considered once ⇒ O(E)
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
A BFS finds the shortest path between the starting vertex and all other
vertices.
• Shortest path in terms of the number of edges
The shortest path between src and dest can be found by tracing backwards
through the predecessor array (from dest to src).
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 → 4 →
8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 → 4 →
8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 →
4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→5 →
4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→
5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0
−→
5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
Example: Shortest path from 0 to 8
0 −→5 → 4 → 8
0
1
2
3
4
5
6
7
8
9
0 8
4
5
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
-1 0 0 2 5 0 5 5 4 7
COMP2521
25T2
Graph
Traversal
BFS
Example
Pseudocode
Analysis
Path Finding
DFS
Ideas/Issues
Appendix
Path-Finding with BFS
bfsFindPath(G, src, dest):
Input: graph G, vertices src and dest
... BFS starting from src ...
if predecessor[dest] ̸= -1:
v = dest
while v ̸= src:
print v, "<-"
v = predecessor[v]
print src
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Iterative
Ideas/Issues
Appendix
Depth-First Search
Depth-first search goes as far down one path
as possible until it reaches a dead end,
then backtracks until it finds a new path to take,
then repeats
DFS can be implemented recursively or iteratively.
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Depth-first search is described recursively as:
1 Mark current vertex as visited
• The first time, this is the starting vertex
2 For each neighbour of the current vertex:
• If it has not been visited:
• Recursively traverse starting from that vertex
The recursion naturally induces backtracking.
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Pseudocode
dfs(G, src):
Input: graph G, starting vertex src
create visited array, initialised to false
dfsRec(G, src, visited)
dfsRec(G, v, visited):
Input: graph G, vertex v, visited array
visited[v] = true // "visit" v
for each neighbour w of v in G:
if visited[w] = false:
dfsRec(G, w, visited)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Example
0
1
2
3
4
5
6
7
8
9
DFS starting at 0
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0 0 0 0 0 0 0 0 0 0
visit order
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Example
0
1
2
3
4
5
6
7
8
9
Done p
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
1 1 1 1 1 1 1 1 1 1
visit order 0 1 5 3 2 4 7 8 9 6
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Recursive Depth-First Search
Analysis
Recursive DFS is O(V + E) when using the adjacency list representation:
• Each vertex is visited at most once ⇒ O(V )
• Function is called on each vertex at most once
• For each vertex, all of its edges are considered once ⇒ O(E)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Recursive DFS can be adapted to check if a path exists between two vertices.
Idea:
• To check if a path exists between src and dest:
• If src = dest, then there is a path (the empty path)
• Otherwise, for each neighbour of src, recursively check if there is a path
from that neighbour to dest
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Example
Does there exist a path between 0 and 7 in this graph?
0
1
2
3
4
5
6
7
8
9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Example
pAnswer: Yes p
0
1
2
3
4
5
6
7
8
9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Pseudocode
dfsHasPath(G, src, dest):
Input: graph G, vertices src and dest
Output: true if there is a path from src to dest
false otherwise
create visited array, initialised to false
return dfsHasPathRec(G, src, dest, visited)
dfsHasPathRec(G, v, dest, visited):
Input: graph G, vertices v and dest, visited array
visited[v] = true
if v = dest:
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHasPathRec(G, w, dest, visited):
return true
return false
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Checking with Recursive DFS
Analysis
O(V + E) when using the adjacency list representation:
• Algorithm is just a modified recursive DFS with return statements
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
How to get the path?
Idea:
• Record the predecessor of each vertex during the DFS
• Trace backwards through the path after the DFS
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Pseudocode
dfsFindPath(G, src, dest):
Input: graph G, vertices src and dest
create predecessor array, initialised to -1
predecessor[src] = src
if dfsFindPathRec(G, src, dest, predecessor):
v = dest
while v ̸= src:
print v, "<-"
v = predecessor[v]
print src
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Pseudocode
dfsFindPathRec(G, v, dest, predecessor):
if v = dest:
return true
for each neighbour w of v in G:
if predecessor[w] = -1:
predecessor[w] = v
if dfsFindPathRec(G, w, dest, predecessor):
return true
return false
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Example
Find a path from 0 to 7
0
1
2
3
4
5
6
7
8
9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Pseudocode
Example
Analysis
Path checking
Path finding
Iterative
Ideas/Issues
Appendix
Path-Finding with Recursive DFS
Example
Path found:
0
1
2
3
4
5
6
7
8
9
pred
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0 0 3 5 3 1 -1 4 -1 -1
Clearly, DFS is not guaranteed to find the shortest path.
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
DFS can be implemented iteratively.
Iterative DFS is similar to BFS, but there are a few crucial differences:
• DFS uses a stack instead of a queue
• DFS marks a vertex as visited after removing it from the stack, not when
adding it (which is what BFS does, but with a queue)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
Pseudocode
dfs(G, src):
Input: graph G, vertex src
create visited array, initialised to false
create predecessor array, initialised to -1
create stack S
push src onto S
while S is not empty:
v = pop from S
if visited[v] = true:
continue // i.e., return to start of loop
visited[v] = true
for each neighbour w of v in G where visited[w] = false:
predecessor[w] = v
push w onto S
COMP2521
25T2
Graph
Traversal
BFS
DFS
Recursive
Iterative
Pseudocode
Analysis
Ideas/Issues
Appendix
Iterative Depth-First Search
Analysis
Iterative DFS is O(V + E) when using the adjacency list representation.
• Typical stack implementation has O(1) push and pop
• Each vertex visited at most once ⇒ O(V )
• For each vertex, all of its edges are considered ⇒ O(E)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Spanning Trees
The edges traversed in a graph traversal form a spanning tree.
Consider the following graph:
a
b
c
d
e
f
g
h
i
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Spanning Trees
A traversal starting at vertex ‘a’ forms the following spanning trees:
a
b
c
d
e
f
g
h
i
Breadth-first search
a
b
c
d
e
f
g
h
i
Depth-first search
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
If a graph is not connected,
a graph traversal starting from a given vertex
will not traverse the entire graph
0
1
2
3
4 5
6
7
8
9
010
11
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
Solution
After initial traversal is complete,
perform traversal again on an unvisited vertex,
repeat until all vertices are visited
This produces a spanning forest
0
1
2
3
4 5
6
7
8
9
010
11
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Spanning Trees
Disconnected
Graphs
Appendix
Disconnected Graphs
dfs(G):
Input: graph G
create predecessor array, initialised to -1
for each vertex v in G:
if predecessor[v] = -1:
dfsRec(G, v, predecessor)
...
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Appendix
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we avoid revisiting the same tiles?
Mark tiles as they are visited!
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we avoid revisiting the same tiles?
Mark tiles as they are visited!
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we find our way back to the entrance?
For each tile that we visit,
keep note of the tile we were on directly before it!
This is called the predecessor.
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS
How do we find our way back to the entrance?
For each tile that we visit,
keep note of the tile we were on directly before it!
This is called the predecessor.
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done
pMark 0 as visited
pMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
00 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0
Dequeue 0
Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
00 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
0
0 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1 -1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
0
0
0 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visited
pMark 1 as visited
pMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0 -1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
00
0 1
0 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0 -1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
00
0 1
0 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visited
pMark 2 as visited
pMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 1
0 1 2
0 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 1
0 1 2
0 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visited
pMark 5 as visited
Done exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0
Explore 0
Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visited
Done exploring 0
p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0
Dequeue 1
Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 2
0 1 2 5
0 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0
p0 is already visited
p5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visited
p5 is already visited
Done exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1
Explore 1
Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visited
Done exploring 1
p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1
Dequeue 2
Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 5
0 1 2 5
0 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1
p0 is already visited
pMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1 0
1
0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0 -1
2
-1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 5
0 1 2 5
0 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visited
pMark 3 as visited
Done exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
2
0
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2
Explore 2
Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visited
Done exploring 2
p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2
Dequeue 5
Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 5
0 1 2 5 3
0 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2
p0 is already visited
p1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visited
p1 is already visited
p3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visited
p3 is already visited
pMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2 -1
5 -1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 3
0 1 2 5 3
0 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visited
pMark 4 as visited
pMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 3
0 1 2 5 3 4
0 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0 -1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 3
0 1 2 5 3 4
0 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visited
pMark 6 as visited
pMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5 -1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 4
0 1 2 5 3 4 6
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5 -1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 4
0 1 2 5 3 4 6
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visited
pMark 7 as visited
Done exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5
Explore 5
Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visited
Done exploring 5
p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5
Dequeue 3
Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 6
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5
p2 is already visited
p4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visited
p4 is already visited
p5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visited
p5 is already visited
Done exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3
Explore 3
Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visited
Done exploring 3
p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3
Dequeue 4
Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3
p3 is already visited
p5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visited
p5 is already visited
p7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5
7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visited
p7 is already visited
pMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5
7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5 -1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visited
pMark 8 as visited
Done exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4
Explore 4
Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visited
Done exploring 4
p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4
Dequeue 6
Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4
p5 is already visited
Done exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6
Explore 6
Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visited
Done exploring 6
p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6
Dequeue 7
Explore 7Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6
p4 is already visited
p5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visited
p5 is already visited
p8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visited
p8 is already visited
pMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1 0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4 -1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visited
pMark 9 as visited
Done exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5
7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7
Explore 7
Dequeue 8Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visited
Done exploring 7
p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7
Dequeue 8
Explore 8Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7
p4 is already visited
p7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visited
p7 is already visited
p9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visited
p9 is already visited
Done exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8
Explore 8
Dequeue 9Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visited
Done exploring 8
p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8
Dequeue 9
Explore 9Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8
p7 is already visited
p8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visited
p8 is already visited
Done exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
9
9
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9
Explore 9
Done pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visited
Done exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
BFS Example
0
1
2
3
4
5
6
7
8
9
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
pred
queue
BFS starting at 0Dequeue 0Explore 0Dequeue 1Explore 1Dequeue 2Explore 2Dequeue 5Explore 5Dequeue 3Explore 3Dequeue 4Explore 4Dequeue 6Explore 6Dequeue 7Explore 7Dequeue 8Explore 8Dequeue 9Explore 9
Done
pMark 0 as visitedpMark 1 as visitedpMark 2 as visitedpMark 5 as visitedDone exploring 0p0 is already visitedp5 is already visitedDone exploring 1p0 is already visitedpMark 3 as visitedDone exploring 2p0 is already visitedp1 is already visitedp3 is already visitedpMark 4 as visitedpMark 6 as visitedpMark 7 as visitedDone exploring 5p2 is already visitedp4 is already visitedp5 is already visitedDone exploring 3p3 is already visitedp5 is already visitedp7 is already visitedpMark 8 as visitedDone exploring 4p5 is already visitedDone exploring 6p4 is already visitedp5 is already visitedp8 is already visitedpMark 9 as visitedDone exploring 7p4 is already visitedp7 is already visitedp9 is already visitedDone exploring 8p7 is already visitedp8 is already visitedDone exploring 9
0
1
2
55
1
0
5
20
3
5
0
1
3
4
6
7
3
2
4
5
4
3
5 7
8
6
5 7
4
5
8
9
8
4
7
99
7
8
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
-1
-1
0
-1
0
-1
2
-1
5
-1
0
-1
5
-1
5
-1
4
-1
7
000 10 1 20 1 2 50 1 2 50 1 2 50 1 2 5 30 1 2 5 30 1 2 5 3 40 1 2 5 3 4 60 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 70 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 80 1 2 5 3 4 6 7 8 90 1 2 5 3 4 6 7 8 9
0 1 2 5 3 4 6 7 8 9
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS

COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0
Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0
Mark 0 as visited
1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
00
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited
1 has not been visited
Recurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visited
Recurse into 1
Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order 0
0 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1
Mark 1 as visited
5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited
5 has not been visited
Recurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visited
Recurse into 5
Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
0
0 1
0 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5
Mark 5 as visited
3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited
3 has not been visited
Recurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visited
Recurse into 3
Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 1
0 1 5
0 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3
Mark 3 as visited
2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited
2 has not been visited
Recurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visited
Recurse into 2
Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 5
0 1 5 3
0 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2
Mark 2 as visited
Return4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
444
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visited
Return
4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn
4 has not been visited
Recurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visited
Recurse into 4
Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 3
0 1 5 3 2
0 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4
Mark 4 as visited
7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited
7 has not been visited
Recurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visited
Recurse into 7
Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 2
0 1 5 3 2 4
0 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
888
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7
Mark 7 as visited
8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
8 has not been visited
Recurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visited
Recurse into 8
Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1 0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 4
0 1 5 3 2 4 7
0 1 5 3 2 4 7 80 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
999
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8
Mark 8 as visited
9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
88
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited
9 has not been visited
Recurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visited
Recurse into 9
Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1 0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 7
0 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 90 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
99
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9
Mark 9 as visited
ReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visited
Return
ReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturn
Return
ReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturn
Return
ReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)
dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturn
Return
Return6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
666
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturn
Return
6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn
6 has not been visited
Recurse into 6Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visited
Recurse into 6
Mark 6 as visitedReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
1 0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 8
0 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
66
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6
Mark 6 as visited
ReturnReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visited
Return
ReturnReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturn
Return
ReturnReturn
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturn
Return
Return
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
DFS Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
8
8
8
9
9
9
8
7
4
3
5
6
6
6
5
1
0
DFS starting at 0Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited8 has not been visitedRecurse into 8Mark 8 as visited9 has not been visitedRecurse into 9Mark 9 as visitedReturnReturnReturnReturnReturn6 has not been visitedRecurse into 6Mark 6 as visitedReturnReturnReturn
Return
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
visit order
00 10 1 50 1 5 30 1 5 3 20 1 5 3 2 40 1 5 3 2 4 70 1 5 3 2 4 7 80 1 5 3 2 4 7 8 9
0 1 5 3 2 4 7 8 9 6
call stack
dfs(0)
dfs(1)
dfs(5)
dfs(3)
dfs(2)dfs(4)
dfs(7)
dfs(8)
dfs(9)
dfs(6)
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?
Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
111
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?
Mark 0 as visited
1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
00
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited
1 has not been visited
Recurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visited
Recurse into 1
Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1 0
1
0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
555
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1
Mark 1 as visited
5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
11
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited
5 has not been visited
Recurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visited
Recurse into 5
Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1
0
1
0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
333
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5
Mark 5 as visited
3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
55
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited
3 has not been visited
Recurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visited
Recurse into 3
Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1
0
1
0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
222
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3
Mark 3 as visited
2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
33
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited
2 has not been visited
Recurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visited
Recurse into 2
Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1 0
1 0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2
Mark 2 as visited
Return false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
22
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visited
Return false
4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
444
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false
4 has not been visited
Recurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visited
Recurse into 4
Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1 0
1 0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
777
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4
Mark 4 as visited
7 has not been visitedRecurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
44
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited
7 has not been visited
Recurse into 7Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visited
Recurse into 7
Mark 7 as visitedReturn trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0 0
1
0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7
Mark 7 as visited
Return trueAnswer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
77
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?
path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visited
Return true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?
COMP2521
25T2
Graph
Traversal
BFS
DFS
Ideas/Issues
Appendix
BFS
BFS Example
DFS
DFS Example
Path-Checking
Example
Path-Checking with Recursive DFS
Example
0
1
2
3
4
5
6
7
8
9
0
0
1
1
1
5
5
5
3
3
3
2
2
2
3
4
4
4
7
7
7
4
3
5
1
0
Is there a path between 0 and 7?Mark 0 as visited1 has not been visitedRecurse into 1Mark 1 as visited5 has not been visitedRecurse into 5Mark 5 as visited3 has not been visitedRecurse into 3Mark 3 as visited2 has not been visitedRecurse into 2Mark 2 as visitedReturn false4 has not been visitedRecurse into 4Mark 4 as visited7 has not been visitedRecurse into 7Mark 7 as visitedReturn true
Answer: Yes
visited
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
0
1
0
1
0
1
0
1
0
1
0
1 0
0
1 0 0
call stack
path(0, 7)?
path(1, 7)?
path(5, 7)?
path(3, 7)?
path(2, 7)?path(4, 7)?
path(7, 7)?


================================================================================

[14/24] week05lec02-directed-weighted-graphs.pdf
------------------------------------------------

COMP2521
25T2
COMP2521 25T2
Graphs (IV)
Directed and Weighted Graphs
Sim Mautner
cs2521@cse.unsw.edu.au
directed graphs
weighted graphs
COMP2521
25T2 Generalising Graphs
In graphs representing real-world scenarios,
edges are often directional and may have a sense of cost.
Thus, we need to consider directed and weighted graphs.
COMP2521
25T2 Directed Graphs
Some applications require us to consider
directional edges: v → w ̸= w → v
e.g., ‘follow’ on Twitter, one-way streets, etc.
In a directed graph or digraph:
edges have direction.
Each edge (v, w) has a source v and a destination w.
COMP2521
25T2 Directed Graphs
Example
a
d
g
f
b
c
e
COMP2521
25T2 Directed Graphs
Applications
application vertex is… edge is…
WWW web page hyperlink
chess board state legal move
scheduling task precedence
program function function call
journals article citation
make target dependency
COMP2521
25T2 Digraph Terminology
(I)
in-degree
deg−(v) or in(v)
the number of incoming edges to a vertex
out-degree
deg+(v) or out(v)
the number of outgoing edges from a vertex
0
1
2 3
in(0) = 1
in(1) = 2
in(2) = 1
in(3) = 2
out(0) = 1
out(1) = 0
out(2) = 3
out(3) = 2
COMP2521
25T2 Digraph Terminology
(II)
A directed path is
a sequence of vertices where
each vertex has an outgoing edge to
the next vertex in the sequence
If there is a directed path from v to w,
then we say that w is reachable from v
A directed cycle is
a directed path where
the first and last vertices are the same
e.g., 0-2-3-1-0, 1-2-3-1
0
1
2
3
4
5
COMP2521
25T2 Digraph Terminology
(III)
A digraph is strongly connected if
there is a directed path from every vertex to every other vertex
0
1
2
3
4
strongly connected
0
1
2
3
4
not strongly connected
COMP2521
25T2 Digraph Terminology
(IV)
A strongly-connected component is a
maximally strongly-connected subgraph.
A digraph that is not strongly connected has
two or more strongly-connected components.
0 1 2 3
4 5 6 7
COMP2521
25T2 Directed Graphs
Representations
Same representations as for undirected graphs:
• Adjacency matrix
• Adjacency list
• Array of edges
COMP2521
25T2 Directed Graphs
Representations
0
1
2 3
0 1 0 0
0 0 0 0
1 1 0 1
0 0 1 1
[0]
[1]
[2]
[3]
1
0 1 3
2 3
[0]
[1]
[2]
[3]
0 1
2 0
2 1
2 3
3 2
3 3
Adjacency matrix Adjacency list Array of edges
COMP2521
25T2 Digraph Complexity
Adjacency Matrix Adjacency List Array of Edges
Space usage O(V 2) O(V + E) O(E)
Insert edge O(1) O(deg(v)) O(E)
Remove edge O(1) O(deg(v)) O(E)
Contains edge O(1) O(deg(v)) O(log(E))
Real digraphs tend to be sparse (large V , small average deg(v)),
so we use deg(v) to denote the degree of the source vertex v.
COMP2521
25T2
Weighted Graphs
COMP2521
25T2 Weighted Graphs
Some applications require us to consider a cost or weight
assigned to a relation between two nodes.
In a weighted graph, each edge ( s, t, w) has a weight w.
0 1
2 3
4
5
3 5
8
2
7
Weighted Graph
0 1
2 3
4
4
3
6
4
2
2 7
6
Directed Weighted Graph
COMP2521
25T2 Weighted Graphs
Example: Major airline routes in Australia
2. 1
3.2
2.5
3.0
3.0 2. 1
0.8
2.0
1.5
1.8
0.8
1. 1
0.8
0.6
PER
ADL
DAR
MEL
BRI
CAN
SYD
COMP2521
25T2 Weighted Graphs
Representations
Adjacency matrix:
• store weight in each cell, not just true/false
• need a value to signify “no edge”
Adjacency list:
• add weight to each list node
Array of edges:
• add weight to each edge
COMP2521
25T2 Weighted Graphs
Representations: Adjacency Matrix
0
1 2
3
4
0.5


0 1 1 1 0
1 0 1 0 0
1 1 0 1 1
1 0 1 0 1
0 0 1 1 0


undirected, unweighted
0
1 2
3
4
0.2
0.4
0.5
0.5
0. 1
0. 1
0.9


− 0.2 0 .4 0 .5 −
0.2 − 0.5 − −
0.4 0 .5 − 0.1 0 .1
0.5 − 0.1 − 0.9
− − 0.1 0 .9 −


undirected, weighted
COMP2521
25T2 Weighted Graph
Representations: Adjacency Matrix
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
* 0.2 0.4 * *
* 0.3 0.6 * *
* 0.5 * 0. 1 *
0.5 * * * 0.9
* * 0. 1 * *
[0]
[1]
[2]
[3]
[4]
edges
nV
nE
5
9
COMP2521
25T2 Weighted Graph
Representations: Adjacency List
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
1 0.2 2 0.4
1 0.3 2 0.6
1 0.5 3 0. 1
0 0.7 4 0.9
2 0. 1
[0]
[1]
[2]
[3]
[4]
edges
nV
nE
5
9
COMP2521
25T2 Weighted Graph
Representations: Array of Edges
0
1
2
3
4
0.2
0.4
0.3
0.6
0.5
0. 1
0.7
0.9
0. 1
edges
nV
nE
maxE
5
9
...
0 1 0.2
0 2 0.4
1 1 0.3
1 2 0.6
2 1 0.5
2 3 0. 1
3 0 0.7
3 4 0.9
4 2 0. 1


================================================================================

[15/24] week05lec02-graph-problems.pdf
--------------------------------------

COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
COMP2521 25T2
Graphs (III)
Graph Problems
Sim Mautner
cs2521@cse.unsw.edu.au
cycle checking
connected components
hamiltonian paths/circuits
eulerian paths/circuits
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Graph Problems
Basic graph problems:
• Is there a cycle?
• How many connected components are there?
• Is there a simple path/cycle that passes through all vertices?
• Is there a path/cycle that passes through each edge exactly once?
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
A cycle is a path of length > 2
where the start vertex = end vertex
and no edge is used more than once
0 1
2
3
4 5 6
This graph has three distinct cycles:
1-2-5-1, 2-5-6-2, 1-2-6-5-1
(two cycles are distinct if they have different sets of edges)
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
How to check if a graph has a cycle?
Idea:
• Perform a DFS, starting from any vertex
• During the DFS, if the current vertex has an edge to an already-visited
vertex, then there is a cycle
0 1
2
3
4 5 6
tests/cycle1.txt
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
pick any vertex v in G
create visited array, initialised to false
return dfsHasCycle(G, v, visited)
dfsHasCycle(G, v, visited):
visited[v] = true
for each neighbour w of vin G:
if visited[w] = true:
return true
else if dfsHasCycle(G, w, visited):
return true
return false
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 1
Problem:
• The algorithm does not check whether the neighbour w is the vertex that
it just came from
• Therefore, it considers moving back and forth along a single edge to be a
cycle (e.g., 0-1-0)
0 1
2
3
4 5 6
tests/cycle2.txt
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
Improved idea:
• Perform a DFS, starting from any vertex
• Keep track of previous vertex during DFS
• During the DFS, if the current vertex has an edge to an already-visited
vertex which is not the previous vertex , then there is a cycle
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
pick any vertex v in G
create visited array, initialised to false
return dfsHasCycle(G, v, v, visited)
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each neighbour w of v in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Attempt 2
Problem:
• The algorithm only checks one connected component
• The connected component that the initially chosen vertex belongs to
0 1
2
3
4 5 6
tests/cycle3.txt
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Working Solution
Working idea:
• Perform a DFS, starting from any vertex
• Keep track of previous vertex during DFS
• During the DFS, if the current vertex has an edge to an already-visited
vertex which is not the previous vertex, then there is a cycle
• After the DFS, if any vertex has not yet been visited, perform another
DFS, this time starting from that vertex
• Repeat until all vertices have been visited
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Working Solution
hasCycle(G):
Input: graph G
Output: true if G has a cycle, false otherwise
create visited array, initialised to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, v, visited):
return true
return false
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each neighbour w of v in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
COMP2521
25T2
Cycle
Checking
Attempt 1
Attempt 2
Solution
Analysis
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Cycle Checking
Analysis
Analysis for adjacency list representation:
• Algorithm is a slight modification of DFS
• A full DFS traversal is O(V + E)
• Thus, worst-case time complexity of cycle checking is O(V + E)
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
A connected component
is a maximally connected subgraph
For example, this graph has three connected components:
0 1
2
3
4 5 6
7
8
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Definitions:
subgraph
a subset of vertices and edges of original graph
connected subgraph
there is a path between every pair of vertices in the subgraph
maximally connected subgraph
no way to include more edges/vertices from original graph into the subgraph
such that subgraph is still connected
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Problems:
How many connected components are there?
Are two vertices in the same connected component?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Goal:
• Compute an array which indicates which connected component each
vertex is in
• Let this array be called componentOf
• componentOf[v]contains the component number of vertex v
• For example:
0 1
2
3
4 5 6
7
8
[0]
0
[1]
0
[2]
1
[3]
1
[4]
0
[5]
1
[6]
1
[7]
2
[8]
2
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Idea:
• Choose a vertex and perform a DFS starting at that vertex
• During the DFS, assign all vertices visited to component 0
• After the DFS, if any vertex has not been assigned a component,
perform a DFS starting at that vertex
• During this DFS, assign all vertices visited to component 1
• Repeat until all vertices are assigned a component, increasing the
component number each time
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
components(G):
Input: graph G
Output: componentOf array
create componentOf array, initialised to -1
compNo = 0
for each vertex v in G:
if componentOf[v] = -1:
dfsComponents(G, v, componentOf, compNo)
compNo = compNo + 1
return componentOf
dfsComponents(G, v, componentOf, compNo):
componentOf[v] = compNo
for each neighbour w of v in G:
if componentOf[w] = -1:
dfsComponents(G, w, componentOf, compNo)
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Analysis
Analysis for adjacency list representation:
• Algorithm performs a full DFS, which is O(V + E)
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Suppose we frequently need to answer the following questions:
• How many connected components are there?
• Are v and w in the same connected component?
• Is there a path between v and w?
Note: The last two questions are actually equivalent in an undirected graph.
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
Solution:
• Cache the components array in the graph struct
struct graph {
...
int nC; // number of connected components
int *cc; // componentOf array
};
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
This allows us to answer the questions very easily:
// How many connected components are there?
int numComponents(Graph g) {
return g->nC;
}
// Are v and w in the same connected component?
bool inSameComponent(Graph g, Vertex v, Vertex w) {
return g->cc[v] == g->cc[w];
}
// Is there a path between v and w?
bool hasPath(Graph g, Vertex v, Vertex w) {
return g->cc[v] == g->cc[w];
}
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Connected Components
However, this information needs to be maintained as the graph changes:
• Inserting an edge may reduce nC
• If the endpoint vertices were in different components
• Removing an edge may increase nC
• If the endpoint vertices were in the same component and there is no other
path between them
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
A Hamiltonian path is
a path that includes each vertex exactly once
A Hamiltonian circuit is
a cycle that includes each vertex exactly once
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Named after
Irish mathematician, astronomer and physicist
Sir William Rowan Hamilton (1805-1865)

COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Consider the following graph:
0
1
2
3
4
0
1
2
3
4
Hamiltonian path
0
1
2
3
4
pHamiltonian circuit p
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
How to check if a graph has a Hamiltonian path?
Idea:
• Brute force
• Use DFS to check all possible paths
• Recursive DFS is perfect, as it naturally allows backtracking
• Keep track of the number of vertices left to visit
• Stop when this number reaches 0
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
hasHamiltonianPath(G):
Input: graph G
Output: true if G has a Hamiltonian path
false otherwise
create visited array, initialised to false
for each vertex v in G:
if dfsHamiltonianPath(G, v, visited, #vertices(G)):
return true
return false
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
dfsHamiltonianPath(G, v, visited, numVerticesLeft):
visited[v] = true
numVerticesLeft = numVerticesLeft - 1
if numVerticesLeft = 0:
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHamiltonianPath(G, w, visited, numVerticesLeft):
return true
visited[v] = false
return false
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path
Why set visited[v]to false at the end of dfsHamiltonianPath?
0
1
2
3
4
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Circuit
How to check if a graph has a Hamiltonian circuit?
• Similar approach as Hamiltonian path
• Don’t need to try all starting vertices
• After a Hamiltonian path is found, check if the final vertex is adjacent to
the starting vertex
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Circuit
hasHamiltonianCircuit(G):
Input: graph G
Output: true if G has a Hamiltonian circuit
false otherwise
if #vertices(G) < 3:
return false
create visited array, initialised to false
return dfsHamiltonianCircuit(G, 0, visited, #vertices(G))
dfsHamiltonianCircuit(G, v, visited, numVerticesLeft):
visited[v] = true
numVerticesLeft = numVerticesLeft - 1
if numVerticesLeft = 0 and adjacent(G, v, 0):
return true
for each neighbour w of v in G:
if visited[w] = false:
if dfsHamiltonianCircuit(G, w, visited, numVerticesLeft):
return true
visited[v] = false
return false
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Hamiltonian Path and Circuit
Analysis
Analysis:
• Worst-case time complexity: O(V !)
• There are at most V ! paths to check ( ≈
√
2πV (V /e)V by Stirling’s
approximation)
• There is no known polynomial time algorithm, so the Hamiltonian path
problem is NP-hard
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
An Eulerian path is
a path that visits each edge exactly once
An Eulerian circuit is
an Eulerian path that starts and ends at the same vertex
0 1
2 3
4
Eulerian path:
4-2-0-1-3-0
0 1
2 3
4
Eulerian circuit:
4-2-0-1-3-4
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
Problem is named after
Swiss mathematician, physicist, astronomer, logician and engineer
Leonhard Euler (1707-1783)

COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
Problem was introduced by Euler while trying to solve the
Seven Bridges of Konigsberg problem in 1736.
Is there a way to cross all the bridges exactly once on a walk through the
town?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Background
This is a graph problem:
vertices represent pieces of land
edges represent bridges

COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
How to check if a graph has an Eulerian path or circuit?
Can use the following theorems:
A graph has an Eulerian path if and only if
exactly zero or two vertices have odd degree,
and all vertices with non-zero degree belong to the same connected
component
A graph has an Eulerian circuit if and only if
every vertex has even degree,
and all vertices with non-zero degree belong to the same connected
component
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Which of these graphs have an Eulerian path? How about an Eulerian circuit?
0 1
2
0 1
2 3
4
0 1
2 3
4 5
6
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Why
“all vertices with non-zero degree belong to the same connected
component”?
0 1
2 3
4
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path
hasEulerianPath(G):
Input: graph G
Output: true if G has an Eulerian path
false otherwise
numOddDegree = 0
for each vertex v in G:
if degree(G, v) is odd:
numOddDegree = numOddDegree + 1
return (numOddDegree = 0 or numOddDegree = 2) and
eulerConnected(G)
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path
eulerConnected(G):
Input: graph G
Output: true if all vertices in G with non-zero degree
belong to the same connected component
false otherwise
create visited array, initialised to false
for each vertex v in G:
if degree(G, v) > 0:
dfsRec(G, v, visited)
break
for each vertex v in G:
if degree(G, v) > 0 and visited[v] = false:
return false
return true
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Circuit
hasEulerianCircuit(G):
Input: graph G
Output: true if G has an Eulerian circuit
false otherwise
for each vertex v in G:
if degree(G, v) is odd:
return false
return eulerConnected(G)
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Eulerian Path and Circuit
Analysis
Analysis for adjacency list representation:
• Finding degree of every vertex is O(V + E)
• Checking connectivity requires a DFS which is O(V + E)
• Therefore, worst-case time complexity is O(V + E)
So unlike the Hamiltonian path problem, the Eulerian path problem can be
solved in polynomial time.
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
Many graph problems are intractable – that is,
there is no known “efficient” algorithm to solve them.
In this context, “efficient” usually means polynomial time.
A tractable problem is one that is known to have a
polynomial-time solution.
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Tractable and Intractable
tractable intractable
what is the shortest path
between two vertices? how about the longest path?
does a graph contain a clique? what is the largest clique?
given two colors, is it possible to
colour every vertex in a graph such
that no two adjacent vertices are the
same colour?
what about three colours?
does a graph contain an Eulerian path? how about a Hamiltonian path?
COMP2521
25T2
Cycle
Checking
Connected
Components
Hamiltonian
Path/Circuit
Eulerian
Path/Circuit
Other
Problems
Other Graph Problems
Bonus Round!
a
b
c
d
e
f
g
h
1 2
34
5 6
78
Graph isomorphism:
Can we make two given graphs identical by renaming vertices?


================================================================================

[16/24] week07lec01-digraph-algorithms.pdf
------------------------------------------

COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Other
Algorithms
COMP2521 25T2
Graphs (V)
Digraph Algorithms
Sim Mautner
cs2521@cse.unsw.edu.au
digraph traversal
cycle checking
transitive closure
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Other
Algorithms
Directed Graphs (Digraphs)
Reminder: directed graphs are graphs where…
• Each edge (v, w) has a source v and a destination w
• Unlike undirected graphs, v → w ̸= w → v
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Other
Algorithms
Digraph Applications
application vertex is… edge is…
WWW web page hyperlink
chess board state legal move
scheduling task precedence
program function function call
journals article citation
make target dependency
COMP2521
25T2
Traversal
Application
Cycle
Checking
Transitive
Closure
Other
Algorithms
Digraph Traversal
Same as for undirected graphs:
bfs(G, src):
initialise visited array
mark src as visited
enqueue src into Q
while Q is not empty:
v = dequeue from Q
for each edge (v, w) in G:
if w has not been visited:
mark w as visited
enqueue w into Q
dfs(G, src):
initialise visited array
dfsRec(G, src, visited)
dfsRec(G, v, visited):
mark v as visited
for each edge (v, w) in G:
if w has not been visited:
dfsRec(G, w, visited)
COMP2521
25T2
Traversal
Application
Cycle
Checking
Transitive
Closure
Other
Algorithms
Digraph Traversal
Application - Web Crawling
Web crawling
Visit a subset of the web…
…to index
…to cache locally
Which traversal method? BFS or DFS?
Note: we can’t use a visited array, as we don’t know how many webpages
there are. Instead, use a visited set.
COMP2521
25T2
Traversal
Application
Cycle
Checking
Transitive
Closure
Other
Algorithms
Digraph Traversal
Application - Web Crawling
Web crawling algorithm:
webCrawl(startingUrl, maxPagesToVisit):
create visited set
add startingUrl to visited set
enqueue startingUrl into Q
numPagesVisited = 0
while Q is not empty and numPagesVisited < maxPagesToVisit:
currPage = dequeue from Q
visit currPage
numPagesVisited = numPagesVisited + 1
for each hyperlink on currPage:
if hyperlink not in visited set:
add hyperlink to visited set
enqueue hyperlink into Q
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
In directed graphs,
a cycle is a directed path
where the start vertex = end vertex
0 1
2
3
4 5 6
This graph has three distinct cycles:
0-4-0, 2-5-6-2, 3-3
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Recall: Cycle checking for undirected graphs:
hasCycle(G):
initialise visited array to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, v, visited):
return true
return false
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each edge (v, w) in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
Does this work for
directed graphs?
No
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Recall: Cycle checking for undirected graphs:
hasCycle(G):
initialise visited array to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, v, visited):
return true
return false
dfsHasCycle(G, v, prev, visited):
visited[v] = true
for each edge (v, w) in G:
if w = prev:
continue
if visited[w] = true:
return true
else if dfsHasCycle(G, w, v, visited):
return true
return false
Does this work for
directed graphs?
No
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Problem #1
Algorithm ignores edge to previous vertex
and therefore does not detect the following cycle:
0 1
Simple fix: Don’t ignore edge to previous vertex
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
hasCycle(G):
initialise visited array to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, visited):
return true
return false
dfsHasCycle(G, v, visited):
visited[v] = true
for each edge (v, w) in G:
if visited[w] = true:
return true
else if dfsHasCycle(G, w, visited):
return true
return false
Does this work for
directed graphs?
No!
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
hasCycle(G):
initialise visited array to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, visited):
return true
return false
dfsHasCycle(G, v, visited):
visited[v] = true
for each edge (v, w) in G:
if visited[w] = true:
return true
else if dfsHasCycle(G, w, visited):
return true
return false
Does this work for
directed graphs?
No!
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Problem #2
Algorithm can detect cycles when there is none,
for example:
0
1
2
Algorithm starts at 0, recurses into 1 and 2,
backtracks to 0, sees that 2 has been visited,
and concludes there is a cycle
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
1
11
2
1
2
call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
1
11
2
1
2
call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
1
1
1
2
1
2
call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
1
1
1
2
1
2
call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
11
1
2
1
2 call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Consider a cycle check on this undirected graph (starting at 0):
0
1
2
0
0
11
1
2
1
2 call stack
dfsHasCycle(0, prev=0)
dfsHasCycle(1, prev=0)
dfsHasCycle(2, prev=1)
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
1
11
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
1
11
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
1
1
1
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
1
1
1
2
2
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
11
1
2
2
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
11
1
2
2
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
1
1
1
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
111
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Let’s compare with a directed graph:
0
1
2
0
0
111
22
call stack
dfsHasCycle(0)
dfsHasCycle(1)
dfsHasCycle(2)
No edge from 2 to 0!
2 is not on the stack!
visited
[0] [1] [2]
1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Idea:
To properly detect a cycle,
check if neighbour is already on the call stack
When the graph is undirected,
this can be done by checking the visited array,
but this doesn’t work for directed graphs!
Need to use separate array to
keep track of when a vertex is on the call stack
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Pseudocode
hasCycle(G):
create visited array, initialised to false
create onStack array, initialised to false
for each vertex v in G:
if visited[v] = false:
if dfsHasCycle(G, v, visited, onStack):
return true
return false
dfsHasCycle(G, v, visited, onStack):
visited[v] = true
onStack[v] = true
for each edge (v, w) in G:
if onStack[w] = true:
return true
else if visited[w] = false:
if dfsHasCycle(G, w, visited, onStack):
return true
onStack[v] = false
return false
COMP2521
25T2
Traversal
Cycle
Checking
Pseudocode
Example
Transitive
Closure
Other
Algorithms
Cycle Checking
Example
Check if a cycle exists in this graph:
0 1
2
3
4
5
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Other
Algorithms
Transitive Closure
Problem: computing reachability
Given a digraph G it is potentially useful to know:
• Is vertex t reachable from vertex s?
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Other
Algorithms
Transitive Closure
One way to implement a reachability check:
• Use BFS or DFS starting at s
• This is O(V + E) in the worst case
• Only feasible if reachability is an infrequent operation
What about applications that frequently need to check reachability?
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Other
Algorithms
Transitive Closure
Idea
Construct a V × V matrix
that tells us whether there is a path (not edge)
from s to t, for s, t ∈ V
This matrix is called the transitive closure (tc) matrix
(or reachability matrix)
tc[s][t]is true if there is a path from s to t, false otherwise
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Other
Algorithms
Transitive Closure
0 1
2
34
5 6
adjacency matrix
[0] [1] [2] [3] [4] [5] [6]
[6]
[5]
[4]
[3]
[2]
[1]
[0]
0 1 1 0 0 0 0
0 0 0 0 0 0 1
0 0 0 1 0 0 1
0 0 1 0 1 0 0
0 0 1 0 0 0 0
1 0 1 0 0 0 0
0 0 0 0 0 0 1
reachability matrix
[0] [1] [2] [3] [4] [5] [6]
[6]
[5]
[4]
[3]
[2]
[1]
[0]
1 1 1 0 0 0 1
1 1 1 0 0 0 1
1 1 1 1 1 0 1
1 1 1 1 1 0 1
0 0 1 0 0 0 0
1 1 1 0 0 0 1
1 1 1 0 0 0 1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Other
Algorithms
Transitive Closure
One way to compute reachability matrix:
• Perform BFS/DFS from every vertex
Another way ⇒ Warshall’s algorithm:
• Simple algorithm that does not require a graph traversal
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Warshall’s algorithm
uses transitivity to compute reachability
If there is a path from u to v,
and a path from v to w...
then there is a path from u to w
u v w
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Warshall’s algorithm
uses transitivity to compute reachability
If there is a path from u to v,
and a path from v to w...
then there is a path from u to w
u v w
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Idea of Warshall’s algorithm:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• …
• There is a path from s to t via any of the other vertices
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• There is a path from s to t via vertex 0, 1, 2 and/or 3
0
1
2
3
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• There is a path from s to t via vertex 0, 1, 2 and/or 3
0
1
2
3
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• There is a path from s to t via vertex 0, 1, 2 and/or 3
0
1
2
3
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• There is a path from s to t via vertex 0, 1, 2 and/or 3
0
1
2
3
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example:
• There is a path from s to t if:
• There is an edge from s to t, or
• There is a path from s to t via vertex 0, or
• There is a path from s to t via vertex 0 and/or 1, or
• There is a path from s to t via vertex 0, 1 and/or 2, or
• There is a path from s to t via vertex 0, 1, 2 and/or 3
0
1
2
3
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
On the k-th iteration, the algorithm determines if a path exists between two
vertices s and t using just 0, … , k as intermediate vertices
s
t
k On the k-th iteration
If we have:
(1) a path from s to k
(2) a path from k to t
(using only vertices 0 to k − 1)
Then we have a path from s to t
using vertices from 0 to k
if tc[s][k] and tc[k][t]:
tc[s][t] = true
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
On the k-th iteration, the algorithm determines if a path exists between two
vertices s and t using just 0, … , k as intermediate vertices
s
t
k On the k-th iteration
If we have:
(1) a path from s to k
(2) a path from k to t
(using only vertices 0 to k − 1)
Then we have a path from s to t
using vertices from 0 to k
if tc[s][k] and tc[k][t]:
tc[s][t] = true
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Pseudocode
warshall(A):
Input: n × n adjacency matrix A
Output: n × n reachability matrix
create tc matrix which is a copy of A
for each vertex k in G: // from 0 to n - 1
for each vertex s in G:
for each vertex t in G:
if tc[s][k] and tc[k][t]:
tc[s][t] = true
return tc
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graph
Initialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1
0
1
1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graph
Initialise tc with edges of original graph
First iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1
0
1
1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graph
First iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1
0
1
1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graph
First iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1
0
1
1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graph
First iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graph
First iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1
1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1 0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1 0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → t
Done
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → t
Done
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1 0
1 0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1
0
1
0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1
0
1
0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Example
Find transitive closure of this graphInitialise tc with edges of original graphFirst iteration: k = 0
There is a path 1 → 0 and a path 0 → 2
So there is a path 1 → 2
Done
Second iteration: k = 1
There is a path 3 → 1 and a path 1 → 0
So there is a path 3 → 0
There is a path 3 → 1 and a path 1 → 2
So there is a path 3 → 2
There is a path 3 → 1 and a path 1 → 3
So there is a path 3 → 3
Done
Third iteration: k = 2
No pairs ( s, t) such that there are paths s → 2 and 2 → tDone
Fourth iteration: k = 3
There is a path 1 → 3 and a path 3 → 1
So there is a path 1 → 1
Done
Finished
0
1
2
3
0
1
2
3
[0] [1] [2] [3]
[0]
[1]
[2]
[3]
0 0 1 0
1
0
1
0
1 1
0 0 0 0
0
1 1
0
1
0
1
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Warshall’s algorithm
Pseudocode
Example
Analysis
Other
Algorithms
Warshall’s Algorithm
Analysis
Analysis:
• Time complexity: O(V 3)
• Three nested loops iterating over all vertices
• Space complexity: O(V 2)
• Can be O(1) if overwriting the input matrix
• Benefit: checking reachability between vertices is now O(1)
• Makes up for slow setup ( O(V 3)) if reachability is a very frequent operation
COMP2521
25T2
Traversal
Cycle
Checking
Transitive
Closure
Other
Algorithms
Other Algorithms
Strongly connected components:
• Kosaraju’s algorithm
• Tarjan’s algorithm


================================================================================

[17/24] week07lec01-dijkstras-algorithm.pdf
-------------------------------------------

COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
COMP2521 25T2
Graphs (VI)
Dijkstra’s Algorithm
Sim Mautner
cs2521@cse.unsw.edu.au
shortest path
dijkstra’s algorithm
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Shortest Path
In a weighted graph…
A path is a sequence of edges
connected end-to-end
(v0, v1, w1), (v1, v2, w2), … , (vm−1, vm , wm )
v0 v1 v2
…
vm−1 vm
weight1 weight2 weightm
The cost of a path is
the sum of edge weights along the path
The shortest path between two vertices s and t is
the path from s to t with minimum cost
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Shortest Path
Variations on shortest path problem:
• Source-target shortest path
• Shortest path from source vertex s to target vertex t
• Single-source shortest path
• Shortest path from source vertex s to all other vertices
• All-pairs shortest path
• Shortest path between all pairs of source and target vertices
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Shortest Path
In a weighted graph,
a path with more edges may be “shorter” than
a path with fewer edges
0 1
2
34
5
5
2 2
2
1
1 1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Dijkstra’s Algorithm
Invented by Dutch computer scientist
Edsger W. Dijkstra in 1956

COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Dijkstra’s Algorithm
Dijkstra’s algorithm
finds the shortest path in a weighted graph
with non-negative weights
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Data Structures
Data structures used in Dijkstra’s algorithm:
• Distance array (dist)
• To keep track of shortest currently known distance to each vertex
• Predecessor array (pred)
• Same purpose as in BFS/DFS
• To keep track of the predecessor of each vertex on the shortest currently
known path to that vertex
• Used to construct the shortest path
• Set of vertices
• Stores unexplored vertices
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Algorithm
1 Create and initialise data structures
• Create distance array, initialised to infinity
• In C, can use INT_MAX(from <limits.h>)
• Create predecessor array, initialised to -1
• Initialise set of vertices to contain all vertices
2 Set distance of source vertex ( s) to 0
3 While set of vertices is not empty:
1 Remove vertex from vertex set with smallest distance in distance array
• Let this vertex be v
2 Explore v - that is, for each edge v – w:
• Check if using this edge gives a shorter path to w
• If so, update w’s distance and predecessor - this is called edge relaxation
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
During Dijkstra’s algorithm, the distand predarrays:
• contain data about the shortest path discovered so far
• need to be updated if a shorter path to some vertex is found
• this is done via edge relaxation
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Suppose we are considering edge (v, w, weight).
We have the following data:
• dist[v]- length of shortest known path from s to v
• dist[w]- length of shortest known path from s to w (which may be ∞)
v
w
s weight
weight
dist[v]
dist[w]
In edge relaxation, we take the shortest known path from s to v and extend it
using edge (v, w, weight) to create a new path from s to w.
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Suppose we are considering edge (v, w, weight).
We have the following data:
• dist[v]- length of shortest known path from s to v
• dist[w]- length of shortest known path from s to w (which may be ∞)
v
w
s
weight
weight
dist[v]
dist[w]
In edge relaxation, we take the shortest known path from s to v and extend it
using edge (v, w, weight) to create a new path from s to w.
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Suppose we are considering edge (v, w, weight).
We have the following data:
• dist[v]- length of shortest known path from s to v
• dist[w]- length of shortest known path from s to w (which may be ∞)
v
w
s weight
weight
dist[v]
dist[w]
In edge relaxation, we take the shortest known path from s to v and extend it
using edge (v, w, weight) to create a new path from s to w.
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Now we have two paths from s to w:
• Shortest known path
• New path via v
v
w
s weight
dist[v]
dist[w]
If the new path is shorter, then we update dist[w]and pred[w].
if dist[v] + weight < dist[w]:
dist[w] = dist[v] + weight
pred[w] = v
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Example 1
Before relaxation along ( u, w, 7)
s
w
u 7
dist[u] = 5
dist[w] = ∞
... [u] ... [w]
dist ... 5 ... ∞
pred ... ... ... -1
After relaxation along ( u, w, 7)
s
w
u 7
dist[u] = 5
dist[w] = 12
... [u] ... [w]
dist ... 5 ... 12
pred ... ... ... u
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Example 1
Before relaxation along ( u, w, 7)
s
w
u 7
dist[u] = 5
dist[w] = ∞
... [u] ... [w]
dist ... 5 ... ∞
pred ... ... ... -1
After relaxation along ( u, w, 7)
s
w
u 7
dist[u] = 5
dist[w] = 12
... [u] ... [w]
dist ... 5 ... 12
pred ... ... ... u
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Example 2
Before relaxation along ( v, w, 3)
s
v
w
u
dist[w] = 12
dist[v] = 8
3
... [u] [v] [w]
dist ... 5 8 12
pred ... ... ... u
After relaxation along ( v, w, 3)
s
v
w
u
dist[v] = 8
3
dist[w] = 11
... [u] [v] [w]
dist ... 5 8 11
pred ... ... ... v
COMP2521
25T2
Algorithm
Edge relaxation
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Edge Relaxation
Example 2
Before relaxation along ( v, w, 3)
s
v
w
u
dist[w] = 12
dist[v] = 8
3
... [u] [v] [w]
dist ... 5 8 12
pred ... ... ... u
After relaxation along ( v, w, 3)
s
v
w
u
dist[v] = 8
3
dist[w] = 11
... [u] [v] [w]
dist ... 5 8 11
pred ... ... ... v
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Pseudocode
dijkstraSSSP(G, src):
Input: graph G, source vertex src
create dist array, initialised to ∞
create pred array, initialised to -1
create vSet containing all vertices of G
dist[src] = 0
while vSet is not empty:
find vertex v in vSet such that dist[v] is minimal
remove v from vSet
for each edge (v, w, weight) in G:
relax along (v, w weight)
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
Dijkstra’s algorithm starting at 0
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)
(p)After first iteration ( v = 0) (p)(p)After second iteration ( v = 3) (p)(p)After third iteration ( v = 2) (p)(p)After fourth iteration ( v = 5) (p)(p)After fifth iteration ( v = 1) (p)(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞
dist 0 14 9 7 ∞ ∞dist 0 14 9 7 ∞ 22dist 0 13 9 7 ∞ 12dist 0 13 9 7 20 12dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1
pred -1 0 0 0 -1 -1pred -1 0 0 0 -1 3pred -1 2 0 0 -1 2pred -1 2 0 0 5 2pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)
(p)After first iteration ( v = 0) (p)
(p)After second iteration ( v = 3) (p)(p)After third iteration ( v = 2) (p)(p)After fourth iteration ( v = 5) (p)(p)After fifth iteration ( v = 1) (p)(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞
dist 0 14 9 7 ∞ ∞
dist 0 14 9 7 ∞ 22dist 0 13 9 7 ∞ 12dist 0 13 9 7 20 12dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1
pred -1 0 0 0 -1 -1
pred -1 0 0 0 -1 3pred -1 2 0 0 -1 2pred -1 2 0 0 5 2pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)(p)After first iteration ( v = 0) (p)
(p)After second iteration ( v = 3) (p)
(p)After third iteration ( v = 2) (p)(p)After fourth iteration ( v = 5) (p)(p)After fifth iteration ( v = 1) (p)(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞dist 0 14 9 7 ∞ ∞
dist 0 14 9 7 ∞ 22
dist 0 13 9 7 ∞ 12dist 0 13 9 7 20 12dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1pred -1 0 0 0 -1 -1
pred -1 0 0 0 -1 3
pred -1 2 0 0 -1 2pred -1 2 0 0 5 2pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)(p)After first iteration ( v = 0) (p)(p)After second iteration ( v = 3) (p)
(p)After third iteration ( v = 2) (p)
(p)After fourth iteration ( v = 5) (p)(p)After fifth iteration ( v = 1) (p)(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞dist 0 14 9 7 ∞ ∞dist 0 14 9 7 ∞ 22
dist 0 13 9 7 ∞ 12
dist 0 13 9 7 20 12dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1pred -1 0 0 0 -1 -1pred -1 0 0 0 -1 3
pred -1 2 0 0 -1 2
pred -1 2 0 0 5 2pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)(p)After first iteration ( v = 0) (p)(p)After second iteration ( v = 3) (p)(p)After third iteration ( v = 2) (p)
(p)After fourth iteration ( v = 5) (p)
(p)After fifth iteration ( v = 1) (p)(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞dist 0 14 9 7 ∞ ∞dist 0 14 9 7 ∞ 22dist 0 13 9 7 ∞ 12
dist 0 13 9 7 20 12
dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1pred -1 0 0 0 -1 -1pred -1 0 0 0 -1 3pred -1 2 0 0 -1 2
pred -1 2 0 0 5 2
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)(p)After first iteration ( v = 0) (p)(p)After second iteration ( v = 3) (p)(p)After third iteration ( v = 2) (p)(p)After fourth iteration ( v = 5) (p)
(p)After fifth iteration ( v = 1) (p)
(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞dist 0 14 9 7 ∞ ∞dist 0 14 9 7 ∞ 22dist 0 13 9 7 ∞ 12dist 0 13 9 7 20 12
dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1pred -1 0 0 0 -1 -1pred -1 0 0 0 -1 3pred -1 2 0 0 -1 2pred -1 2 0 0 5 2
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Initialisation (p)(p)After first iteration ( v = 0) (p)(p)After second iteration ( v = 3) (p)(p)After third iteration ( v = 2) (p)(p)After fourth iteration ( v = 5) (p)(p)After fifth iteration ( v = 1) (p)
(p)After sixth iteration ( v = 4) (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 ∞ ∞ ∞ ∞ ∞dist 0 14 9 7 ∞ ∞dist 0 14 9 7 ∞ 22dist 0 13 9 7 ∞ 12dist 0 13 9 7 20 12
dist 0 13 9 7 18 12
pred -1 -1 -1 -1 -1 -1pred -1 0 0 0 -1 -1pred -1 0 0 0 -1 3pred -1 2 0 0 -1 2pred -1 2 0 0 5 2
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Example
(p)Done (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0] [1] [2] [3] [4] [5]
dist 0 13 9 7 18 12
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
The shortest path from the source vertex to any other vertex
can be constructed by tracing backwards through the predecessor array
(like for BFS)
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→2 −→1 −→
4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→2 −→1 −→
4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→2 −→
1 −→4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→2 −→
1 −→4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→
2 −→1 −→4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0
−→
2 −→1 −→4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
Example: Shortest path from 0 to 4
0 −→2 −→1 −→4
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
1
2
[0] [1] [2] [3] [4] [5]
pred -1 2 0 0 1 2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Example
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Path Finding
How to find shortest path between two other vertices
(neither of which are the source vertex)?
Generally, you will need to rerun Dijkstra’s algorithm from one of these
vertices.
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Implementation Details
Set of vertices
The set of vertices can be implemented in different ways:
1 Visited array
2 Explicit array/list of vertices
3 Priority queue
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Implementation Details
Set of vertices - visited array
Visited array implementation:
• Similar to visited array in BFS/DFS
• Array of V booleans, initialised to false
• After exploring vertex v, set visited[ v] to true
• At the start of each iteration, find vertex v such that visited[ v] is false
and dist[v] is minimal ⇒ O(V )
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Implementation Details
Set of vertices - list of vertices
Array/list of vertices implementation:
• Store all vertices in an array/linked list
• After exploring vertex v, remove v from array/linked list
• At the start of each iteration, find vertex in array/list such that dist[ v] is
minimal ⇒ O(V )
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Implementation Details
Set of vertices - priority queue
Priority queue implementation:
• A priority queue is an ADT…
• where each item has a priority
• with two main operations:
• Insert: insert item with priority
• Delete: remove item with highest priority
• Use priority queue to store vertices, use distance to vertex as priority
(smaller distance = higher priority)
• A good priority queue implementation has O(log n) insert and delete
Priority queues will be discussed in Week 9.
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Correctness
Time complexity
Other
Algorithms
Appendix
Analysis
Correctness
Proof by induction
(see appendix for the proof outline)
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Correctness
Time complexity
Other
Algorithms
Appendix
Analysis
Time complexity
Analysis:
• Each edge is considered once ⇒ O(E)
• Undirected edges are considered once in each direction
• Outer loop has V iterations
• Every iteration, algorithm must find vertex v in vSet with minimum
distance - time complexity depends on how set of vertices is
implemented
• Boolean array ⇒ O(V ) per iteration
⇒ overall cost = O(E + V 2) =O(V 2)
• Array/list of vertices ⇒ O(V ) per iteration
⇒ overall cost = O(E + V 2) =O(V 2)
• Priority queue ⇒ O(log V ) per iteration
⇒ overall cost = O(E + V log V )
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Other Shortest Path Algorithms
For your curiosity:
• Floyd-Warshall Algorithm
• All-pairs shortest path
• Works for graphs with negative weights
• Bellman-Ford Algorithm
• Single-source shortest path
• Works for graphs with negative weights
• Can detect negative cycles
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Appendix
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm
4
10
7
5
2
6
8
3
2 4
1
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)
(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)
(p)Remove 0 from vSet (p)
(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)
(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]
dist[0] + 14 = 14 < dist[1]
dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0 ∞
1413
∞
9
∞
7
∞
2018
∞
2212
pred -1 -1
02
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)
(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13
∞
9
∞
7
∞
2018
∞
2212
pred -1
-1
0
2
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13
∞
9
∞
7
∞
2018
∞
2212
pred -1
-1
0
2
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13
∞
9
∞
7
∞
2018
∞
2212
pred -1
-1
0
2
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]
dist[0] + 9 = 9 < dist[2]
dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13
∞
9
∞
7
∞
2018
∞
2212
pred -1
-1
0
2
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13
∞
9
∞
7
∞
2018
∞
2212
pred -1
-1
0
2
-1
0
-1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
33
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9 ∞
7
∞
2018
∞
2212
pred -1
-1
0
2 -1
0 -1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9 ∞
7
∞
2018
∞
2212
pred -1
-1
0
2 -1
0 -1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9 ∞
7
∞
2018
∞
2212
pred -1
-1
0
2 -1
0 -1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]
dist[0] + 7 = 7 < dist[3]
dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9 ∞
7
∞
2018
∞
2212
pred -1
-1
0
2 -1
0 -1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9 ∞
7
∞
2018
∞
2212
pred -1
-1
0
2 -1
0 -1
0
-1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)
(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)
(p)Remove 3 from vSet (p)
(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)
(p)Explore 3 (p)
(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)
(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2 52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2
52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2
52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]
dist[3] + 10 = 17 ≮ dist[2]
dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2
52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2
52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0
2
52
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2
5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2
5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]
dist[3] + 15 = 22 < dist[5]
dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2
5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2
5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018
∞
2212
pred -1
-1
0
2 -1
0
-1
0 -1
51
-1
32
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2
5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)
(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)
(p)Remove 2 from vSet (p)
(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)
(p)Explore 2 (p)
(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)
(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
20
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]
dist[2] + 4 = 13 < dist[1]
dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞
14
13 ∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-1
0
2 -1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
55
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]
dist[2] + 3 = 12 < dist[5]
dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞
22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -1
3
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1]
[2]
[2] [3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)
(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)
(p)Remove 5 from vSet (p)
(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)
(p)Explore 5 (p)
(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
41
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)
(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
52
3
41
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
41
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]
dist[5] + 8 = 20 < dist[4]
dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7 ∞
2018 ∞22
12
pred -1
-10
2
-1
0
-1
0 -1
51 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)
(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)
(p)Remove 1 from vSet (p)
(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)
(p)Explore 1 (p)
(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
44
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)
(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0
2
44
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0
2
44
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]
dist[1] + 5 = 18 < dist[4]
dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞
20
18 ∞22
12
pred -1
-10
2
-1
0
-1
0
-1
5
1 -13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0] [1]
[1] [2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)
(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)
(p)Remove 4 from vSet (p)
(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)
(p)Explore 4 (p)
(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)
(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
41
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3] [4]
[4] [5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)
(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Dijkstra’s Algorithm Example
(p)Initialisation (p)(p)Remove 0 from vSet (p)(p)Explore 0 (p)(p)Relax along (0, 1, 14) (p)
dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]dist[0] + 14 = 14 < dist[1]
(p)Relax along (0, 2, 9) (p)
dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]dist[0] + 9 = 9 < dist[2]
(p)Relax along (0, 3, 7) (p)
dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]dist[0] + 7 = 7 < dist[3]
(p)Done with exploring 0 (p)(p)Remove 3 from vSet (p)(p)Explore 3 (p)(p)No need to consider (3, 0, 7) (p)
(0 has already been explored)
(p)Relax along (3, 2, 10) (p)
dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]dist[3] + 10 = 17 ≮ dist[2]
(p)Relax along (3, 5, 15) (p)
dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]dist[3] + 15 = 22 < dist[5]
(p)Done with exploring 3 (p)(p)Remove 2 from vSet (p)(p)Explore 2 (p)(p)No need to consider (2, 0, 9) (p)
(0 has already been explored)
(p)Relax along (2, 1, 4) (p)
dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]dist[2] + 4 = 13 < dist[1]
(p)No need to consider (2, 3, 10) (p)
(3 has already been explored)
(p)Relax along (2, 5, 3) (p)
dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]dist[2] + 3 = 12 < dist[5]
(p)Done with exploring 2 (p)(p)Remove 5 from vSet (p)(p)Explore 5 (p)(p)No need to consider (5, 2, 3) (p)
(2 has already been explored)
(p)No need to consider (5, 3, 15) (p)
(3 has already been explored)
(p)Relax along (5, 4, 8) (p)
dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]dist[5] + 8 = 20 < dist[4]
(p)Done with exploring 5 (p)(p)Remove 1 from vSet (p)(p)Explore 1 (p)(p)No need to consider (1, 0, 14) (p)
(0 has already been explored)
(p)No need to consider (1, 2, 4) (p)
(2 has already been explored)
(p)Relax along (1, 4, 5) (p)
dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]dist[1] + 5 = 18 < dist[4]
(p)Done with exploring 1 (p)(p)Remove 4 from vSet (p)(p)Explore 4 (p)(p)No need to consider (4, 1, 5) (p)
(1 has already been explored)
(p)No need to consider (4, 5, 8) (p)
(5 has already been explored)
(p)Done with exploring 4 (p)
(p)Finished (p)
0
1
2
3
4
5
14
9
7
5
4
3
10 15
8
0
1
2
3
3
0 2 5
2
0
1
3
5
5
2
3
4
1
0 2
4
4
1
5
while vSet is not empty:
find vertex v in vSet such that
dist[v] is minimal
and remove it from vSet
for each edge (v, w, weight) in G:
relax along (v, w, weight)
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]
[4]
[4]
[5]
[5]
dist 0
∞14
13
∞
9
∞
7
∞20
18
∞22
12
pred -1
-10
2
-1
0
-1
0
-15
1
-13
2
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Proof by induction.
Aim is to prove that before and after each iteration:
1 For all explored nodes s, dist[s] is shortest distance from source to s
2 For all unexplored nodes t, dist[t] is shortest distance from source to t
via explored nodes only
Ultimately, all nodes are explored, so by 1 :
• For all nodes v, dist[v] is the shortest distance from source to v
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Base case:
• Start of first iteration
• 1 holds, as there are no explored nodes
• 2 holds, because
• dist[source] = 0
• For all other nodes t, dist[t] = ∞
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step:
• Assume that 1 and 2 hold at the start of an iteration
• Let s be an unexplored node with minimum distance
• We claim that dist[ s] is the shortest distance from source to s
• If there is a shorter path to s via explored nodes only, then dist[ s] would
have been updated when exploring the predecessor of s on that path
• If there is a shorter path to s via an unexplored node u, then dist[ u] <
dist[s], which is a contradiction, since s has minimum distance out of all
unexplored nodes
src
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step:
• Assume that 1 and 2 hold at the start of an iteration
• Let s be an unexplored node with minimum distance
• We claim that dist[ s] is the shortest distance from source to s
• If there is a shorter path to s via explored nodes only, then dist[ s] would
have been updated when exploring the predecessor of s on that path
• If there is a shorter path to s via an unexplored node u, then dist[ u] <
dist[s], which is a contradiction, since s has minimum distance out of all
unexplored nodes
src s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step:
• Assume that 1 and 2 hold at the start of an iteration
• Let s be an unexplored node with minimum distance
• We claim that dist[ s] is the shortest distance from source to s
• If there is a shorter path to s via explored nodes only, then dist[ s] would
have been updated when exploring the predecessor of s on that path
• If there is a shorter path to s via an unexplored node u, then dist[ u] <
dist[s], which is a contradiction, since s has minimum distance out of all
unexplored nodes
src s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step:
• Assume that 1 and 2 hold at the start of an iteration
• Let s be an unexplored node with minimum distance
• We claim that dist[ s] is the shortest distance from source to s
• If there is a shorter path to s via explored nodes only, then dist[ s] would
have been updated when exploring the predecessor of s on that path
• If there is a shorter path to s via an unexplored node u, then dist[ u] <
dist[s], which is a contradiction, since s has minimum distance out of all
unexplored nodes
src s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step:
• Assume that 1 and 2 hold at the start of an iteration
• Let s be an unexplored node with minimum distance
• We claim that dist[ s] is the shortest distance from source to s
• If there is a shorter path to s via explored nodes only, then dist[ s] would
have been updated when exploring the predecessor of s on that path
• If there is a shorter path to s via an unexplored node u, then dist[ u] <
dist[s], which is a contradiction, since s has minimum distance out of all
unexplored nodes
src s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src s
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src
s
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src
s
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src
s
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src
s
s
explored
unexplored
COMP2521
25T2
Algorithm
Pseudocode
Example
Path Finding
Implementa-
tion Details
Analysis
Other
Algorithms
Appendix
Overview
Example
Correctness Proof
Correctness Proof Outline
Induction step (continued):
• dist[s] is the shortest distance from source to s
• After exploring s:
• 1 still holds for s, since dist[ s] is not updated while exploring s
• Same for all other explored nodes
• 2 still holds for all unexplored nodes t, since:
• If there is a shorter path to t via s then we would have updated dist[ t] while
exploring s
• Otherwise, we would not have updated dist[ t] and it would remain as it is
src
s
s
explored
unexplored


================================================================================

[18/24] week07lec02-msts.pdf
----------------------------

COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
COMP2521 25T2
Graphs (VII)
Minimum Spanning Trees
Sim Mautner
cs2521@cse.unsw.edu.au
minimum spanning trees
kruskal’s algorithm
prim’s algorithm
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Minimum Spanning Trees
A spanning tree of an undirected graph G
is a subgraph of G that contains all vertices of G,
that is connected and contains no cycles
A minimum spanning tree of an undirected weighted graph G
is a spanning tree of G that has
minimum total edge weight among all spanning trees of G
Applications:
Electrical grids, networks
Any situation where we want to connect nodes as cheaply as possible
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Minimum Spanning Trees
Example
0
1
2
3
4 8
2
2
1
64
Original graph
0
1
2
3
4 8
4
2
2
1
6
Spanning tree
0
1
2
3
4 8
6
2
2
1
4
Minimum spanning tree
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Minimum Spanning Tree Algorithms
Basic minimum spanning tree algorithms:
• Kruskal’s algorithm
• Prim’s algorithm
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Invented by
American mathematician, statistician, computer scientist
Joseph Kruskal in 1956

COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Algorithm:
1 Start with an empty graph
• With same vertices as original graph
2 Consider edges in increasing weight order
• Add edge if it does not form a cycle in the MST
3 Repeat until V − 1 edges have been added
Critical operations:
• Iterating over edges in weight order
• Checking if adding an edge would form a cycle
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Run Kruskal’s algorithm on this graph:
0 1
23
4
1
3
4
8
5
6
72
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
0 1
23
4
1
3
4
8
5
6
72
1
Add 0-1
0 1
23
4
1
3
4
8
5
6
72
1
2
Add 3-4
0 1
23
4
1
3
4
8
5
6
72
1
2
3
Add 0-3
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4
Don’t add 0-4
0 1
23
4
1
3
4
8
5
6
72
1
2
3
5
Don’t add 1-4
0 1
23
4
1
3
4
8
5
6
72
1
2
3
6
Add 2-3
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
MST:
0 1
23
4
1
3
4
8
5
6
72
1
2
3
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Pseudocode (Version 1)
kruskalMst(G):
Input: graph G with V vertices
Output: minimum spanning tree of G
mst = empty graph with V vertices
sortedEdges = sort edges of G by weight
for each edge e in sortedEdges:
add e to mst
if mst has a cycle:
remove e from mst
if mst has V − 1 edges:
return mst
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Pseudocode (Version 2)
kruskalMst(G):
Input: graph G with V vertices
Output: minimum spanning tree of G
mst = empty graph with V vertices
sortedEdges = sort edges of G by weight
for each edge (v, w, weight) in sortedEdges:
if there is no path between v and w in mst:
add edge (v, w, weight) to mst
if mst has V − 1 edges:
return mst
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
Proof by exchange argument.
Idea:
• Suppose there exists another algorithm A which makes a different set
of choices
• In this case, chooses a different set of edges for the MST
• Identify one choice made by A which is not made by our algorithm
• Show that by exchanging that choice with one of the choices made by
our algorithm, the solution does not become worse or less optimal
• In this case, the “solution” is the spanning tree produced
• In this case, an “optimal” solution is a spanning tree that costs as little as
possible
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
Sort the edges of G in increasing order.
Let K be the set of edges selected by Kruskal’s algorithm.
Let A be the set of edges selected by a different algorithm.
edges of G e1 e2 e3 e4 e5 e6 e7 e8 e9 . . .
edges of K e1 e2 e4 e5 e7 e9 . . .
edges of A e1 e2 e4 e7 e8 e9 . . .
G
e8
e3
e1
e6
e4
e2
e10
e5
e9
e11
e12
e7
e13
e14
K A
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
Consider the first edge that is chosen by K but not by A.
Add this edge to a copy of A (call it A′). This forms a cycle in A′.
Now find the highest-weight edge in this cycle and remove it from A′.
edges of G e1 e2 e3 e4 e5 e6 e7 e8 e9 . . .
edges of K e1 e2 e4 e5 e7 e9 . . .
edges of A e1 e2 e4 e7 e8 e9 . . .
edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .
G
e8
e3
e1
e6
e4
e2
e10
e5
e9
e11
e12
e7
e13
e14
K A
A′
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
Consider the first edge that is chosen by K but not by A.
Add this edge to a copy of A (call it A′). This forms a cycle in A′.
Now find the highest-weight edge in this cycle and remove it from A′.
edges of G e1 e2 e3 e4 e5 e6 e7 e8 e9 . . .
edges of K e1 e2 e4 e5 e7 e9 . . .
edges of A e1 e2 e4 e7 e8 e9 . . .
edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .
edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .
G
e8
e3
e1
e6
e4
e2
e10
e5
e9
e11
e12
e7
e13
e14
K
A
A′
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
Consider the first edge that is chosen by K but not by A.
Add this edge to a copy of A (call it A′). This forms a cycle in A′.
Now find the highest-weight edge in this cycle and remove it from A′.
edges of G e1 e2 e3 e4 e5 e6 e7 e8 e9 . . .
edges of K e1 e2 e4 e5 e7 e9 . . .
edges of A e1 e2 e4 e7 e8 e9 . . .edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .
edges of A′ e1 e2 e4 e5 e7 e8 e9 . . .
G
e8
e3
e1
e6
e4
e2
e10
e5
e9
e11
e12
e7
e13
e14
K
A
A′
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
K A A′
Now A′ is once again a spanning tree,
but it is more similar to K than A and it costs no more than A.
Repeat until A′ is identical to K . Each time we perform an exchange, the
spanning tree does not increase in cost.
Therefore, K is an optimal spanning tree (MST).
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Correctness
K A A′
Now A′ is once again a spanning tree,
but it is more similar to K than A and it costs no more than A.
Repeat until A′ is identical to K . Each time we perform an exchange, the
spanning tree does not increase in cost.
Therefore, K is an optimal spanning tree (MST).
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Example
Pseudocode
Analysis
Correctness
Time complexity
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Analysis - Time complexity
Analysis:
• Sorting edges is O(E · log E)
• Main loop has at most E iterations
• Different ways to check if adding an edge would form a cycle
• Cycle/path checking is O(V ) in the worst case (adjacency list)
⇒ overall cost = O(E · log E + E · V ) =O(E · V )
• Using union-find data structure is close to O(1) in the worst case
⇒ overall cost = O(E · log E + E) =O(E · log E) =O(E · log V )
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Developed by Vojtěch Jarník in 1930
and rediscovered by Robert C. Prim in 1957
Vojtěch Jarník
 (j Robert C. Prim j)
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Algorithm:
1 Start with an empty graph
2 Start from any vertex, add it to the MST
3 Choose cheapest edge s–t such that:
• s has been added to the MST, and
• t has not been added to the MST
and add this edge and the vertex t to the MST
4 Repeat previous step until V − 1 edges have been added
• Or until all vertices have been added
Critical operations:
• Finding the cheapest edge s–t such that
s has been added to the MST and t has not been added to the MST
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Example
Run Prim’s algorithm on this graph (starting at 0):
0 1
23
4
1
3
4
8
5
6
72
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Example
0 1
23
4
0
8
5
6
72
1
3
4
Start of step 1
0 1
23
4
0 1
3
4
8
5
6
72
1
End of step 1
0 1
23
4
0 1
6
72
1
3
4
8
5
Start of step 2
0 1
23
4
0 1
3
4
8
5
6
72
1
3
End of step 2
0 1
23
4
0 1
3
7
1
3
4
8
5
6
2
Start of step 3
2
0 1
3
4
4
8
5
6
7
1
3
2
End of step 3
2
0 1
3
4
4
8
5
1
3
2
8
6
7
Start of step 4
0 1
23
4
4
8
5
7
1
3
2
6
End of step 4
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Example
MST:
0 1
23
4
1
3
4
8
5
6
72
1
2
3
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Pseudocode
primMst(G):
Input: graph G with V vertices
Output: minimum spanning tree of G
mst = empty graph with V vertices
usedV = {0}
unusedE = edges of G
while |usedV| < V :
find cheapest edge e (s, t, weight) in unusedE such that
s ∈ usedV and t /∈ usedV
add e to mst
add t to usedV
remove e from unusedE
return mst
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Example
Pseudocode
Analysis
Comparison
Other
Algorithms
Appendix
Prim’s Algorithm
Analysis
Analysis:
• Algorithm considers at most E edges ⇒ O(E)
• Loop has V iterations
• In each iteration, finding the minimum-weighted edge:
• With set of edges is O(E)
⇒ overall cost = O(E + V · E) =O(V · E)
• With Fibonacci heap is O(log E) =O(log V )
⇒ overall cost = O(E + V · log V )
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Comparison
Kruskal’s algorithm vs Prim’s algorithm
Kruskal’s algorithm…
• is O(E · log V )
• uses array-based data structures
• performs better on sparse graphs
Prim’s algorithm…
• is O(E + V · log V )
• uses complex linked data structures
• in its most efficient implementation (Fibonacci heap)
• performs better on dense graphs
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Other MST Algorithms
• Boruvka’s algorithm
• Oldest MST algorithm
• Start with V separate components
• Join components using min cost links
• Continue until only a single component
• Worst-case time complexity: O(E · log V )
• Karger, Klein and Tarjan
• Based on Boruvka’s algorithm, but non-deterministic
• Randomly selects subset of edges to consider
• Time complexity: O(E) on average
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Appendix
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graph
Adding 0-1 would not create a cycleAdding 3-4 would not create a cycleAdding 0-3 would not create a cycleAdding 0-4 would create a cycleAdding 1-4 would create a cycleAdding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graph
Adding 0-1 would not create a cycle
Adding 3-4 would not create a cycleAdding 0-3 would not create a cycleAdding 0-4 would create a cycleAdding 1-4 would create a cycleAdding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycle
Adding 3-4 would not create a cycle
Adding 0-3 would not create a cycleAdding 0-4 would create a cycleAdding 1-4 would create a cycleAdding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycleAdding 3-4 would not create a cycle
Adding 0-3 would not create a cycle
Adding 0-4 would create a cycleAdding 1-4 would create a cycleAdding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycleAdding 3-4 would not create a cycleAdding 0-3 would not create a cycle
Adding 0-4 would create a cycle
Adding 1-4 would create a cycleAdding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4
5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycleAdding 3-4 would not create a cycleAdding 0-3 would not create a cycleAdding 0-4 would create a cycle
Adding 1-4 would create a cycle
Adding 2-3 would not create a cycleDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4
5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycleAdding 3-4 would not create a cycleAdding 0-3 would not create a cycleAdding 0-4 would create a cycleAdding 1-4 would create a cycle
Adding 2-3 would not create a cycle
Done - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Kruskal’s Algorithm Example
Original graphAdding 0-1 would not create a cycleAdding 3-4 would not create a cycleAdding 0-3 would not create a cycleAdding 0-4 would create a cycleAdding 1-4 would create a cycleAdding 2-3 would not create a cycle
Done - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
1
2
3
4 5
6
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graph
Start at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0 1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graph
Start at vertex 0
Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0
Choose cheapest edge out of these (in red)
Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0 1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)
Add 0-1 to MST
Choose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MST
Choose cheapest edge out of these (in red)
Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)
Add 0-3 to MST
Choose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
22
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MST
Choose cheapest edge out of these (in red)
Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
2
2
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)
Add 3-4 to MST
Choose cheapest edge out of these (in red)Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
2
2
4
8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MST
Choose cheapest edge out of these (in red)
Add 3-2 to MSTDone - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
2
2
4 8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)
Add 3-2 to MST
Done - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
2
2
4
8
6
7
6 2
COMP2521
25T2
Minimum
Spanning
Trees
Kruskal’s
Algorithm
Prim’s
Algorithm
Comparison
Other
Algorithms
Appendix
Kruskal’s Algorithm
Example
Prim’s Algorithm
Example
Prim’s Algorithm Example
Original graphStart at vertex 0Choose cheapest edge out of these (in red)Add 0-1 to MSTChoose cheapest edge out of these (in red)Add 0-3 to MSTChoose cheapest edge out of these (in red)Add 3-4 to MSTChoose cheapest edge out of these (in red)Add 3-2 to MST
Done - MST has 4 edges
0 1
23
4
1
3
4
8
5
6
72
0
1
3
4
1 1
3
4
8
5
3
3
4
8
5
6
2
2
4
8
6
7
6 2


================================================================================

[19/24] week08lec01-hash-tables.pdf
-----------------------------------

COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
COMP2521 25T2
Hash Tables
Sim Mautner
cs2521@cse.unsw.edu.au
maps
hash tables
hashing
collision resolution
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Keys and Values
A commonly desired abstraction
in computer science and in the real world
is the ability to map one kind of data to another,
in other words, map keys to values
Examples:
Map words to definitions
Map student numbers to names
Map people to favourite colors
Map characters to codes
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT
An map is an abstract data type
that stores key-value pairs, where keys are unique.
jas ⇒ green andrew ⇒ red
sasha ⇒ purple
jake ⇒ yellowkevin ⇒ blue
hayden ⇒ red
Note:
Maps are also called dictionaries, associative arrays or symbol tables.
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT
The Map ADT supports the following main operations:
insert
insert a key-value pair
(replace the value if the key already exists)
lookup
given a key, return its associated value
delete
given a key, delete its key-value pair
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
How to implement a map?
unordered array
ordered array
balanced binary search tree
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
unordered array
jas
green
andrew
red
sasha
purple
jake
yellow
kevin
blue
hayden
red
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Lookup: O(n)
Delete: O(n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
unordered array
jas
green
andrew
red
sasha
purple
jake
yellow
kevin
blue
hayden
red
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Lookup: O(n)
Delete: O(n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
ordered array
andrew
red
hayden
red
jake
yellow
jas
green
kevin
blue
sasha
purple
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Lookup: O(log n)
Delete: O(n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
ordered array
andrew
red
hayden
red
jake
yellow
jas
green
kevin
blue
sasha
purple
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Lookup: O(log n)
Delete: O(n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
balanced binary search tree
jake
yellow
hayden
red
andrew
red
kevin
blue
jas
green
sasha
purple
Performance?
Insert: O(log n)
Lookup: O(log n)
Delete: O(log n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
balanced binary search tree
jake
yellow
hayden
red
andrew
red
kevin
blue
jas
green
sasha
purple
Performance?
Insert: O(log n)
Lookup: O(log n)
Delete: O(log n)
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Motivation
Map ADT - Implementation
How to implement a map?
unordered array
ordered array
balanced binary search tree
hash table
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Tables
A hash table is a data structure
that implements a map.
It uses an array to store key-value pairs,
and a hash function that,
given a key, computes an index into the array
where the associated value can be found.
A good hash table implementation has an
average performance of O(1) for
insertion, lookup and deletion!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Tables
[0] [1] [2] [3] [4] [N - 2] [N - 1]
NO ITEM jake
yellow
NO ITEM sasha
purple
jas
green
NO ITEM andrew
red
...
index = 4
key = “jas” hash function
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Tables
Interface
/** Creates a new hash table */
HashTable HashTableNew(void);
/** Frees all memory allocated to the hash table */
void HashTableFree(HashTable ht);
/** Inserts a key-value pair into the hash table
If the key already exists, replaces the value */
void HashTableInsert(HashTable ht, Key key, Value value);
/** Returns true if the hash table contains the given key,
and false otherwise */
bool HashTableContains(HashTable ht, Key key);
/** Returns the value associated with the given key
Assumes that the key exists */
Value HashTableGet(HashTable ht, Key key);
/** Deletes the key-value pair associated with the given key */
void HashTableDelete(HashTable ht, Key key);
/** Returns the number of key-value pairs in the hash table */
int HashTableSize(HashTable ht);
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Tables
Example Usage
HashTable ht = HashTableNew();
HashTableInsert(ht, "jas", "green");
HashTableInsert(ht, "andrew", "red");
HashTableInsert(ht, "sasha", "purple");
HashTableInsert(ht, "jake", "yellow");
printf("jas' fav colour is %s\n", HashTableGet(ht, "jas")); // green
HashTableInsert(ht, "jas", "orange");
printf("jas' fav colour is %s\n", HashTableGet(ht, "jas")); // orange
HashTableDelete(ht, "jas");
if (!HashTableContains(ht, "jas")) {
printf("jas has no fav colour\n");
}
HashTableFree(ht);
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Hashing is the process of
mapping data of arbitrary size to fixed-size values
using a hash function
Applications:
Hash tables
Password storage and verification
Verifying integrity of messages and files
Database indexing
…many others
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
A hash function:
• Maps a key to an index in the range [0, N − 1]
• where N is the size of the array
• Must be cheap to compute
• Is deterministic
• Given the same key, will always return the same index
• Ideally, maps keys uniformly over the range of indices
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
Basic mechanism of hash functions:
int hash(Key key, int N) {
int val = convert key to 32-bit int
return val % N;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
Example
Simple hash function for ints:
int hash(int key, int N) {
return key % N;
}
Simple hash function for strings:
int hash(char *key, int N) {
int sum = 0;
for (int i = 0; key[i] != '\0'; i++) {
sum += key[i];
}
return sum % N;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
Example
More robust hash function for strings:
int hash(char *key, int N) {
int h = 0, a = 31415, b = 21783;
for (char *c = key; *c != '\0'; c++) {
a = a * b % (N - 1);
h = (a * h + *c) % N;
}
return h;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
Example
A real hash function (from PostgreSQL DBMS)…
int hash_any(unsigned char *k, register int keylen, int N) {
register uint32 a, b, c, len;
// set up internal state
len = keylen;
a = b = 0x9e3779b9;
c = 3923095;
// handle most of the key, in 12-char chunks
while (len >= 12) {
a += (k[0] + (k[1] << 8) + (k[2] << 16) + (k[3] << 24));
b += (k[4] + (k[5] << 8) + (k[6] << 16) + (k[7] << 24));
c += (k[8] + (k[9] << 8) + (k[10] << 16) + (k[11] << 24));
mix(a, b, c);
k += 12; len -= 12;
}
// collect any data from remaining bytes into a,b,c
mix(a, b, c);
return c % N;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hash Functions
Example
…where mix is defined as:
#define mix(a, b, c) \
{ \
a -= b; a -= c; a ^= (c >> 13); \
b -= c; b -= a; b ^= (a << 8); \
c -= a; c -= b; c ^= (b >> 13); \
a -= b; a -= c; a ^= (c >> 12); \
b -= c; b -= a; b ^= (a << 16); \
c -= a; c -= b; c ^= (b >> 5); \
a -= b; a -= c; a ^= (c >> 3); \
b -= c; b -= a; b ^= (a << 10); \
c -= a; c -= b; c ^= (b >> 15); \
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4
h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4
h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4
8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4
8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4
h(8) = 8
h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4
8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4
h(8) = 8
h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8
h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Example
Given a hash table with 11 slots
and the hash function h(k) =k % 11,
insert the following keys:
4 8 15 16 23 42
h(4) = 4h(8) = 8
h(15) = 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
4 8
index 4 already contains an item ⇒ collision!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Hashing
Hash Collisions
Often, the range of possible key values is
much larger than the range of indices ( [0, N − 1]),
so collisions are inevitable.
A hash collision occurs when for two keys x and y,
x ̸= y, but h(x) =h(y).
A hash table must have a method for resolving collisions.
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Implementa-
tion Details
Collision Resolution
Collision resolution methods:
• Separate chaining
• Each array slot contains a list of the items hashed to that index
• Allows multiple items in one slot
• Linear probing
• Check rest of array slots consecutively until an empty slot is found
• Double hashing
• Instead of checking slots consecutively, use an increment which is
determined by a secondary hash
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Implementa-
tion Details
Collision Resolution
Important statistic: load factor (α)
• Ratio of items to slots; α = M /N
• Useful when analysing collision resolution methods
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Resolve collisions by having multiple items per array slot.
Each array slot contains a linked list of items that are hashed to that index.
...
[0] [1] [2] [3] [4] [5] [N - 2] [N - 1]
Item
Item
Item
Item
Item
Item Item Item
Item
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2
h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2
h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2
h(4) = 4% 7 = 4
h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2
h(4) = 4% 7 = 4
h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4
h(16) = 16% 7 = 2
h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4
h(16) = 16% 7 = 2
h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2
h(42) = 42% 7 = 0
h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2
h(42) = 42% 7 = 0
h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42
8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42
8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0
h(8) = 8% 7 = 1
h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42
8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0
h(8) = 8% 7 = 1
h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1
h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Example
Given a hash table with 7 slots that uses separate chaining
and the hash function h(k) =k % 7,
insert the following keys:
23 4 16 42 8 15
h(23) = 23% 7 = 2h(4) = 4% 7 = 4h(16) = 16% 7 = 2h(42) = 42% 7 = 0h(8) = 8% 7 = 1
h(15) = 15% 7 = 1
[0] [1] [2] [3] [4] [5] [6]
42 8
15
23
16
4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
Assuming integer keys and values:
struct hashTable {
struct node **slots; // array of lists
int numSlots;
int numItems;
};
struct node {
int key;
int value;
struct node *next;
};
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
HashTable HashTableNew(void) {
HashTable ht = malloc(sizeof(*ht));
ht->slots = calloc(INITIAL_NUM_SLOTS, sizeof(struct node *));
ht->numSlots = INITIAL_NUM_SLOTS;
ht->numItems = 0;
return ht;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
void HashTableInsert(HashTable ht, int key, int value) {
if (/* load factor exceeds threshold */) {
// resize hash table
}
int i = hash(key, ht->numSlots);
ht->slots[i] = doInsert(ht, ht->slots[i], key, value);
}
struct node *doInsert(HashTable ht, struct node *list,
int key, int value) {
if (list == NULL) {
ht->numItems++;
return newNode(key, value);
} else if (list->key == key) {
list->value = value; // replace value
} else {
list->next = doInsert(ht, list->next, key, value);
}
return list;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
bool HashTableContains(HashTable ht, int key) {
int i = hash(key, ht->numSlots);
struct node *curr = ht->slots[i];
while (curr != NULL) {
if (curr->key == key) {
return true;
}
curr = curr->next;
}
return false;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
int HashTableGet(HashTable ht, int key) {
int i = hash(key, ht->numSlots);
struct node *curr = ht->slots[i];
while (curr != NULL) {
if (curr->key == key) {
return curr->value;
}
curr = curr->next;
}
error;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Implementation
void HashTableDelete(HashTable ht, int key) {
int i = hash(key, ht->numSlots);
ht->slots[i] = doDelete(ht, ht->slots[i], key);
}
struct node *doDelete(HashTable ht, struct node *list,
int key) {
if (list == NULL) {
return NULL;
} else if (list->key == key) {
struct node *newHead = list->next;
free(list);
ht->numItems--;
return newHead;
} else {
list->next = doDelete(ht, list->next, key);
return list;
}
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Example
Implementation
Analysis
Linear probing
Double hashing
Implementa-
tion Details
Separate Chaining
Analysis
Cost analysis:
• N array slots, M items
• Average list length L = M /N
• Best case: Items evenly distributed, so maximum list length is ⌈M /N ⌉
• Cost of insert/lookup/delete: O(M /N )
• Worst case: One list of length M
• Cost of insert/lookup/delete: O(M )
Average costs:
• If good hash and α ≤ 1, cost is O(1)
• If good hash and α > 1, cost is O(M /N )
• To avoid degrading perfomance, hash table should be resized when α ≈ 1
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Resolve collisions by finding a new slot for the item
• Each array slot stores a single item (unlike separate chaining)
• On a hash collision, try next slot, then next, until an empty slot is found
• Insert item into empty slot
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 No
Item
No
Item 18 9
insert k=22
h(22) = 2
insert k=14
h(14) = 4
insert k=8
h(8) = 8
Example: h(k) =k % 10
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Concrete data structures
Assuming integer keys and values:
struct hashTable {
struct slot *slots;
int numSlots;
int numItems;
};
struct slot {
int key;
int value;
bool empty;
};
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Constructor
HashTable HashTableNew(void) {
HashTable ht = malloc(sizeof(*ht));
ht->slots = malloc(INITIAL_CAPACITY * sizeof(struct slot));
for (int i = 0; i < ht->numSlots; i++) {
ht->slots[i].empty = true;
}
ht->numSlots = INITIAL_CAPACITY;
ht->numItems = 0;
return ht;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Insertion
Process for insertion:
1 If load factor exceeds threshold, resize
• Whether to do this or not is a design decision
2 Hash given key to get an index
3 Starting from this index, find first slot that either:
• Contains the given key, or
• Is empty
4 If the slot is empty, store the key and value, otherwise just replace the
value
This will be a task in the week 9 lab exercise!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Lookup
Process for lookup:
1 Hash given key to get an index
2 Starting from this index, find first slot that either:
• Contains the given key, or
• Is empty
3 If the slot contains the given key, return the value, otherwise error
• This is a design decision
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Lookup - Implementation
int HashTableGet(HashTable ht, int key) {
int i = hash(key, ht->numSlots);
for (int j = 0; j < ht->numSlots; j++) {
if (ht->slots[i].empty) break;
if (ht->slots[i].key == key) {
return ht->slots[i].value;
}
i = (i + 1) % ht->numSlots;
}
error;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Deletion
How to delete an item?
We can’t simply remove the item and be done,
as this can break the probe paths for other items,
for example:
h(k) =k % 10
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 14 4 18 No
Item
No
Item 11 No
Item
No
Item
No
Item 5 14 4 18 No
Item
deleting 24 (incorrectly)
Probe path for 14 and 4 is broken!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Deletion
Two primary methods for deletion:
1 Backshift
• Remove and re-insert all items between the deleted item and the next
empty slot
2 Tombstone
• Replace the deleted item with a “deleted” marker (AKA a tombstone) that:
• Is treated as empty during insertion
• Is treated as occupied during lookup
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Backshift Deletion - Example
Using the backshift method, delete 24 from this hash table:
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 14 4 18 No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Backshift Deletion - Example
Step 1: Remove 24
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item
No
Item 5 14 4 18 No
Item
Step 2: Re-insert 5
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item
No
Item 5 14 4 18 No
Item
Step 3: Re-insert 14
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 14 5 No
Item 4 18 No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Backshift Deletion - Example
Step 4: Re-insert 4
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 14 5 4 No
Item 18 No
Item
Step 5: Re-insert 18
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 14 5 4 No
Item 18 No
Item
This will be a task in the week 9 lab exercise!
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Tombstone Deletion - Example
Using the tombstone method, delete 14 from this hash table:
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 14 4 18 No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Tombstone Deletion - Example
After deleting 14:
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 DEL 4 18 No
Item
Search for 4:
No
Item 11 No
Item
No
Item 24 5 DEL 4 18 No
Item
h(4) = 4
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Tombstone Deletion - Example
Insert 15:
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
No
Item 11 No
Item
No
Item 24 5 DEL 4 18 No
Item
h(15) = 5
Result:
No
Item 11 No
Item
No
Item 24 5 15 4 18 No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Deletion - Remarks
Backshift method:
• Moves items closer to their hash index
• Thus reducing the length of their probe path
• Deletion becomes more expensive
Tombstone method:
• Fast
• But does not reduce probe path length
• Large number of deletions will cause tombstones to build up
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Clustering
Problem with linear probing: clustering
• Items tend to cluster together into long runs
• i.e., long contiguous regions that don’t contain empty slots
• Long runs are a problem:
• Insertions must travel to the end of a run
• Lookups of non-existent keys must travel to the end of a run
Causes of clustering:
• The longer a run becomes, the more likely it is to accrue additional items
• Two long runs can be connected together into an even longer run due to
the insertion of an item between them
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Clustering
Example (h(k) =k % 15):
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14]
Insert 1, 2, 3, 17, 18
1 2 3 17 18
Insert 7, 9, 22, 24, 37, 11
1 2 3 17 18 7 922 24 37 11
What happens if we insert/search for 8? How about if we insert 6?
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Insertion
Lookup
Deletion
Clustering
Analysis
Double hashing
Implementa-
tion Details
Linear Probing
Lookup - Analysis
Analysis of lookup:
• Hash function is O(1)
• Subsequent cost depends on probe path length
• Affected by load factor α = M /N
• Analysed by Donald Knuth in 1963
• Average cost for successful search = 1
2
(
1 + 1
1−α
)
• Average cost for unsuccessful search = 1
2
(
1 + 1
(1−α)2
)
Example costs (assuming large hash table):
load factor (α) 0.50 0.67 0.75 0.90
search hit 1.5 2.0 3.0 5.5
search miss 2.5 5.0 8.5 55.5
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Double hashing improves on linear probing:
• By using an increment which…
• is based on a secondary hash of the key
• ensures that all slots will be visited
(by using an increment which is relatively prime to N )
• Tends to reduce clustering ⇒ shorter probe paths
To generate relatively prime number:
• Set table size to prime, e.g., N = 127
• Ensure secondary hash function returns number in range [1, N − 1]
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example: Insert 22
Suppose h(k) =k % 7 and h2(k) =k % 3 + 1
h(22) = 22% 7 = 1⇒ collision!
h2(22) = 22% 3 + 1 = 2
[0] [1] [2] [3] [4] [5] [6]
No
Item 15 No
Item 10 4 No
Item
22
No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example: Insert 22
Suppose h(k) =k % 7 and h2(k) =k % 3 + 1
h(22) = 22% 7 = 1⇒ collision!
h2(22) = 22% 3 + 1 = 2
[0] [1] [2] [3] [4] [5] [6]
No
Item 15 No
Item 10 4 No
Item
22
No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example: Insert 22
Suppose h(k) =k % 7 and h2(k) =k % 3 + 1
h(22) = 22% 7 = 1⇒ collision!
h2(22) = 22% 3 + 1 = 2
[0] [1] [2] [3] [4] [5] [6]
No
Item 15 No
Item 10 4 No
Item
22
No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example: Insert 22
Suppose h(k) =k % 7 and h2(k) =k % 3 + 1
h(22) = 22% 7 = 1⇒ collision!
h2(22) = 22% 3 + 1 = 2
[0] [1] [2] [3] [4] [5] [6]
No
Item 15 No
Item 10 4 No
Item
22
No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example: Insert 22
Suppose h(k) =k % 7 and h2(k) =k % 3 + 1
h(22) = 22% 7 = 1⇒ collision!
h2(22) = 22% 3 + 1 = 2
[0] [1] [2] [3] [4] [5] [6]
No
Item 15 No
Item 10 4
No
Item
22 No
Item
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5
h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5
h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5
20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5
20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5
h(20) = 20% 11 = 9
h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5
20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5
h(20) = 20% 11 = 9
h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20
161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20
161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9
h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20
161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9
h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20
161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9
h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 2016
1 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 2016
1 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1
h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 2016
1 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1
h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161
42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161
42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1
h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161
42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1
h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161
42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1
h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42
15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42
15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42
15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42
15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Example
Given a hash table with 11 slots that uses double hashing,
with primary hash function h(k) =k % 11
and secondary hash function h2(k) =k % 5 + 1,
insert the following keys:
5 20 16 1 42 15
h(5) = 5% 11 = 5h(20) = 20% 11 = 9h(16) = 16% 11 = 5⇒ collision!
h2(16) = 16% 5 + 1 = 2
h(1) = 1% 11 = 1h(42) = 42% 11 = 9⇒ collision!
h2(42) = 42% 5 + 1 = 3
h(15) = 15% 11 = 4⇒ collision!
h2(15) = 15% 5 + 1 = 1
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
5 20161 42 15
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Concrete data structures
Assuming integer keys and values:
struct hashTable {
struct slot *slots;
int numSlots;
int numItems;
int hash2Mod;
};
struct slot {
int key;
int value;
bool empty;
};
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Constructor
HashTable HashTableNew(void) {
HashTable ht = malloc(sizeof(*ht));
ht->slots = malloc(INITIAL_CAPACITY * sizeof(struct slot));
for (int i = 0; i < ht->numSlots; i++) {
ht->slots[i].empty = true;
}
ht->numSlots = INITIAL_CAPACITY;
ht->numItems = 0;
ht->hash2Mod = findSuitableMod(INITIAL_CAPACITY);
return ht;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Insert - Implementation
void HashTableInsert(HashTable ht, int key, int value) {
if (/* load factor exceeds threshold */) {
// resize
}
int i = hash(key, ht->numSlots);
int inc = hash2(key, ht->hash2Mod);
for (int j = 0; j < ht->numSlots; j++) {
if (ht->slots[i].empty) {
ht->slots[i].key = key;
ht->slots[i].value = value;
ht->slots[i].empty = false;
ht->numItems++;
return;
}
if (ht->slots[i].key == key) {
ht->slots[i].value = value;
return;
}
i = (i + inc) % ht->numSlots;
}
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Lookup - Implementation
int HashTableGet(HashTable ht, int key) {
int i = hash(key, ht->numSlots);
int inc = hash2(key, ht->hash2Mod);
for (int j = 0; j < ht->numSlots; j++) {
if (ht->slots[i].empty) break;
if (ht->slots[i].key == key) {
return ht->slots[i].value;
}
i = (i + inc) % ht->numSlots;
}
error;
}
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Deletion
How to delete an item?
Backshift method is harder to implement
due to large increments
Tombstone method (lazy deletion) still works
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Double Hashing
Lookup - Analysis
Analysis of lookup:
• Hash function is O(1)
• Subsequent cost depends on probe path length
• Affected by load factor α = M /N
• Average cost for successful search = 1
α ln
(
1
1−α
)
• Average cost for unsuccessful search = 1
1−α
Example costs (assuming large hash table):
load factor (α) 0.50 0.67 0.75 0.90
search hit 1.4 1.6 1.8 2.6
search miss 1.5 2.0 3.0 5.5
Can be significantly better than linear probing
• Especially if table is heavily loaded
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Separate chaining
Linear probing
Double hashing
Example
Implementation
Analysis
Implementa-
tion Details
Collision Resolution
Summary
Collision resolution approaches:
• Separate chaining: Easy to implement, allows α > 1
• Linear probing: Fast if α ≪ 1, complex deletion
• Double hashing: Avoids clustering issues with linear probing
All approaches can be used to achieve O(1) performance on average,
assuming
• good hash function
• table is appropriately resized if load factor exceeds threshold
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Implementation Details
• How to resize a hash table?
• How to avoid two calls when performing lookup?
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Implementation Details
How do we resize a hash table?
• Hash function depends on the number of slots
• Items may not belong at the same index after resizing
• So all items must be re-inserted
• How much to resize by?
• Good strategy is to roughly double the number of slots every resizing
COMP2521
25T2
Motivation
Hash Tables
Hashing
Collision
Resolution
Implementa-
tion Details
Implementation Details
How to avoid two calls when performing lookup?
• HashTableGetassumes the given key exists, and generates an error if
it doesn’t
• So to look up an item which we don’t know exists, we must perform two
calls:
• One call to HashTableContainsto check for existence of key
• One call to HashTableGetto get the value
• Idea: Provide another function that allows user to specify a default value
to return if key does not exist
int HashTableGetOrDefault(HashTable ht, int key, int defaultValue);


================================================================================

[20/24] week08lec02-hash-table-applications.pdf
-----------------------------------------------

COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
COMP2521 25T2
Applications of Hash Tables
Sim Mautner
cs2521@cse.unsw.edu.au
set adt
counter adt
assorted problems
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Recap: Hash Tables
A hash table is a data structure that stores key-value pairs,
where keys are unique
jas ⇒ green andrew ⇒ red
sasha ⇒ purple
jake ⇒ yellowkevin ⇒ blue
hayden ⇒ red
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Recap: Hash Tables
Operations
Insert: Insert or replace key-value pair
Lookup: Given a key, get its associated value
Delete: Given a key, delete its key-value pair
Performance
Average-case: O(1)
Assuming good hash function and appropriate resizing
Worst-case: O(n)
If all keys hash to the same value (extremely unlikely with good hash)
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Applications of Hash Tables
Hash tables are used everywhere
due to their efficiency
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Set ADT
A set is an unordered collection of distinct elements
Operations
Insert: Insert an item into the set
Membership: Check if an item is in the set
Delete: Delete an item from the set
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Set ADT
Interface
/** Creates a new empty set */
Set SetNew(void);
/** Free memory used by set */
void SetFree(Set set);
/** Inserts an item into the set */
void SetInsert(Set set, int item);
/** Checks if an item is in the set */
bool SetContains(Set set, int item);
/** Deletes an item from the set */
void SetDelete(Set set, int item);
/** Returns the size of the set */
int SetSize(Set set);
/** Displays the set */
void SetShow(Set set);
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Set ADT
Implementations
Data Structure Insert Membership Delete
Unordered array O(n) O(n) O(n)
Ordered array O(n) O(log n) O(n)
Linked list O(n) O(n) O(n)
AVL tree O(log n) O(log n) O(log n)
Hash table ? ? ?
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Set ADT
How to implement the Set ADT using a hash table?
Insert
Insert item into the hash table as a key
Can use anything as the value
Contains
Check if the item exists in the hash table
Delete
Delete the item from the hash table
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Set ADT
Implementations
Data Structure Insert Membership Delete
Unordered array O(n) O(n) O(n)
Ordered array O(n) O(log n) O(n)
Linked list O(n) O(n) O(n)
AVL tree O(log n) O(log n) O(log n)
Hash table* O(1) O(1) O(1)
* average costs
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Counter ADT
A counter is a collection of items where
each distinct item has a count
Operations
Add: Add one to the count of an item
Get: Get the count of an item
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Counter ADT
Interface
/** Creates a new empty counter */
Counter CounterNew(void);
/** Free memory used by counter */
void CounterFree(Counter c);
/** Add one to the count of an item */
void CounterAdd(Counter c, int item);
/** Get the count of an item */
int CounterGet(Counter c, int item);
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Counter ADT
Implementations
Data Structure Add Get
Unordered array O(n) O(n)
Ordered array O(n) O(log n)
AVL tree O(log n) O(log n)
Hash table ? ?
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Counter ADT
How to implement the Counter ADT using a hash table?
Use hash table to map items to their counts
Add
Look up item’s count in the hash table
Then re-insert the item into the hash table
with count increased by 1
Get
Look up item’s count in the hash table
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Counter ADT
Implementations
Data Structure Add Get
Unordered array O(n) O(n)
Ordered array O(n) O(log n)
AVL tree O(log n) O(log n)
Hash table* O(1) O(1)
* average costs
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Two sum
Odd occurring
Anagram
Demo: Python
Dictionaries
Assorted Problems
Hash tables are often used as sets or counters
to solve problems efficiently
Examples
Two sum
Odd occurring elements
Anagram
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Two sum
Odd occurring
Anagram
Demo: Python
Dictionaries
Two Sum
Problem
Given an array of integers and a target sum S,
determine whether the array contains two integers
that sum to S.
Examples
Consider the array A = [12, 6, 3, 3, 7, 8]
twoSum(A, 13) ⇒ true
twoSum(A, 16) ⇒ false
twoSum(A, 3) ⇒ false
twoSum(A, 6) ⇒ true
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Two sum
Odd occurring
Anagram
Demo: Python
Dictionaries
Odd Occurring Elements
Problem
Given an array of integers,
return the number of distinct integers that
occur an odd number of times.
Examples
oddOccurring([4, 3, 4, 8, 8, 4]) ⇒ 2
oddOccurring([7, 2, 1, 5, 6, 9]) ⇒ 6
oddOccurring([1, 1, 3, 3, 7, 7]) ⇒ 0
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Two sum
Odd occurring
Anagram
Demo: Python
Dictionaries
Anagram
Problem
Given two strings s and t,
determine whether they are anagrams.
Two strings are anagrams if they contain
the same amount of each character.
Examples
anagram("abcde", "edcba") ⇒ true
anagram("abcde", "fdcba") ⇒ false
anagram("abcde", "abcdef") ⇒ false
anagram("aaabb", "ababa") ⇒ true
anagram("aaabb", "babab") ⇒ false
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Demo: Python Dictionaries
Bonus content!
Python has built-in syntax for hash tables,
which are called dictionaries.
COMP2521
25T2
Recap
Set ADT
Counter ADT
Assorted
Problems
Demo: Python
Dictionaries
Demo: Python Dictionaries
Operations
Create a dictionary
my_dictionary = {}
Insert a key-value pair
my_dictionary[key] = value
Check if a key exists
key in my_dictionary
Get the value associated with a key
my_dictionary[key]
Delete a key-value pair
del my_dictionary[key]


================================================================================

[21/24] week09lec01-priority-queues.pdf
---------------------------------------

COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort COMP2521 25T2
Priority Queues and Heaps
Sim Mautner
cs2521@cse.unsw.edu.au
priority queues
binary heaps
heap sort
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Motivation
We have learned about types of collections
where items are inserted and then
deleted based on insertion order
stack
last in, first out
queue
first in, first out
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Motivation
There are applications where
we want to process items based on priority
Examples:
Hospital triage
Incident management
Huffman coding
Dijkstra’s algorithm
Prim’s algorithm
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
A priority queue is an abstract data type
where each item has an associated priority.
andrew
30
sasha
25
jake
23
alice
4
bob
3front back
high low
priority
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
A priority queue supports the following main operations:
insert
insert an item with an associated priority
delete
delete (and return) the item with the highest priority
peek
get the item with the highest priority, without deleting it
is empty
check if the priority queue is empty
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
Depending on the application,
either a large priority value or small priority value
could be taken to mean “high priority” .
Here we’ll take a larger priority value to mean higher priority.
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
Interface
typedef struct pq *Pq;
/** Creates a new, empty pq */
Pq PqNew(void);
/** Frees memory allocated to a pq */
void PqFree(Pq pq);
/** Adds an item with priority to a pq */
void PqInsert(Pq pq, Item item, int priority);
/** Deletes and returns the item with the highest priority */
Item PqDelete(Pq pq);
/** Returns the item with the highest priority */
Item PqPeek(Pq pq);
/** Returns true if the pq is empty, false otherwise */
bool PqIsEmpty(Pq pq);
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
Example Usage
Pq pq = PqNew();
PqInsert(pq, "alice", 4);
PqInsert(pq, "bob", 3);
PqInsert(pq, "andrew", 30);
PqInsert(pq, "jas", 35);
printf("%s\n", PqDelete(pq)); // jas
printf("%s\n", PqDelete(pq)); // andrew
PqInsert(pq, "jake", 23);
PqInsert(pq, "sasha", 25);
printf("%s\n", PqPeek(pq)); // sasha
printf("%s\n", PqDelete(pq)); // sasha
printf("%s\n", PqDelete(pq)); // jake
printf("%s\n", PqDelete(pq)); // alice
printf("%s\n", PqDelete(pq)); // bob
if (PqIsEmpty(pq)) {
printf("the queue is empty\n");
}
PqFree(pq);
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queues
How to implement a priority queue?
unordered array
ordered array
linked list (unordered/ordered)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Unordered array implementation
unordered array
j alice j
j 4 j
j bob j
j 3 j
j andrew j
j 30 j
j jas j
j 35j
j jake j
j 23 j
j sasha j
j 25 j
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(1)
Delete: O(n)
Peek: O(n)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Unordered array implementation
unordered array
j alice j
j 4 j
j bob j
j 3 j
j andrew j
j 30 j
j jas j
j 35j
j jake j
j 23 j
j sasha j
j 25 j
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(1)
Delete: O(n)
Peek: O(n)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Ordered array implementation
ordered array
j bob j
j 3 j
j alice j
j 4 j
j jake j
j 23 j
j sasha j
j 25 j
j andrew j
j 30 j
j jas j
j 35j
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Delete: O(1)
Peek: O(1)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Ordered array implementation
ordered array
j bob j
j 3 j
j alice j
j 4 j
j jake j
j 23 j
j sasha j
j 25 j
j andrew j
j 30 j
j jas j
j 35j
[0] [1] [2] [3] [4] [5]
Performance?
Insert: O(n)
Delete: O(1)
Peek: O(1)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Unordered linked list implementation
unordered linked list
j alice j
j 4 j
j bob j
j 3 j
j andrew j
j 30 j
j jas j
j 35 j
j jake j
j 23 j
j sasha j
j 25 j NULL
Performance?
Insert: O(1)
Delete: O(n)
Peek: O(n)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Unordered linked list implementation
unordered linked list
j alice j
j 4 j
j bob j
j 3 j
j andrew j
j 30 j
j jas j
j 35 j
j jake j
j 23 j
j sasha j
j 25 j NULL
Performance?
Insert: O(1)
Delete: O(n)
Peek: O(n)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Ordered linked list implementation
ordered linked list
j jas j
j 35 j
j andrew j
j 30 j
j sasha j
j 25 j
j jake j
j 23 j
j alice j
j 4 j
j bob j
j 3 j NULL
Performance?
Insert: O(n)
Delete: O(1)
Peek: O(1)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Priority Queue
Ordered linked list implementation
ordered linked list
j jas j
j 35 j
j andrew j
j 30 j
j sasha j
j 25 j
j jake j
j 23 j
j alice j
j 4 j
j bob j
j 3 j NULL
Performance?
Insert: O(n)
Delete: O(1)
Peek: O(1)
Is empty: O(1)
COMP2521
25T2
Motivation
Priority
Queues
Implementations
Heaps
Heap Sort
Summary (so far)
Data Structure Insert Delete Peek Is Empty
Unordered array O(1) O(n) O(n) O(1)
Ordered array O(n) O(1) O(1) O(1)
Unordered linked list O(1) O(n) O(n) O(1)
Ordered linked list O(n) O(1) O(1) O(1)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Heaps
A heap is a tree-based data structure
which satisfies the heap property.
The heap property specifies how
values in the heap should be ordered,
and depends on the kind of heap:
In a max heap, the value in each node must be
greater than or equal to the values in its children.
In a min heap, the value in each node must be
less than or equal to the values in its children.
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Heaps
Example max heap:
28
23
21
3 18
11
8
15
13 6
0
In this lecture we will focus on max heaps.
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Heaps
There are many variants of heaps,
for example:
binary heap, binomial heap, Fibonacci heap,
leftist heap, pairing heap, soft heap,
…
We will consider just the binary heap.
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
A binary heap is a heap that
takes the form of a binary tree,
and satisfies the following properties:
heap property
as defined above
completeness property
all levels of the tree (except possibly the last) must be fully filled
and the last level must be filled from left to right
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
13
7
5 4
9
2
satisfies heap property
satisfies completeness
⇒ is a binary heap
13
7
5
9
2 8
satisfies heap property
does not satisfy completeness
⇒ is not a binary heap
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
A result of the completeness property
is that binary heaps always contain ⌊log2 n⌋ + 1levels
where n is the number of nodes.
This will be relevant for analysis.
n number of levels heap
1 1
2-3 2
4-7 3
… … …
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
…as arrays
Heaps are usually implemented with an array.
For a binary heap,
index 1 of the array contains the root item,
the next two indices contain the root’s children,
the next four indices contain the children of the root’s children,
and so on.
20
[1]
17
[2]
13
[4]
1
[5]
11
[3]
8
[6]
[0] [1] [2] [3] [4] [5] [6]
20 17 11 13 1 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
…as arrays
This arrangement gives rise to a useful property:
• For an item at index i:
• Its left child is located at index 2i
• Its right child is located at index 2i + 1
• Its parent is located at index ⌊i/2⌋
This makes it efficient to move “up” and “down” the tree.
20
[1]
17
[2]
13
[4]
1
[5]
11
[3]
8
[6]
[0] [1] [2] [3] [4] [5] [6]
20 17 11 13 1 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
…as arrays
Consider this max heap:
28
23
21
3 18
11
8 10
15
13
12
6
0
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
…as arrays
The heap as an array:
28
23 15
21 11 13 6
3 18 8 10 12
28 23 15 21 11 13 6 3 18 8 10 12
[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12]
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
Concrete data structures
Assuming integer items:
struct heap {
int *items;
int numItems;
int capacity;
};
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Heap Sort
Binary Heaps
Constructor
struct heap *heapNew(void) {
struct heap *heap = malloc(sizeof(struct heap));
heap->numItems = 0;
heap->capacity = INITIAL_CAPACITY;
heap->items = malloc((heap->capacity + 1) * sizeof(int));
return heap;
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Insertion is a two-step process:
1 Add new item at next available position on bottom level
i.e., after the last item
• New item may violate the heap property
2 Fix up: While new item is greater than its parent (and not at the root),
swap with its parent
• This re-organises items along the path to the root and restores the heap
property
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)Fix up
26 is greater than its parent (11) ⇒ swap26 is greater than its parent (20) ⇒ swap
Done
20
2626
17 11
2620
13 1 8
2611
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap26 is greater than its parent (20) ⇒ swap
Done
20
2626
17 11
2620
13 1 8 26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap26 is greater than its parent (20) ⇒ swap
Done
20
2626
17 11
2620
13 1 8 26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap
26 is greater than its parent (20) ⇒ swap
Done
20
2626
17 11
2620
13 1 8 26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap
26 is greater than its parent (20) ⇒ swap
Done
20
2626
17
11
26
20
13 1 8
26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap
26 is greater than its parent (20) ⇒ swap
Done
20
2626
17
11
26
20
13 1 8
26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)
Fix up
26 is greater than its parent (11) ⇒ swap
26 is greater than its parent (20) ⇒ swap
Done
20
26
26
17
1126
20
13 1 8
26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example: Insert 26
Insert 26 after the last item (8)Fix up
26 is greater than its parent (11) ⇒ swap26 is greater than its parent (20) ⇒ swap
Done
2026
26
17
1126
20
13 1 8
26
11
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
172530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
172530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
172530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|
j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17
1725253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
2530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|
j|17 is at the root - done j|
j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17
1725253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
2530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17
17
25253030
25173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
2530 25173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|
j|Add 25 after the last item j|
j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17
17
25253030
25
173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
2530
25
173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|
j|25 is greater than its parent (17) - swap j|
j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17
17
25253030
25
173025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
2530
25
173025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|
j|25 is greater than its parent (17) - swap j|
j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
1717
25
253030
25
17
3025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|
j|25 is at the root - done j|
j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
1717
25
253030
25
17
3025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 881313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025 813 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|
j|Add 8 after the last item j|
j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025
8
81313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|
j|8 is not greater than its parent (25) - done j|
j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025
8
81313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
66 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13 6 3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|
j|Add 6 after the last item j|
j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
6
6 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13
6
3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|
j|6 is not greater than its parent (17) - done j|
j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
6
6 3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13
6
3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
6
6
3017 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13
6
3017 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|
j|Add 30 after the last item j|
j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
6
6 30
17 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13
6 30
17 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|
j|30 is greater than its parent (17) - swap j|
j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
25
17
3025 8
8
1313
6
6 30
17 138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 25
17
3025
8
13
6 30
17 138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|
j|30 is greater than its parent (17) - swap j|
j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
2517
30
25 8
8
1313
6
6
30
17
138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 2517
30
25
8
13
6
30
17
138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|
j|30 is greater than its parent (25) - swap j|
j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
171725
25
3030
2517
30
25 8
8
1313
6
6
30
17
138
[0] [1] [2] [3] [4] [5] [6]
17
25
30 2517
30
25
8
13
6
30
17
138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|
j|30 is greater than its parent (25) - swap j|
j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17172525
30
30
251730
25
8
8
1313
6
6
30
17
138
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25 8
13
6
30
17
138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|
j|30 is at the root - done j|
j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
17172525
30
30
251730
25
8
8
1313
6
6
30
17
138
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25 8
13
6
30
17
138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
8
8
1313
6
6
30
17
138
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25 8
13
6
30
17
138
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|
j|Add 13 after the last item j|
j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
8
8
1313
6
6
30
17 13
8
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25 8
13
6
30
17 13
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|
j|13 is greater than its parent (8) - swap j|
j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
8
8
1313
6
6
30
17 13
8
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25 8
13
6
30
17 13
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|
j|13 is greater than its parent (8) - swap j|
j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
88
13
13
6
6
30
17
13
8
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25
8
13 6
30
17
13
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|
j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
88
13
13
6
6
30
17
13
8
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25
8
13 6
30
17
13
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Example
Insert the following items into an initially empty max heap:
17 25 8 6 30 13
j|Add 17 to the heap j|j|17 is at the root - done j|j|Add 25 after the last item j|j|25 is greater than its parent (17) - swap j|j|25 is at the root - done j|j|Add 8 after the last item j|j|8 is not greater than its parent (25) - done j|j|Add 6 after the last item j|j|6 is not greater than its parent (17) - done j|j|Add 30 after the last item j|j|30 is greater than its parent (17) - swap j|j|30 is greater than its parent (25) - swap j|j|30 is at the root - done j|j|Add 13 after the last item j|j|13 is greater than its parent (8) - swap j|j|13 is not greater than its parent (30) - done j|
1717252530
30
251730
25
8813
13
6
6
30
17
13
8
[0] [1] [2] [3] [4] [5] [6]
1725
30
251730
25
8
13 6
30
17
13
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Implementation
void heapInsert(struct heap *heap, Item it) {
if (heap->numItems == heap->capacity) {
// resize
}
heap->numItems++;
heap->items[heap->numItems] = it;
fixUp(heap->items, heap->numItems);
}
void fixUp(Item items[], int i) {
// while index i is not the root and
// item at index i is greater than its parent
while (i > 1 && items[i] > items[i / 2]) {
swap(items, i, i / 2);
i = i / 2;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Example
Implementation
Analysis
Deletion
PQ implementation
Heap Sort
Binary Heap Insertion
Analysis
Cost of insertion:
• Add new item after last item ⇒ O(1)
• Fix up considers one item on each level in the worst case
• Heap is a complete tree ⇒ O(log n) levels
• Therefore, worst-case time complexity is O(log n)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Deletion is a three-step process:
1 Replace root item with last item
• Last item = bottom-most, rightmost item
• Let this item be i
2 Remove last item
3 Fix down: While i is less than its greater child, swap it with its greater
child
• This restores the heap property
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20
20817
17
813
11
13
88
1 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20
20
817
17
813
11
13
88
1 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
2020
8
17
17
813
11
13
88
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
2020
8
17
17
813
11
13
88
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|
j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
2020
8
17
17
813
11
13
88
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|
j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20208
17
17
8
13
11
13
88
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|
j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20208
17
17
8
13
11
13
88
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|
j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|
j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20208
17
178
13 11
13
8
8
1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example: Delete from this max heap
j|Delete 20, replace with 8 j|j|Fix down j|
j|8 is less than its greater child (17) ⇒ swap j|j|8 is less than its greater child (13) ⇒ swap j|
j|Done j|
20208
17
178
13 11
138
8 1
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30
3082525817176131368866
25
8178866
13
66
6 17
88
8
[0] [1] [2] [3] [4] [5] [6]
30
825817613686
25
81786
13
6
6 17
8
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|
j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30
30
82525817176131368866
25
8178866
13
66
6 17
88
8
[0] [1] [2] [3] [4] [5] [6]
30
825817613686
25
81786
13
6
6 17
8
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|
j|Replace 30 with last item (8) j|
j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030
8
2525817176131368866
25
8178866
13
66
6 17
88 8
[0] [1] [2] [3] [4] [5] [6]
30
8
25817613686
25
81786
13
6
6 17
8 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|
j|8 is less than its greater child (25) - swap j|
j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030
8
2525817176131368866
25
8178866
13
66
6 17
88 8
[0] [1] [2] [3] [4] [5] [6]
30
8
25817613686
25
81786
13
6
6 17
8 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|
j|8 is less than its greater child (25) - swap j|
j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308
25
25817176131368866
25
8
178866
13
66
6 17
88 8
[0] [1] [2] [3] [4] [5] [6]
308
25
817613686 25
8
1786
13
6
6 17
8 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|
j|8 is less than its greater child (17) - swap j|
j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308
25
25817176131368866
25
8
178866
13
66
6 17
88 8
[0] [1] [2] [3] [4] [5] [6]
308
25
817613686 25
8
1786
13
6
6 17
8 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|
j|8 is less than its greater child (17) - swap j|
j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308
25
25817176131368866
258
17
8866
13
66
6
17
8
8 8
[0] [1] [2] [3] [4] [5] [6]
308
25
817613686 258
17
86
13
6
6
17
8
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30
25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|
j|8 is at a leaf - done j|
j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308
25
25817176131368866
258
17
8866
13
66
6
17
8
8 8
[0] [1] [2] [3] [4] [5] [6]
308
25
817613686 258
17
86
13
6
6
17
8
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25
17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|
j|Deleting 25 j|
j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825
25
817176131368866
258
17
8866
13
66
6
178
8
8
[0] [1] [2] [3] [4] [5] [6]
308
25
817613686 258
17
86
13
6
6
17
8
8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25
17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|
j|Replace 25 with last item (8) j|
j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525
8
17176131368866
258
17
8866
13
66
6
1788 8
[0] [1] [2] [3] [4] [5] [6]
30825
8
17613686 258
17
86
13
6
6
178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25
17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|
j|8 is less than its greater child (17) - swap j|
j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525
8
17176131368866
258
17
8866
13
66
6
1788 8
[0] [1] [2] [3] [4] [5] [6]
30825
8
17613686 258
17
86
13
6
6
178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25
17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|
j|8 is less than its greater child (17) - swap j|
j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258
17
176131368866
25817
8
866
13
66
6
1788 8
[0] [1] [2] [3] [4] [5] [6]
308258
17
613686 25817
8
6
13
6
6
178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25
17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|
j|8 is not less than its greater child (6) - done j|
j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258
17
176131368866
25817
8
866
13
66
6
1788 8
[0] [1] [2] [3] [4] [5] [6]
308258
17
613686 25817
8
6
13
6
6
178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17
13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|
j|Deleting 17 j|
j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525817
17
6131368866
258178
8
66
13
66
6
1788 8
[0] [1] [2] [3] [4] [5] [6]
308258
17
613686 25817
8
6
13
6
6
178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17
13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|
j|Replace 17 with last item (6) j|
j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308252581717
6
131368866
258178
8
66
13
66
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817
6
13686 25817
8
6
13
6 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17
13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|
j|6 is less than its greater child (13) - swap j|
j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308252581717
6
131368866
258178
8
66
13
66
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817
6
13686 25817
8
6
13
6 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17
13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|
j|6 is less than its greater child (13) - swap j|
j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525817176
13
1368866
258178
8
66 13
6
6
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176
13
686 25817
8
6 13
6
6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17
13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|
j|6 is at a leaf - done j|
j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525817176
13
1368866
258178
8
66 13
6
6
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176
13
686 25817
8
6 13
6
6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13
8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|
j|Deleting 13 j|
j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308252581717613
13
68866
258178
8
66 136
6
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176
13
686 25817
8
6 13
6
6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13
8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|
j|Replace 13 with last item (6) j|
j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258171761313
6
8866
258178
8
66 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817613
6
86 25817
8
6 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13
8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|
j|6 is less than its greater child (8) - swap j|
j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258171761313
6
8866
258178
8
66 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817613
6
86 25817
8
6 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13
8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|
j|6 is less than its greater child (8) - swap j|
j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308252581717613136
8
866
2581788
6
6 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176136
8
6 258178
6
136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13
8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|
j|6 is at a leaf - done j|
j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
30308252581717613136
8
866
2581788
6
6 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176136
8
6 258178
6
136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8
6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|
j|Deleting 8 j|
j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
303082525817176131368
8
66
25817886
6
1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
308258176136
8
6 258178
6
136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8
6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|
j|Replace 8 with last item (6) j|
j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258171761313688
6
6
258178866 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
3082581761368
6
2581786 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8
6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|
j|6 is at a leaf - done j|
j|Deleting 6 j|j|Delete 6 j|j|Heap is now empty j|
3030825258171761313688
6
6
258178866 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
3082581761368
6
2581786 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|
j|Deleting 6 j|
j|Delete 6 j|j|Heap is now empty j|
30308252581717613136886
6
258178866 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
3082581761368
6
2581786 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|
j|Delete 6 j|
j|Heap is now empty j|
303082525817176131368866
258178866 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817613686 2581786 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Example
Delete from the following max heap until it is empty:
30 25 17 13 8 6
j|Deleting 30 j|j|Replace 30 with last item (8) j|j|8 is less than its greater child (25) - swap j|j|8 is less than its greater child (17) - swap j|j|8 is at a leaf - done j|j|Deleting 25 j|j|Replace 25 with last item (8) j|j|8 is less than its greater child (17) - swap j|j|8 is not less than its greater child (6) - done j|j|Deleting 17 j|j|Replace 17 with last item (6) j|j|6 is less than its greater child (13) - swap j|j|6 is at a leaf - done j|j|Deleting 13 j|j|Replace 13 with last item (6) j|j|6 is less than its greater child (8) - swap j|j|6 is at a leaf - done j|j|Deleting 8 j|j|Replace 8 with last item (6) j|j|6 is at a leaf - done j|j|Deleting 6 j|j|Delete 6 j|
j|Heap is now empty j|
303082525817176131368866
258178866 1366
6 1788 8
[0] [1] [2] [3] [4] [5] [6]
30825817613686 2581786 136 6 178 8
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Implementation (I)
Item heapDelete(struct heap *heap) {
Item item = heap->items[1];
heap->items[1] = heap->items[heap->numItems];
heap->numItems--;
fixDown(heap->items, 1, heap->numItems);
return item;
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Implementation (II)
void fixDown(Item items[], int i, int N) {
// while index i has at least one child
while (2 * i <= N) {
// let j be the index of index i's left child
int j = 2 * i;
// if index i's right child is greater than its left child
if (j < N && items[j] < items[j + 1]) j++;
// if the item at index i is greater than or equal to both children
if (items[i] >= items[j]) break;
swap(items, i, j);
// move one level down the heap
i = j;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
Example
Implementation
Analysis
PQ implementation
Heap Sort
Binary Heap Deletion
Analysis
Cost of deletion:
• Replace root by item at end of array ⇒ O(1)
• Fix down considers two items on each level in the worst case
• Heap is a complete tree ⇒ O(log n) levels
• Therefore, worst-case time complexity is O(log n)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Time Complexity
Heap Sort
PQ Implementation
Concrete data structures
struct pq {
struct pqItem *items; // array of items
int numItems; // number of items stored
int capacity; // max number of items
};
struct pqItem {
Item item;
int priority;
};
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Time Complexity
Heap Sort
PQ Implementation
Constructor
Pq PqNew(void) {
Pq pq = malloc(sizeof(struct pq));
pq->numItems = 0;
pq->capacity = INITIAL_CAPACITY;
pq->items = malloc((pq->capacity + 1) * sizeof(struct pqItem));
return pq;
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Time Complexity
Heap Sort
PQ Implementation
Insertion
void PqInsert(Pq pq, Item it, int priority) {
if (pq->numItems == pq->capacity) {
// resize array
}
pq->numItems++;
pq->items[pq->numItems] = (struct pqItem){it, priority};
fixUp(pq->items, pq->numItems);
}
void fixUp(struct pqItem items[], int i) {
while (i > 1 && items[i].priority > items[i / 2].priority) {
swap(items, i, i / 2);
i = i / 2;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Time Complexity
Heap Sort
PQ Implementation
Deletion
Item PqDelete(Pq pq) {
Item item = pq->items[1].item;
pq->items[1] = pq->items[pq->numItems];
pq->numItems--;
fixDown(pq->items, 1, pq->numItems);
return item;
}
void fixDown(struct pqItem items[], int i, int N) {
while (2 * i <= N) {
int j = 2 * i;
if (j < N && items[j].priority < items[j + 1].priority) j++;
if (items[i].priority >= items[j].priority) break;
swap(items, i, j);
i = j;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Insertion
Deletion
PQ implementation
Time Complexity
Heap Sort
PQ Implementation
Time Complexity
Data Structure Insert Delete Peek Is Empty
Unordered array O(1) O(n) O(n) O(1)
Ordered array O(n) O(1) O(1) O(1)
Unordered linked list O(1) O(n) O(n) O(1)
Ordered linked list O(n) O(1) O(1) O(1)
Binary heap O(log n) O(log n) O(1) O(1)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heap sort is a sorting algorithm that uses a heap!
Method:
• Build up a heap within the original array
• This is called “heapify”
• Repeatedly delete from the heap
• Each time an element is deleted, place it at the end of the heap
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Adjusted indexing scheme:
• For an item at index i:
• Its children are at indices 2i + 1and 2i + 2
• Its parent is located at index ⌊(i − 1)/2⌋
20
[0]
17
[1]
13
[3]
1
[4]
11
[2]
8
[5]
4
[6]
[0] [1] [2] [3] [4] [5] [6]
20 17 11 13 1 8 4
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method
How to build up a heap within the original array?
Idea:
Use a similar idea to insertion sort!
Take first element and treat as a heap of size 1
Take next element and insert into the heap, which increases the size of the
heap by one
Repeat for remaining elements
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Example:
3 5 1 6 7 2 4
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1
Insert 5 into the heapInsert 1 into the heapInsert 6 into the heapInsert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
567
5
356
1
24
6
3
7
5
2
1
4
2
3
567
5356 124
63 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1
Insert 5 into the heap
Insert 1 into the heapInsert 6 into the heapInsert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
567
5
356
1
24
6
3
7
5
2
1
4
2
3
567
5
356 124
63 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1
Insert 5 into the heap
Insert 1 into the heapInsert 6 into the heapInsert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
5
67 5
3
56
1
24
6
3
7
5
2
1
4
2
3
5
67
5
3
56 124
63 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heap
Insert 1 into the heap
Insert 6 into the heapInsert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
5
67 5
3
56
1
24
6
3
7
5
2
1
4
2
3
5
67
5
3
56
1
24
63 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heap
Insert 1 into the heap
Insert 6 into the heapInsert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
5
67 5
3
56
1
24
6
3
7
5
2
1
4
2
3
5
67
5
3
56
1
24
63 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heap
Insert 6 into the heap
Insert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
3
5
67 5
3
56
1
24
6
3
7
5
2
1
4
2
3
5
67
5
3
56
1
24
6
3 75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heap
Insert 6 into the heap
Insert 7 into the heapInsert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
35
6
7 53
5
6
1
24 6
3 7
5
2
1
4
2
35
6
7
53
5
6
1
24
6
3
75 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heap
Insert 7 into the heap
Insert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
35
6
7 53
5
6
1
24 6
3 7
5
2
1
4
2
35
6
7
53
5
6
1
24
6
3 7
5 21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heap
Insert 7 into the heap
Insert 2 into the heapInsert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
356
7
535
6 1
24 6
3
7
5 2
1
4
2
356
7
535
6 1
24
6
3
7
5
21 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heapInsert 7 into the heap
Insert 2 into the heap
Insert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
356
7
535
6 1
24 6
3
7
5 2
1
4
2
356
7
535
6 1
24
6
3
7
5 2
1 42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heapInsert 7 into the heap
Insert 2 into the heap
Insert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
356
7
535
6
1
2
4 6
3
7
5
2
1 4
2
356
7
535
6
1
2
4
6
3
7
5
2
1
42
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heapInsert 7 into the heapInsert 2 into the heap
Insert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
356
7
535
6
1
2
4 6
3
7
5
2
1 4
2
356
7
535
6
1
2
4
6
3
7
5
2
1 4
2
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Example
Take first element and treat as heap of size 1Insert 5 into the heapInsert 1 into the heapInsert 6 into the heapInsert 7 into the heapInsert 2 into the heap
Insert 4 into the heap
[0] [1] [2] [3] [4] [5] [6]
356
7
535
6
12
4
6
3
7
5
2
1
4
2
356
7
535
6
12
4
6
3
7
5
2
1
4
2
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Implementation
void heapify(Item items[], int size) {
for (int i = 1; i < size; i++) {
fixUp(items, i);
}
}
void fixUp(Item items[], int i) {
while (i > 0 && items[i] > items[(i - 1) / 2]) {
swap(items, i, (i - 1) / 2);
i = (i - 1) / 2;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Example
Implementation
Analysis
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Up Method - Analysis
Analysis:
• Inserting into a heap is O(log n)
• Therefore, inserting n items into an initially empty heap is
O(log 1 +log 2 +log 3 +. . .+ log n) =O(log n!) =O(n log n)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method
Heapify can be implemented more efficiently
by performing a fix down on every element in the
first half of the array in reverse (i.e., from right to left)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Example:
3 5 1 6 7 2 4
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1
Perform fix down on 1Perform fix down on 5Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7
5
76
1
4
6
3
7
5
2 4
1
37
576 14
6
3
7
5
2 4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1
Perform fix down on 1
Perform fix down on 5Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7
5
76
1
4
6
3
7
5
2 4
1
37
576
1
4
6
3
7
5
2 4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1
Perform fix down on 1
Perform fix down on 5Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7
5
76 1
4 6
3
7
5
2
4
1
37
576 1
4
6
3
7
5
2
4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1Perform fix down on 1
Perform fix down on 5
Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7
5
76 1
4 6
3
7
5
2
4
1
37
5
76 1
4
6
3
7
5
2
4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1Perform fix down on 1
Perform fix down on 5
Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7 5
7
6 1
4 6
3 7
5 2
4
1
37
5
7
6 1
4
6
3 7
5 2
4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1Perform fix down on 1Perform fix down on 5
Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7 5
7
6 1
4 6
3 7
5 2
4
1
3
7
5
7
6 1
4
6
3 7
5 2
4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Example
Treat each element in the second half of the array
as a heap of size 1Perform fix down on 1Perform fix down on 5
Perform fix down on 3
[0] [1] [2] [3] [4] [5] [6]
3
7
57
6
1
4
6
3
7
5 2
4
1
3
7
57
6
1
4
6
3
7
5 2
4
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Implementation
void heapify(Item items[], int size) {
for (int i = size / 2 - 1; i >= 0; i--) {
fixDown(items, i, size - 1);
}
}
void fixDown(Item items[], int i, int N) {
while (2 * i + 1 <= N) {
int j = 2 * i + 1;
if (j < N && items[j] < items[j + 1]) j++;
if (items[i] >= items[j]) break;
swap(items, i, j);
i = j;
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
Example
Implementation
Analysis
De-Heapify
Analysis
Properties
Heap Sort
Heapify, Fix Down Method - Analysis
This implementation of heapify is O(n).
Why?
Most of the items in a heap are on the lowest levels.
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify
After the array has been heapified,
repeatedly delete from the heap, each time
placing the deleted item at the end of the heap.
Example:
7 6 4 3 5 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7
16251423121
6
53212
4
13
3
24
5
15
2
6
1
7
7
16251423121
6
5321
4
1
3
2
5
1
2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7
1
6251423121
6
53212
4
13
3
24
5
15
2
6 1
7
7
1
6251423121
6
5321
4
1
3
2
5
1
2
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71
6
251423121 6
5
3212
4
13
3
24 5
1
5
2
6 1
7
71
6
251423121
6
5
321
4
1
3
2 5
1 2
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71
6
251423121 6
5
3212
4
13
3
24 5
1
5
2
6 1
7
71
6
251423121
6
5
321
4
1
3
2 5
1 2
1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
716
2
51423121 6
5
3212
4
13
3
24 5
1
5 2
6
1
7
716
2
51423121
6
5
321
4
1
3
2 5
1
2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7162
5
1423121 65
3
212
4
13 3
2
4 5
1
5 2
6
1
7
7162
5
1423121
65
3
21
4
1
3
2
5
1
2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7162
5
1423121 65
3
212
4
13 3
2
4 5
1
5 2
6
1
7
7162
5
1423121
65
3
21
4
1
3
2
5
1
2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625
1
423121 65
3
212
4
13 3
2
4 51
5
2
6
1
7
71625
1
423121
65
3
21
4
1
3
2
51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
716251
4
23121 65
3
212 4
1
3 3
2
4 51
5
2
6
1
7
716251
4
23121
65
3
21 4
1
3
2
51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
716251
4
23121 65
3
212 4
1
3 3
2
4 51
5
2
6
1
7
716251
4
23121
65
3
21 4
1
3
2
51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7162514
2
3121 65
3
212 4
1
3 32
4
51
5
2
6
1
7
7162514
2
3121
65
3
21 4
1
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142
3
121 653
2
12 4
1
3 32
4
51
5
2
6
1
7
71625142
3
121
653
2
1 4
1
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142
3
121 653
2
12 4
1
3 32
4
51
5
2
6
1
7
71625142
3
121
653
2
1 4
1
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
716251423
1
21 653
2
12 41
3
32
4
51
5
2
6
1
7
716251423
1
21
653
2
1 41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7162514231
2
1 6532
1
2 41
3
32
4
51
5
2
6
1
7
7162514231
2
1
6532
1
41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
7162514231
2
1 6532
1
2 41
3
32
4
51
5
2
6
1
7
7162514231
2
1
6532
1
41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142312
1
65321
2
41
3
32
4
51
5
2
6
1
7
71625142312
1
65321 41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142312
1
65321
2
41
3
32
4
51
5
2
6
1
7
71625142312
1
65321 41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142312
1
65321
2
41
3
32
4
51
5
2
6
1
7
71625142312
1
65321 41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Example
Delete 7 from the heap
Perform fix down on 1 to restore heap
Delete 6 from the heap
Perform fix down on 2 to restore heap
Delete 5 from the heap
Perform fix down on 1 to restore heap
Delete 4 from the heap
Perform fix down on 2 to restore heap
Delete 3 from the heap
Perform fix down on 1 to restore heap
Delete 2 from the heap
Perform fix down on 1 to restore heap
Delete 1 from the heap
Done
[0] [1] [2] [3] [4] [5] [6]
71625142312
1
65321
2
41
3
32
4
51
5
2
6
1
7
716251423121
65321 41
32 51 2 1
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Implementation
void deheapify(Item items[], int size) {
while (size > 1) {
swap(items, 0, size - 1);
size--;
fixDown(items, 0, size - 1);
}
}
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Example
Implementation
Analysis
Analysis
Properties
Heap Sort
De-Heapify - Analysis
Analysis:
• Deleting from a heap is O(log n)
• Therefore, deleting all items from a heap of size n is
O(log n + log(n − 1) +log(n − 2) +. . .+ log 1) =O(log n!) =O(n log n)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Analysis
Analysis of heap sort:
• Heapify is O(n)
• De-heapify is O(n log n)
• Therefore, heap sort is O(n log n)
COMP2521
25T2
Motivation
Priority
Queues
Heaps
Heap Sort
Heapify (Fix Up)
Heapify (Fix Down)
De-Heapify
Analysis
Properties
Heap Sort
Properties
Unstable
Due to long-range swaps
Non-adaptive
O(n log n) on average and if array is sorted
In-place
Sorting is done within original array; does not use temporary arrays


================================================================================

[22/24] week09lec02-tries.pdf
-----------------------------

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
COMP2521 25T2
Tries
Sim Mautner
cs2521@cse.unsw.edu.au
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Motivation
Many applications require
searching through a set of strings
with a pattern
Examples:
Autocomplete
Predictive text
Approximate string matching
Spell checking
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Motivation
Autocomplete

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Motivation
Predictive text
For example, pressing “4663”
can be interpreted as the word
good, home, hood or hoof
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Motivation
How can we implement a set of strings
using data structures covered so far?
AVL tree
Performance: O(log n) worst case
Hash table
Performance: O(1) average case
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Motivation
AVL trees and hash tables are efficient, but…
…they are not efficient when searching for a pattern
Possible solution: tries
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Tries
A trie…
• is a tree data structure
• used to represent a set of strings
• e.g., all the distinct words in a document, a dictionary, etc.
• we will call these strings keys or words
• supports string matching queries in O(m) time
• where m is the length of the string being searched for
Note: the word trie comes from retrieval, but pronounced as “try” not “tree”
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Tries
Example:
Keys in
the trie:
ace
aces
ape
apes
app
apply
early
earth
east
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Tries
Important features of tries:
• Each link represents an individual character
• A key is represented by a path in the trie
• Each node can be tagged as a “finishing” node
• A “finishing” node marks the end of a key
• Each node may contain data associated with key
• Unlike a search tree, the nodes in a trie do not store their associated key
• Instead, keys are implicitly defined by their position in the trie
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Representation
Assuming alphabetic strings:
#define ALPHABET_SIZE 26
struct node {
struct node *children[ALPHABET_SIZE];
bool finish; // marks the end of a key
Data data; // data associated with key
};
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Representation
Example
Consider this trie:
s
e
a l
l
s
h
e
COMP2521
25T2
Motivation
Tries
Representation
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Representation
Example
Concrete representation:
(f = finishing node)
s
e h
a l e
f
l
f
s
f
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Insertion
Process for insertion:
• Start at the root
• For each character c in the key (from left to right):
• If there is no child node corresponding to c, create one
• Descend into the child node corresponding to c
• Mark the resulting node as a finishing node and insert data (if any)
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Insertion
Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Insertion
Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Insertion
Pseudocode
Recursive method:
trieInsert(t, key, data):
Input: trie t
key of length m and associated data
Output: t with key and data inserted
if t is empty:
t = new node
if m = 0:
t->finish = true
t->data = data
else:
first = key[0]
rest = key[1..m - 1] // i.e., slice off first character from key
t->children[first] = trieInsert(t->children[first], rest, data)
return t
exercise Try writing an iterative version.
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Search is similar to insertion:
• Start at the root
• For each character c in the key (from left to right):
• If there is no child node corresponding to c, return false
• Descend into the child node corresponding to c
• If the resulting node is a finishing node, then return true, otherwise
return false
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
Search for “early”
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
4
5
jFound! j
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
Search for “early”
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
4
5
jFound! j
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
Search for “apple”
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
4
Not found - node for “appl” has no child node for ‘e’
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
Search for “apple”
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
4
Not found - node for “appl” has no child node for ‘e’
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
jSearch for “ear” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
Not found - node for “ear” is not a finishing node
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Example
jSearch for “ear” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
1
2
3
Not found - node for “ear” is not a finishing node
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Search
Pseudocode
Recursive method:
trieSearch(t, key):
Input: trie t
key of length m
Output: true if key is in t
false otherwise
if t is empty:
return false
else if m = 0:
return t->finish = true
else:
first = key[0]
rest = key[1..m - 1]
return trieSearch(t->children[first], rest)
exercise Try writing an iterative version.
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Deletion is trickier…
• Can simply find node corresponding to given key
and mark it as a non-finishing node
• …but this can leave behind dead branches
• i.e., branches that don’t contain any finishing nodes
• dead branches waste memory
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example of dead branch:
s
e
a l
l
h
e
l
l
o
r
e
delete
“shore”
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Process for deletion:
• Find node corresponding to given key
• If node doesn’t exist, do nothing
• Mark the node as a non-finishing node
• While current node is not a finishing node and has no child nodes:
• Delete current node and move up to parent
• Handled recursively
• Be careful not to delete the root node!
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “ace” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - node for “ace” is no longer marked as a finishing node
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “ace” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - node for “ace” is no longer marked as a finishing node
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “apply” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - deleted nodes corresponding to “apply” and “appl”
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “apply” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - deleted nodes corresponding to “apply” and “appl”
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “earth” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - deleted nodes corresponding to “earth” and “eart”
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Example
jDelete “earth” j
a
c
e
s
p
e
s
p
l
y
e
a
r
l
y
t
h
s
t
Deleted - deleted nodes corresponding to “earth” and “eart”
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Pseudocode (I)
Recursive method:
trieDelete(t, key):
Input: trie t
key of length m
Output: t with key deleted
return doTrieDelete(t, key, true)
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Trie Deletion
Pseudocode (II)
doTrieDelete(t, key, isRoot):
Input: trie t
key of length m
boolean isRoot indicating if t is the root node
Output: t with key deleted
if t is empty:
return t
else if m = 0:
t->finish = false
else:
first = key[0]
rest = key[1..m - 1]
t->children[first] = doTrieDelete(t->children[first], rest, false)
if isRoot = false and t->finish = false and t has no child nodes:
return NULL
else:
return t
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Analysis
Analysis of standard trie:
• O(m) insertion, search and deletion
• where m is the length of the given key
• each of these needs to examine at most m nodes
• O(nR) space
• where n is the total number of characters in all keys
• where R is the size of the underlying alphabet (e.g., 26)
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Simple trie representation consumes an enormous amount of memory
• Each node contains ALPHABET_SIZEpointers
• If keys are alphabetic, then this is 26 pointers…
• …which is 8 × 26 = 208bytes on an 64-bit machine!
• If keys can contain any ASCII character, then this is 128 pointers!
• Even if trie contains many keys, most child pointers will be unused
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Different representations exist to reduce memory usage at the cost of
increased running time:
• Use a singly linked list to store child nodes
• Alphabet reduction - break each character into smaller chunks, and treat
these chunks as the characters
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Linked list of children
One technique to reduce memory usage:
Have each node store a linked list of its children
instead of an array of ALPHABET_SIZEpointers
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Linked list of children
struct node {
struct child *children;
bool finish;
Data data;
};
struct child {
char c;
struct node *node;
struct child *next;
};
Instead of:
e h
… …
We have:
e h ×
… …
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Linked list of children
Consider the following trie:
a
n t
e
b
e i
d
o
w
d
o
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Linked list of children
Its concrete representation:
a b d ×
n t ×
× e ×
×
e i o ×
× d ×
×
w ×
×
o ×
×
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Left-child right-sibling binary tree
We can simplify this representation
by merging each linked list node with its corresponding trie node
This produces the left-child right-sibling binary tree representation
struct node {
char c;
struct node *children;
struct node *sibling;
bool finish;
Data data;
};
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Left-child right-sibling binary tree
Concrete representation of above trie:
a
n t
e
b
e i
d
o
w
d
o
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Left-child right-sibling binary tree
Analysis:
• This representation uses much less space
• Each node just stores one extra pointer to its sibling
instead of ALPHABET_SIZEpointers
• But this is at the expense of running time
• Need to traverse up to ALPHABET_SIZEnodes before reaching desired
child
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Alphabet reduction
Another technique to reduce memory usage:
alphabet reduction
Break each 8-bit character into two 4-bit nybbles
This reduces the branching factor,
i.e., the number of pointers in each node
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Alphabet reduction
For example, the word “sea” consists of the following bytes:
s e a
01110011 01100101 01100001
We break it into 4-bit nybbles like so:
s e a
01110011 01100101 01100001
0111 0011 0110 0101 0110 0001
Instead of storing the word “sea” , we now insert the following word:
0111 0011 0110 0101 0110 0001
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Alphabet reduction
Analysis:
• This representation uses much less space
• Much fewer pointers per node
• But this is at the expense of running time
• Path to each key is twice as long - lookups need to visit twice as many
nodes
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Compressed tries
Another technique to reduce memory usage:
use a compressed trie
In a compressed trie, each node contains ≥ 1 character
Obtained by merging non-branching chains of nodes
Specifically, non-finishing nodes with only one child are merged with their child
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Linked list of
children
Binary tree
Alphabet reduction
Compressed tries
Applications
Appendix
Variants
Compressed tries

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Word finding
Autocomplete
Predictive text
Appendix
Applications
Word finding
Idea:
Given a document, preprocess it
by storing all words in a trie,
and for each word, store the location of all its occurrences
When user searches for a word,
can query the trie instead of scanning entire document
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Word finding
Autocomplete
Predictive text
Appendix
Applications
Word finding

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Word finding
Autocomplete
Predictive text
Appendix
Applications
Autocomplete
Autocomplete
Given a series of letters,
find all words that start with it

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Word finding
Autocomplete
Predictive text
Appendix
Applications
Predictive text
Predictive text
Given a series of button presses (e.g., on a keypad),
where each button can represent multiple letters,
find all possible matching words

COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Appendix
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e
COMP2521
25T2
Motivation
Tries
Insertion
Search
Deletion
Analysis
Variants
Applications
Appendix
Insertion example
Trie Insertion Example
Insert the following words into an initially empty trie:
sea shell sell shore she
s
e
a
s
e
a
h
e
l
l
s
e
a l
l
h
e
l
l
s
e
a l
l
h
e
l
l
o
r
e


================================================================================

[23/24] week10lec01-course-review-exam.pdf
------------------------------------------

COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
COMP2521 25T2
Course Review and Exam
Sim Mautner
cs2521@cse.unsw.edu.au
course review
final exam
course evaluation
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Course Review
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Course Goals
COMP1511
• gets you thinking like a programmer
• solve problems by developing programs
• express your ideas in the C language
COMP2521
• gets you thinking like a computer scientist
• know a set of fundamental techniques/structures
• able to reason about their applicability/effectiveness
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Acquired Knowledge
• data structures: trees, graphs, hash tables, heaps, tries
• data structure/algorithm analysis: time/space complexity
• sorting and searching techniques
• graph algorithms
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Acquired Skills
By the end of this course, you should be able to:
• Implement solutions to a wider range of problems
• Analyse performance characteristics of algorithms
• Analyse performance characteristics of data structures
• Make decisions about appropriate data structures and algorithms
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus Detail
(I)
For each specific data type, we considered:
• implementation in C (data structures, functions)
• operations (e.g., insert, search, delete, traverse)
• analysis of efficiency of operations
• applications of the data type
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus Detail
(II)
Recursion
Analysis of algorithms
• empirical analysis
• theoretical analysis
• time complexity and big-O
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus Detail
(III)
Sorting algorithms
• properties
• time/space complexity
• stability
• adaptability
• elementary sorts
• selection sort
• bubble sort
• insertion sort
• divide and conquer sorts
• merge sort
• quick sort
• non-comparison-based sorts
• radix sort
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus
(IV)
ADTs
• interface vs. implementation
• defining ADTs in C
• stacks
• queues
• sets
Trees
• tree terminology
• tree properties
• binary search trees
• balancing binary search trees
• avl trees
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus
(V)
Graphs
• graph terminology/properties
• graph representations
• graph traversal
• bfs/dfs
• graph problems
• cycle checking
• connected components
• hamiltonian/eulerian paths/circuits
• warshall’s algorithm
• dijkstra’s algorithm
• minimum spanning trees
• kruskal’s algorithm
• prim’s algorithm
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus
(VI)
Hash tables
• hash functions
• collision resolution
• separate chaining
• linear probing
• double hashing
• applications
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Syllabus
(VII)
Priority queues and heaps
• implementations
• binary heaps
• heap sort
Tries
• implementations
• applications
COMP2521
25T2
Course
Review
Outline
Syllabus
Assessment
Final Exam
Course
Evaluation
Final Words
Course Assessment
Assessments:
• 15% labs
• 10% quizzes
• 15% assignment 1
• 15% assignment 2
• 45% final exam
To pass COMP2521, you must:
• score at least 50/100 overall
• pass the exam hurdle (see next section)
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Final Exam
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Final Exam
• 3-hour in-person exam
• 10 minutes reading time
• 3 hours working time
• Wednesday 20th August
• Invigilated and held in CSE labs
• Closed book - no materials allowed
• Code/pseudocode for main data structures and algorithms will be
available
• C quick-reference will be available
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Final Exam
• Two sessions: morning and afternoon
• You have been asked to indicate a preference via email
• Exam organisers will allocate you to your preferred session if possible
• You will receive an email with your allocation early Week 11
• Students with a clash will be pre-allocated to appropriate session
• To prevent communication between students in morning and afternoon
sessions:
• Students in morning session cannot leave early
• Students in afternoon session will be corralled before the end of the morning
session
• Students in afternoon session are not allowed to be late
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Clashes
• UNSW policy is that you may be required to take two exams in one day
• Students with clashes will be automatically allocated to a non-clashing
session by the CSE Exams team
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Conditions
• UNSW on-campus exam rules apply
• see https://www.student.unsw.edu.au/exam/rules
• Items/materials:
• You must bring your UNSW student ID card
• Must not be expired
• You may bring a clear water bottle
• You may bring a clear pencil case (or plastic sleeve) with pens/pencils
• You may not bring your own keyboard/mouse or other hardware
• All other items must be placed in your bag
• Phone, smart watch, other electronic devices must be switched off and
placed in your bag
• Deliberate violation of exam conditions will be treated as serious
misconduct and may be referred to the SCIU
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Environment
• Restricted environment - not your CSE account
• No access to Internet
• Uh oh, no ChatGPT!
• No access to any of your files
• Available editors: gedit, VSCode, vim
• All come with syntax highlighting
• VSCode comes with clangd extension - provides IntelliSense
• Standard CSE lab machine commands available
• make, clang, gdb, valgrind, man
• Calculator app available
• You get a chance to try out the exam environment during in-person Week
10 labs
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Format
• Marked out of 100
• Two sections:
• Practical: Programming questions, worth 60 marks
• Theory: Short-answer questions, worth 40 marks
• Each question answered in a separate file
• Submit answers using the givecommand
• Submit as you complete each question
• Check what you have submitted using the givecommand
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Format
Programming questions
• Tests your problem solving and programming ability
• Each question will ask you to implement one function
• Questions will include examples
• Questions will provide sample test cases
• Passing these test cases means your solution mostly works
• Your solution must attempt to solve the problem generally
• Solutions that just hardcode return values for provided tests will receive
zero
• Each question will specify a file to implement your solution in
• Starter version of file will be provided
• Makefile and main program will be provided
• If solution requires ADT(s), they will be provided
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Format
Programming questions
• Helper functions allowed
• Defining your own #defines, structs, enums allowed
• Using any functions provided by #included libraries allowed
• Global/static variables strictly forbidden
• Inefficient solutions (within reason) allowed unless specified
• Questions may specify additional constraints
• E.g., no while loops, for loops, or goto
• E.g., time complexity must not be worse than O(n)
• Your solution must abide by these constraints or you may receive fewer
marks (or zero) for the question
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Format
Programming questions
• Solutions will be automarked
• All solutions will be manually inspected
• To ensure constraints have been followed
• No marks awarded for style
• But a human marker needs to be able to deduce the behaviour of your
program
• Solutions receiving less than 50% from automarking may receive partial
marks for making substantial progress towards a correct solution
• Resulting mark will not be greater than 50%
• Marks awarded for code only - pseudocode or English description is not
worth marks
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Format
Short-answer questions
• Theory questions
• Tests your knowledge, understanding, critical thinking
• Proofs not required
• Most questions will require explanation/justification
• If question does not ask for explanation, then no need
• Questions may have sub-questions
• Each question will specify a file to write your answers in
• Starter version of file will be provided
• Each file will clearly indicate where to write answers for each sub-question
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Exam Hurdle
To pass the exam hurdle, you must:
• score at least 40% on the final exam
• score at least 25% (15/60) on the practical section
• score at least 25% (10/40) on the theory section
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Scaling
• Scaling depends on mark distribution
• We manually inspect the work of students just below the pass threshold
• If we see many students who’ve sufficiently shown competency with basic
course material but have not passed, exam mark may be scaled up
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Special Exam Conditions
• Students with extra exam time approved by ELS will be given extra time
• Handled by CSE Exams team
• Exam paper shows the standard time limit (3 hours), any extra time is
additional to it
• Email us if you have any concerns regarding ELS conditions
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Special Consideration
• The exam is covered by UNSW’s fit-to-sit policy
• By starting the exam:
• You are saying “I am well enough to finish the exam”
• You cannot apply for Special Consideration for issues that existed prior to
the exam
• If you are unwell before the exam:
• Do not attend the exam
• See a doctor and get a medical certificate ASAP
• Apply for Special Consideration
• If you become unwell during the exam: talk to an exam supervisor ASAP
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Supplementary Exam
• If you miss the original exam due to illness/misadventure
• Apply for special consideration - you may be eligible for a supplementary
exam
• Supplementary exams will take place between Monday 8th September
and Friday 12th September, and will be in person, just like the final exam
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Revision Strategy
How to revise?
• Re-read lecture slides
• Review tutorial questions, lab exercises, quizzes
• Redo them without looking at answers/solutions
• Do extra lab exercises and practice exercises
• Try to understand/reproduce lecture code
• Programming is a skill that improves with practice
• Attempt sample exam and past exams (multiple past papers available)
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Course Evaluation
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Course Evaluation
Course evaluation via myExperience:
• How did we do?
• What did you like?
• What could be improved?
• Let us know!
• https://myexperience.unsw.edu.au
• Please give your tutors feedback - myExperience is the best way to give
them feedback, and it will more likely than not make their day.
• Please give specific feedback
• Specific feedback is more actionable
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Course Evaluation
Incentive for myExperience completion:
• At the 60% response rate, and for every 10% after:
• We will add a hint to one randomly chosen exam (programming) question
• Hints will be added to questions at 60%, 70%, 80%, …
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Thank You
A big thank you to:
• Our lovely teaching staff
• Admins
• Tutors and lab assistants
• Forum staff
• Help session staff
• All of you!
• For engaging with the course and giving it your all!
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
Good Luck
Good luck!
🎉
We hope what you’ve learned in this course will be useful.
We hope you get the mark you’re aiming for!
COMP2521
25T2
Course
Review
Final Exam
Course
Evaluation
Final Words
And Finally…
Good luck with the exam, and with your future studies!


================================================================================

[24/24] week10lect02-revision.pdf
---------------------------------

COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
COMP2521 25T2
Revision Lecture (Based on Requests)
Sim Mautner
cs2521@cse.unsw.edu.au
What if my question isn’t answered today?
Hamiltonian Path Algorithm
Doubly Linked Lists
Specific Student Questions
Exam Questions
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
What if my question isn’t answered today?
• Lots of great questions were asked in the poll
• We won’t have time to answer all of them
• For the most general questions, I will produce a reference guide
indicating where in the lectures you can find your answers
• For the more specific questions (and if you have some after watching the
lectures), I recommend organising a consultation time with me. That way
I’ll be able to answer your question(s).
Alternatively, if there is high enough demand (eg at least 10 students
committing to attending live, online), I’ll gladly conduct a follow-on lecture in
the same or similar format early next week.
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Hamiltonian Path
Clarifying the task:
• Hamiltonian - visit each vertex exactly once
• Not all edges need to be ”drawn over”
• Edges can be ”drawn over” more than once
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Hamiltonian Path
Approach:
• DFS throughout the graph
• Record which nodes have been visited
• As we unwind (backtrack in the DFS) (before we find a HP) record those
nodes as ”not visited” as, if we find a path, those nodes will not be on
our successful path
• Don’t visit a node more than once (this is default in DFS)
• If at the end of the DFS, if all nodes have been visited, then we have a
Hamiltonian Path
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Hamiltonian Path
One more thing to remember:
• Whether a Hamiltonian Path is found or not depends on which node we
start on
• To address this, we need to repeat the above process using each node in
the graph as a starting node, until we find a Hamiltonian Path
• Once we have done this (DFS starting on each node), if no Hamiltonian
Path has been found, then there is no Hamiltonian Path in the graph.
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Hamiltonian Path
Why set visited[v]to false at the end of dfsHamiltonianPath?
Why start DFS on every node, not just one?
0
1
2
3
4
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Benefits
Implementation
Inserting
Deleting
Quick(ish)
Specific
Questions
Doubly Linked Lists - Benefits
Why might we want doubly linked lists?
• It allows us to move forwards and backwards within a list.
• Depending on the implementation, it can allow easier access to items
towards the end of the list.
• Inserting and deleting from the middle of the list (eg ordered lists) in
particular can be considered ”less fiddly”
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Benefits
Implementation
Inserting
Deleting
Quick(ish)
Specific
Questions
Doubly Linked Lists - Implementation
struct node {
Item data;
struct node *prev;
struct node *next;
};
struct list {
struct node *head;
struct node *tail;
};
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Benefits
Implementation
Inserting
Deleting
Quick(ish)
Specific
Questions
Doubly Linked Lists - Inserting
• At the start
• At the end
• In the middle
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Benefits
Implementation
Inserting
Deleting
Quick(ish)
Specific
Questions
Doubly Linked Lists - Deleting
• From the start
• From the end
• From the middle
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
How to decide whether to use adj matrix, or adj list when answering a graph
question (exam style)
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Best way to make use of the Data Structures and Algorithms Manual for exam
style questions
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Deriving time complexity from written code.
Let’s look at Q1c in
https://cgi.cse.unsw.edu.au/~cs2521/25T2/past-exam/22T1.
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
More theory exam questions:
Let’s look at Q3a,b, Q4, Q5b in
https://cgi.cse.unsw.edu.au/~cs2521/25T2/past-exam/22T1.
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Programming exam question(s):
Let’s look at Q9 or Q10 in
https://cgi.cse.unsw.edu.au/~cs2521/25T2/past-exam/22T1.
COMP2521
25T2
What if my
question isn’t
answered
today?
Hamiltonian
Path
Doubly Linked
Lists
Quick(ish)
Specific
Questions
Cheapest Flights Within K Stops leetcode:
https://leetcode.com/problems/
cheapest-flights-within-k-stops/description/


================================================================================

